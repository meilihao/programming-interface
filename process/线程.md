# 线程

### 可执行文件转进程
sys_execve -> do_execve -> load_elf_binary -> 具体程序

> PID 1 的进程是init 进程 systemd,PID 2 的进程是内核线程 kthreadd, 其中用户态的不带中括号,内核态的带中括号. `ps -ef`的tty列是`?`表示不是前台启动的,一般都是后台的服
务
> 用户态的进程,祖先都是 1 号进程; 所有带中括号的内核态的进程,祖先都是 2 号进程

### 线程
参考:
- [programming with posix threads]

对于任何一个进程来讲,即便我们没有主动去创建线程,进程也是默认有一个主线程的.

使用进程实现并行执行的问题:
1. 创建进程占用资源太多
2. 进程之间的通信需要数据在不同的内存空间传来传去, 共享起来复杂

线程的数据:
1. 线程栈上的本地数据 : 栈的大小可以通过命令 ulimit -a 查看,默认情况下线程栈大小为 8192(8MB); 也可通过`pthread_attr_setstacksize()`修改
    主线程在内存中有一个栈空间,其他线程栈也拥有独立的栈空间. 为了避免线程之间的栈空间踩踏,线程栈之间还会有小块区域,用来隔离保护各自的栈空间. 一旦另一个线程踏入到这个隔离区,就会引发**段错误**
1. 在整个进程里共享的全局数据
    需要Mutex解决并发操作
1. 线程私有数据 (Thread Specific Data), 可通过`pthread_key_create()`创建

> pthread_mutex_lock()会阻塞
> pthread_mutex_trylock()不阻塞, 而是等待通知, 当它接到了通知,来操作共享资源的时候,还是需要抢互斥锁,因为可能很多人都受到了通知,都来访问了,所以**条件变量和互斥锁是配合使用**的

## FAQ
### 进程, 线程, 协程关系
三者的核心关系
维度	进程	线程	协程
资源分配	操作系统资源分配的基本单位，拥有独立的地址空间、文件描述符、内存等	共享进程资源, 但拥有独立的栈	共享线程资源
调度单位	操作系统内核	操作系统内核	用户程序（事件循环）
切换开销	高（涉及内核态切换）	中（需内核介入）	极低（纯用户态）
并发能力	多进程并行（多核）	多线程并行（多核）	单线程内高并发（I/O Bound）
通信方式	IPC（管道、共享内存等）	共享内存（需同步）	直接共享变量（无锁）
隔离性	强（崩溃无影响）	弱（线程崩溃可能拖垮进程）	无隔离（同线程内）

进程至少包含一个主线程

实际应用中的组合:
- 多进程 + 多线程（如Web服务器Nginx）

    进程提供稳定性，线程处理并发请求。

- 单线程 + 多协程（如Python的asyncio）

    协程处理高并发I/O，避免线程切换开销。

- 多进程 + 协程（如Go语言的GMP模型）
    
    进程利用多核，协程实现轻量级并发