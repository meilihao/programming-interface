# 线程

### 可执行文件转进程
sys_execve -> do_execve -> load_elf_binary -> 具体程序

> PID 1 的进程是init 进程 systemd,PID 2 的进程是内核线程 kthreadd, 其中用户态的不带中括号,内核态的带中括号. `ps -ef`的tty列是`?`表示不是前台启动的,一般都是后台的服
务
> 用户态的进程,祖先都是 1 号进程; 所有带中括号的内核态的进程,祖先都是 2 号进程

### 线程
参考:
- [programming with posix threads]

对于任何一个进程来讲,即便我们没有主动去创建线程,进程也是默认有一个主线程的.

使用进程实现并行执行的问题:
1. 创建进程占用资源太多
2. 进程之间的通信需要数据在不同的内存空间传来传去, 共享起来复杂

线程的数据:
1. 线程栈上的本地数据 : 栈的大小可以通过命令 ulimit -a 查看,默认情况下线程栈大小为 8192(8MB); 也可通过`pthread_attr_setstacksize()`修改
    主线程在内存中有一个栈空间,其他线程栈也拥有独立的栈空间. 为了避免线程之间的栈空间踩踏,线程栈之间还会有小块区域,用来隔离保护各自的栈空间. 一旦另一个线程踏入到这个隔离区,就会引发**段错误**
1. 在整个进程里共享的全局数据
    需要Mutex解决并发操作
1. 线程私有数据 (Thread Specific Data), 可通过`pthread_key_create()`创建

> pthread_mutex_lock()会阻塞
> pthread_mutex_trylock()不阻塞, 而是等待通知, 当它接到了通知,来操作共享资源的时候,还是需要抢互斥锁,因为可能很多人都受到了通知,都来访问了,所以**条件变量和互斥锁是配合使用**的