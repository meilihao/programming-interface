# process

## 程序和进程
程序(program)是存储上的可执行文件. 进程(process)是程序在内存执行时的实体即进程是由内核定义的抽象的实体.

在类unix中, 每个进程都有一个唯一的数字标识符，称为进程ID（process ID）,也叫pid, 进程ID是一个非负整数.

Linux 内核默认限制进程号需小于等于 32767. 新进程创建时,内核会按顺序将下一个可用的进程号分配给其使用. 每当进程号达到 32767 的限制时,内核将重置进程号计数器(到300, 因为低数值的进程号为系统进程和守护进程所长期占用),以便从小整数开始分配.

> 进程号的默认上限可以通过 Linux系统特有的/proc/sys/kernel/pid_max 文件来进行调整(其值=pid默认最大值+1), 但32 位平台
中, pid_max 文件的最大值为 32768; 64位则允许是2^22.
> pid默认最大值受`<linux/threads.h>`中定义的PID最大值的限制.

每个进程都有一个创建自己的父进程, 可通过`getppid()`获得, 因此存在进程tree的概念. 同样也可通过由 Linux 系统所特有的`/proc/${PID}/status` 文件所提供的 ppid 字段获得.

进程可认为是一个用户地址空间和内核描述该进程的一组内核数据结构共同组成: 其中用户内存空间包含了程序代码及代码所使用的变量,而内核数据结构则用于维护进程状态信息. 
记录在内核数据结构中的信息包括许多与进程相关的标识号(IDs)、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息.

先看看linux正在运行的进程:
```sh
$ps -eo pid,comm,args
```

> `comm`是进程的简称(即执行程序的名称);`args`是进程所对应的程序(可能含有路径)以及运行时所带的参数

也可使用`pstree`命令来展示当前的进程树.

POSIX进程的内存布局, 其分为三大段:
- 正文/文本段(比如程序代码) : 只读
- 数据段(比如变量, 通过`brk()`增长)

	- 初始化数据段包含显式初始化的全局变量和静态变量
	- 未初始化数据段包含了未进行显式初始化的全局变量和静态变量

		程序启动之前,系统将本段内所有内存初始化为 0. 出于历史原因, 此段常被称为 BSS 段(block started by symbol).
- 堆栈段

	- 栈(stack)

		一个动态增长和收缩的段,由栈帧(stack frames)组成. 系统会为每个当前调用的函数分配一个栈帧. 栈帧中存储了函数的局部变量(所谓自动变量)、实参和返回值.

	- 堆(heap)

		可在运行时(为变量)动态进行内存分配的一块区域. 堆顶端称作 program break(可通过brk()和 sbrk()调整).

> 堆向上增长, 栈向下增长.
> `brk()`不属于POSIX.

程序的具体构成:
- 二进制格式标识

	每个程序文件都包含用于描述可执行文件格式的元信息(metainformation). 内核(kernel)会利用此信息来解释文件中的其他信息. 现在,大多数 UNIX 实现(包括 Linux)采用可执行连接格式(ELF)

- 机器语言指令 : 对程序算法进行编码
- 程序入口地址 : 标识程序开始执行时的起始指令位置
- 数据 : 程序文件包含的变量初始值和程序使用的字面常量(literal constant)值(比如字符串)
- 符号表及重定位表 : 描述程序中函数和变量的位置及名称. 这些表格有多种用途,其中包括调试和运行时的符号解析(动态链接)
- 共享库和动态链接信息 : 程序文件所包含的一些字段,列出了程序运行时需要使用的共享库,以及加载共享库的动态链接器的路径名
- 其他信息 : 程序文件还包含许多其他信息,用以描述如何创建进程

> 应用程序二进制接口(ABI)是一套规则,规定了二进制可执行文件在运行时应如何与某些服务(诸如内核或函数库所提供的服务)交换信息. ABI 特别规定了使用哪些寄存器和栈地址来交换信息以及所交换值的含义.
> 在大多数 UNIX 实现(包括 Linux)中 C 语言编程环境提供了 3 个全局符号(symbol):etext、edata 和 end,可在程序内使用这些符号以获取相应程序文本段、初始化数据段和非初始化数据段结尾处下一字节的地址.

## 进程控制
有三个用于进程控制的主要函数： fork, exec和waitpid, 其中exec函数有7种变体，但经常统称它们为exec函数.

### 状态
- 运行中(实际占用cpu)
- 就绪(可运行, 但还未分配到cpu)
- 阻塞中(需要某种条件, 无法运行)

![](/misc/img/os/961dcc4764f2e60c09fa5255a02ba71f.png)

Linux进程状态:
![](/misc/img/os/linux_process_state.png)

## 进程和线程
尽管在UNIX中，进程与线程是有联系但不同的两个东西，但**在Linux中，线程只是一种特殊的进程, 它们都被抽象为task**,多个线程之间可以共享内存空间和IO接口.所以，进程是Linux程序的唯一的实现方式.

> 在现代os中, 进程提供两种虚拟机制: 虚拟处理器和虚拟内存.

通常, 一个进程只有一个线程(thread, 进程中一个**单一顺序**的控制流), 但也允许有多个线程, 这样可以进行多任务的同时处理和充分利用多核处理器的**并行**能力.

一个进程内的所有线程会共享同一地址空间, 文件描述符, 栈以及与进程相关的属性, 因此访问共享数据时需要**同步措施来避免不一致性**, 但它也有独立的程序计数器, 栈和一组寄存器. 与进程相同, 线程也有ID, 但其仅在所属进程内有效.

在引入线程的操作系统中，线程是独立**调度**的基本单位，进程是**资源**拥有的基本单位. 在同一进程中，线程的切换不会引起进程切换; 在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换.

线程:
1. 用户态(1:M) : java

   不需要内核支持而在用户程序中实现的线程, 其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程.

   优点: 线程切换简单, 进程可以有自定义的调度算法.
   缺点: 操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞, 即用户级线程是OS内核不可感知的; 用户级线程不能利用系统的多核处理，仅有一个用户级线程可以被执行
1. 内核级(1:1)

   由操作系统内核创建和撤销, 内核维护进程及线程的上下文信息以及线程切换.一个内核线程由于I/O操作而阻塞，不会影响其它线程的运行.

   优点: 可以利用多核
   缺点: 线程在用户态的运行，而线程的调度和管理在内核实现，在控制权从一个线程传送到另一个线程需要用户态到内核态再到用户态的模式切换，比较占用系统资源.

1. 混合式(M:N) : go的GPM模型

   内核只识别内核级线程, 其再被用户级线程多路复用.

三种线程模型之间最大的差异就在于用户线程与内核调度实体（KSE，Kernel Scheduling Entity即内核线程）之间的对应关系上:
- 一对一模型（1:1） : 一个用户线程映射到一个内核线程，用户线程在存活期都会绑定到一个内核线程，一旦退出，2个线程都会退出
    优点: 实现简单且实现了真正的并发，多个线程可同时跑在不同的CPU上
    缺点: 借助了操作系统内核来创建、销毁和以及多个线程之间的上下文切换和调度, 代价很大. 比如用户线程起多了，内核线程肯定不够用，那么就需要切换.

	> LinuxThreads与NPTL均采用一对一的线程模型.
- 多对一模型（M:1）　：　多个用户线程(一般从属于单个进程)被映射到一个内核线程
    优点: 多个用户线程切换非常的轻量快速，不需要内核线程上下文切换(即不会陷入到内核态)
    缺点: 1个进程的所有协程都绑定在1个线程上, 该程序用不了硬件的多核优势; 如果一个线程阻塞了，那么映射到同一个内核线程的用户线程将都无法运行(因为内部线程对CPU是不可见的，此时可以理解为阻塞的是用户进程)
- 多对多模型（M:N） :　综合以上两种模型，即用户调度器实现用户线程到KSE的"调度"，内核调度器实现KSE到CPU上的"调度", 但实现最为复杂．golang采用的就是这种方式.

> 内核调度实体 KSE 就是指可以被操作系统内核调度器调度的对象实体.
> 用户态线程也叫协程（co-routine）
> 类nix实现了POSIX1003.1c标准的线程模型即pthread.
> 内核线程只工作在内核态中；而用户线程则既可以运行在内核态（执行系统调用时），也可以运行在用户态
> 多线程进程: **每个线程有自己的线程控制块, 用户栈, 内核栈**.

ULT(user level thread, 用户态线程)和KLT(kernel level thread, 内核态线程即轻量级进程)比较:
- ULT优势

	1. 所有线程在用户态, 不用上下文切换, 减少切换开销
	1. 可以定制更合适的调度策略, 而不会干扰kernel的调度
	1. ult可在任何os中运行, 而不用修改kernel
- ULT劣势

	1. ult阻塞时会阻塞进程中的所有线程
	1. ult无法充分利用多核技术: kernel一次只能把一个进程分配给一个cpu核心.

> windows中所有管理线程的工作由kernel完成(kernel提供api), 因此它是纯KLT.

## 进程分类
- 系统进程: 进行内存分配, 进程切换等管理工作. 不受普通用户甚至root的干预
- 用户进程: 执行用户程序.

	细分:
	- 交互进程: 由shell启动的进程, 在执行过程中, 需要与用户进行交互, 可运行在前/后台
	- 批处理进程: 一个进程集合, 负责按顺序启动其他的进程
	- 守护进程: 一直运行的进程, 不与终端关联, 周期性执行某种任务或等待处理某些发生的事件.


## 上下文(context)
执行上下文(execution context)又称为进程状态(process state), 是os用来管理和控制进程所需的内部数据. 可简单理解为被运行中的进程加载到寄存器的数据集.

上下文切换(context switching) : 存储运行中的进程的上下文, 然后将下一个要运行的进程的上下文恢复到寄存器的过程.

> 存储上下文的位置: 进程描述符和内核模式堆栈区域

### 进程实现
在 Linux 里面，无论是进程，还是线程，到了内核里面，统一都叫任务（Task），由一个统一的结构 [task_struct](https://elixir.bootlin.com/linux/latest/source/include/linux/sched.h#L632) 进行管理.

task_struct即进程描述符(process descriptor)也叫进程控制块(PCB))存在任务队列(task list, 双向循环链表)中.

task_struct包括:
- 它打开的文件
- 进程的地址空间
- 挂起的信号
- 进程的状态
- 等等

linux使用slab分配task_struct, 便于对象复用和缓存着色(cache coloring).

进程在内核态运行时需要自己的堆栈信息, 因此linux内核为每个进程都提供了一个内核栈kernel stack.

整个内核栈可分为四个部分，从低地址开始依次为:
1. thread_info结构体
2. 溢出标志
3. 从溢出标志开始到kernel_stack之间的实际可用栈内存空间，kernel_stack为percpu变量，通过它可间接找到内核栈的起始地址
4. 从kernel_stack到栈底的长度为KERNEL_STACK_OFFSET的保留空间

内核引入thread_info的一大原因是方便通过它直接找到进(线)程的task_struct指针，x86 平台的thread_info结构体定义在`<asm/thread_info.h>`. 但Linux内核引入percpu变量之后，逐渐通过percpu变量来实现current宏，并且从Linux 4.1开始，x86移除了kernel_stack，并逐渐开始简化thread_info结构体，直到Linux 4.9彻底不再通过thread_info获取task_struct指针，而是直接通过current_struct percpu变量存放task_struct的指针.

task_struct包含一个指向父进程的parent指针和一个指向子进程的children 链表.

init进程的进程描述符是作为init_task静态分配的.

查找init: `for (task = current; task != &init_task; task=task->parent)`
对于给定进程, 获取task list中的下一个进程`list_entry(task->task.next, struct task_struct, tasks)`(by next_task(task)宏);获取上一个进程`list_entry(task->task.prev, struct task_struct, tasks)`(by prev_task(task)宏)
遍历task list: `for_each_process(task)`, 开销较大.

### 线程实现
linux将线程当做进程来实现.

线程仅是在call clone时传递一些参数标志来指明需要共享的资源: `clone(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND, 0)`

> windows和sum solaris等提供专门的线程机制(也叫轻量级进程, lightweight process).
> [clone()参数标志](Linux内核设计与实现v3-3.4.1 创建线程), 它定义在`<linux/sched.h>`

内核线程和普通进程的区别是它没有独立的地址空间(即指向地址空间的mm属性被设为NULL), 它只运行在内核空间, 可被调度和抢占.
内核线程只能由其他内核线程创建, 并从kthreadd内核进程中衍生出来, 创建接口定义在`<linux/kthread.h>`中. 新创建的线程处于不可运行状态, 需要wake_up_process()唤醒.

## 进程组(process group)
每个进程除了有进程id外, 还隶属于一个进程组. 进程组是一个或多个**进程**(进程+子进程+后裔进程)的集合.进程组会有一个进程组领导进程 (process group leader)，领导进程的PID则成为进程组的ID (process group ID, PGID)，以识别进程组.
PGID不会因领导进程退出而受到影响，且fork调用也不会改变PGID.

> `pstree -pg`可查看进程的pid和pgid, 也可通过`ps`查看.
> linux和unix的新进程由fork而来, 因此原远程的pid就是当前进程的ppid.
> 当用户从键盘发出一个信号时, 该信号会被送给当前与键盘相关的进程组中的所有成员.

```sh
➜  ~ ps -ax -o pid,pgid,ppid,args| cat # `-ax`=`-A`
  PID  PGID  PPID COMMAND
15967 15967  4325 /usr/bin/zsh
16547 16547 15967 ps -o pid,pgid,ppid,args
16548 16547 15967 cat
```

## 会话(session)
一个或多个**进程组**的集合.新建会话时，当前进程（会话中唯一的进程）成为会话首进程(session leader)，也是当前进程组的组长进程，其进程号为该会话的SID(session id).它通常是登录 shell，也可以是调用`setsid`成功新建会话的孤儿进程.

会话的每个进程组称为一个工作(job).一个会话一般包含**一个会话首进程、至多一个前台进程组和任意个后台进程组，控制终端(由这些组共享)可有可无**.

打开控制终端会致使会话首进程成为终端的控制进程即会话首进程与终端挂钩了. 一旦断开了与终端的连接(比如,关闭了终端窗口),控制进程将会收到 SIGHUP 信号.

> 一个终端至多只能成为一个会话的控制终端.

前后台进场分工:
- 前台进程组 : 该进程组中的进程可以向终端设备进行读、写操作（属于该组的进程都可以从终端获得输入）.通常用该进程组的`PGID=TPGID`来判断前台进程组.
- 后台进程组 : 该进程组中的进程只能向终端设备进行写操作.

```sh
➜  ~ ps -A -o pid,pgid,ppid,sid,args,tty,tpgid
  PID  PGID  PPID   SID COMMAND                     TT       TPGID
 4326  4326  4321  4326 /usr/bin/zsh                pts/0     9125
 9119  9119  4326  4326 ping localhost -c 10        pts/0     9125
 9125  9125  4326  4326 ps -o pid,pgid,ppid,sid,arg pts/0     9125
```

**进程组领导进程不能成为新会话首进程，但新会话首进程必定成为进程组领导进程.**

一个命令可以通过在末尾加上&方式让它在后台运行:
```sh
➜  ~ ping localhost -c 4 & 
[1] 6954 # 1表示工作号,6954为PGID
```

结束工作:
```sh
$kill -SIGTERM -6954 #通过在PGID前面加-来表示是一个PGID而不是PID
```
或者
```sh
$kill -SIGTERM %1 #发送给工作1
```

查看后台工作:
```sh
$fg %1
```

将当前运行的程序放在后台:
```sh
<CTRL> + z
```

停止执行当前运行的程序:
```sh
<CTRL> + c
```

列出所有后台程序:
```sh
$ jobs
```

## env
每个进程都有一份kv形式的环境列表, 由 fork()创建时继承自父进程的环境副
本. 这也为父子进程间通信提供了一种机制. 当进程调用 exec()时可指定新的环境列表.

在绝大多数 shell 中,可使用 export 命令来创建环境变量. 当前shell的环境变量可通过`env`命令查看.

set,env,export的区别:
- set : 显示(设置)**shell变量**,包括的私有变量以及用户变量，不同类的shell有不同的私有变量(bash,ksh,csh每中shell私有变量都不一样)
- env : 显示(设置)**用户环境变量**
- export : 显示(设置)当前**导出成**用户环境变量的shell变量

## 命令行参数
argv[0]包含了调用程序的名称,可以利用这一特性玩个实用的小技巧. 首先为同一程序创建多个链接(即名称不同)
,然后让该程序查看 argv[0],并根据调用程序的名称来执行不同任务, poweroff, reboot,half命令均是该技术应用的一个例子.

SUSv3 规定使用 ARG_MAX 常量(定义于`<limits.h>`)或者调用`sysconf (_SC_ARG_MAX)`函数以确定argv容量的上限值.

## init进程
系统引导时,内核会创建一个名为 init 的特殊进程,即"所有进程之父",该进程的相应
程序文件为`/sbin/init`(当前主流是systemd). 系统的所有进程不是由 init(使用 frok())`亲自`创建,就是由其后代
进程创建. init 进程的进程号总为 1,且总是以超级用户权限运行. 谁(哪怕是超级用户)都
不能`杀死`init 进程,只有关闭系统才能终止该进程. init 的主要任务是创建并监控系统运
行所需的一系列进程.

## 终止
终止一个进程有两种方法:
1. 进程可使用_exit()系统调用(或相关的exit()库函数),请求退出
2. 向进程传递信号,将其`杀死`

无论以何种方式退出,进程都会生成`终止状态`,一个非负小整数,可供父进程的 wait()系统调用检测. 在调用_exit()的
情况下,进程会指明自己的终止状态; 若由信号来`杀死`进程,则会根据导致进程`死亡`的信号类型来设置进程的终止状态.
有时会将传递进_exit()的参数称为进程的`退出状态`,以示与被killed的终止状态有所不同,后者(终止状态)要么指传递给_exit()的参数值,要么表示“杀死”进程的信号.

根据惯例,终止状态为 0 表示进程`功成身退`,非 0 则表示有错误发生. 大多数 shell 会
将前一执行程序的终止状态保存于 shell 变量`$?`中.

## 孤儿进程
**父进程先于子进程结束**，这时的子进程应该称作`孤儿进程（Orphan）`，它将被`1`号进程（即init 进程,通常是systemd）接管，init 进程成为其父进程.

## 僵尸进程(Zombie)
**子进程先于父进程结束**，但是其父进程尚未对其进行善后处理（获取已终止子进程的有关信息、释放相关资源）的进程.

一个已经终止,但父进程没有函数调用`wait/waitpid`等待子进程结束，也没有注册`SIGCHLD`信号处理函数，结果使得子进程的进程列表信息无法回收，就变成了僵尸进程.

> unix提供了一种机制可以让父进程知道子进程结束时的状态信息. 这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等, 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等, 要直到父进程通过wait / waitpid来取时才释放.

> kill无法杀死僵尸进程, 因为它已死亡(确保了父进程总是可以执行 wait()方法), 可通过杀死父进程的方法解决; 如果父进程是init, 则需要重启系统.

## 守护进程(daemon)
一个在后台运行并且不受任何终端控制的进程.

> 因此守护进程不属于任何终端, 因此它通过系统调用`syslog`来输出日志. 

守护进程的特点： 
1. 自成进程组，自成会话，与控制终端脱关联
2. 守护进程的父进程是1号进程
3. 守护进程的命令一般以字符d结尾 
4. 守护进程的生命周期是7*24小时不掉线

### 创建守护进程为什么要fork两次
1. 第一次fork: 为了脱离终端控制的魔爪. 调用了fork后，子进程拷贝了父进程的会话期、进程组、控制终端等资源、虽然父进程退出了，但是这些资源并没有改变，因此，需要用`setsid`来使得该子进程完全独立出来，从而摆脱其他进程的控制.
2. 第二次fork(不是必须的): 子进程调用`setsid`后成立了会话首进程,有了打开控制终端的能力，再fork一次，孙子进程就不能打开控制终端了(没调用`setsid`,不是会话首进程).

## 守护进程与后台进程

通过&符号，可以把命令放到后台执行。它与守护进程是不同的：
- 守护进程与终端无关，是被init进程收养的孤儿进程；而后台进程的父进程是终端，仍然可以在终端打印
- 守护进程在关闭终端时依然坚挺；而后台进程会随用户退出而停止，除非加上nohup
- 守护进程改变了会话、进程组、工作目录和文件描述符，后台进程直接继承父进程（shell）的

> 换句话说：守护进程就是默默地奋斗打拼的有为青年，而后台进程是默默继承老爸资产的富二代.

## 查看进程的信息
```sh
ll /proc/$PID
```

output:
- cwd : 符号链接,指向进程执行目录
- exe : 符号连接,执行程序的绝对路径\
- cmdline : 程序运行时输入的命令行命令
- environ : 进程运行时的环境变量
- fd : 目录,进程打开或使用的文件的符号连接

> 内核进程的话`/proc/$PID/exe`不指向具体路径.
> top -p $PID中该内核进程的VIRT和RES都显示为0

## 进程时间
一个进程维护3个时间:
- real : 进程运行的总时间
- user : 用户态的cpu时间,即cpu执行用户指令所用时间
- sys : 内核态的cpu时间,即cpu执行内核程序所用时间

## 工作目录
进程的当前工作目录继承自其父进程. 进程可以用chdir函数更改其工作目录.

## 文件描述符(file descriptor)
文件描述符是一个小的非负整数, kenel用以标识一个特定进程正在访问的文件. 当内核打
开一个现有文件或创建一个新文件时, 它就返回一个文件描述符. 当读、写文件时，就可使
用它.

## 进程时间
即CPU时间, 用以度量进程使用的CPU资源，是用户CPU时间和系统CPU时间之和.

进程时间以时钟滴答计算, 通常每秒钟取为 50、60或100个滴答.

当度量一个进程的执行时间时(比如time命令), 类Unix系统会使用三个时间值:
- 时钟时间 : 进程运行的时间段
- 用户CPU时间 :　执行用户指令所用的时间量
- 系统CPU时间 :　为该进程执行内核指令所用的时间

> 时钟滴答可使用sysconf函数获取, example中有示例.

## 错误处理
在类unix系统中, 函数出错时通常会返回一个负值, 而且整型变量errno通常设置为具有特定信息的一个值.

文件`<errno.h>`中定义了变量errno以及赋与它的各种常量. 这些常量都以`E`开头.

在支持多线程的环境中, 每个线程都有属于自己的局部errno, 以避免相互干扰.

> Unix手册第 2部分的第 1页， intro(2) 列出了所有这些出错常量; 而linux是包含在errno(3)手册页中.

### 出错恢复
错误分为两类: 致命性和非致命性.

发生致命性错误后, 程序通常会输出错误信息并退出, 但也允许拦截该错误自行处理, 比如golang的`recover()`. 

常见的处理非致命错误的方法是: 等待再重试.

## stdin(0), stdout(1), stderr(2)
通常运行一个程序时, 所有的shell都为其打开三个文件描述符(更确切地说是程序继承了 shell 文件描述符的副本)：标准输入、标
准输出以及标准出错. 如果不做特殊处理，则这三个描述符都连向终端. 大多数shell都会提供一种方法，使其中任何一个或所有这三个描述符都能重新定向到某一个文件.

> 记忆: 没有(0)要输入(in), 有(1)要输出(out), 其他(2)是错误(err)
> 非守护进程都有一个关联的控制终端, 进程的stdin, stdout, stderr都默认连接到该终端.

## 进程关联的用户id/组id
- 实际用户id/实际组id : 来自登录回话, 表示`我实际上是谁`
- 有效用户id/有效组id/附属组id : 决定了文件访问权限
- 保存的设置用户id/保存的设置组id : 有exec函数使用, 比如`passwd`命令

## 能力(Capabilities)
从kernel 2.2起, Linux 把传统上赋予超级用户的权限划分为一组相互独立的单元即`能力`. 每次特权操作都与特定的能力相关,仅当进程具有特定能力时,才能执行相应操作.
传统意义上的超级用户进程(有效用户 ID 为 0)则相应开启了所有能力.

## 资源限制
使用系统调用 setrlimit(), 进程可为自己消耗的各类资源设定一个上限. 此类资源限制的每一项均有两个相关值:软限制
(soft limit)限制了进程可以消耗的资源总量, 硬限制(hard limit)限制软限制的调整上限. 非特权
进程在针对特定资源调整软限制值时,可将其设置为 0 到相应硬限制值之间的任意值,但硬限制值则只能调低,不能调高.

由 fork()创建的新进程,会继承其父进程对资源限制的设置.
使用 ulimit 命令可调整 shell 的资源限制. shell 为执行命令所创建的子进程会继承上述资源设置.

## 虚拟地址表
由于物理内存的大小是受限制的，所以进程运行在自身的内存沙盒内即“虚拟内存地址（virtual address space）”，也称作 虚拟内存（Virtual Memory）.

字节在这个虚拟地址空间内的地址不再和处理器放在地址总线上的地址相同. 因此必须建立转换数据结构和系统将虚拟地址空间中的字节映射到物理字节.

虚拟地址可参见下图(`/proc/$PID/maps`)
[](https://cdn-images-1.medium.com/max/1300/1*ImbY2Tb3wZaeuKblwarFTg.jpeg)

当 CPU 执行一个指令需要引用内存地址时。首先将在 VMA（Virtual Memory Areas）中的逻辑地址转换为线性地址。这个转换通过 MMU 完成.
[](https://cdn-images-1.medium.com/max/1040/1*xek5BQhJhWqsOPAaA5uROw.png)

由于逻辑地址太大几乎很难独立的管理，所以引入`页（pages）` 进行管理。当必要的分页操作被激活后， 虚拟地址空间被分成更小的称作页的区域 （大部分操作系统下是 4KB，可以修改）。页是虚拟内存中数据内存管理的最小单元。**虚拟内存不存储任何内容，而是简单的将程序地址空间映射到底层物理内存之上**.

如果堆上有足够的空间的满足我们代码的内存申请，内存分配器可以完成内存申请无需内核参与，否则将通过操作系统调用`brk`进行扩展堆，通常是申请一大块内存.

堆内存地址增长,见下图:
- [](https://cdn-images-1.medium.com/max/1040/1*mvi6PRy9wu0KmBcP9YT5Cw.png)

应用程序通过系统调用`brk （sbrk/mmap 等）`获得内存. 内核调用它只更新堆VMA.

> 如何减少内存碎片化呢？答案取决是使用哪种内存分配算法，也就是使用哪个底层库, 比如tcmalloc和jemlloc.

参考:
- [Go 内存分配器可视化指南](https://blog.learngoprogramming.com/a-visual-guide-to-golang-memory-allocator-from-ground-up-e132258453ed)

## example
1. 从标准输入中读取并写入标准输出
```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	reader := bufio.NewReader(os.Stdin)

	for {
		result, err := reader.ReadString('\n')
		if err != nil {
			fmt.Println("stdin read error:", err)
		}
		if result == "\n" {
			fmt.Println("quit!", result)

			break
		}

		fmt.Fprintf(os.Stdout,"output: %s\n", result)
	}
}
```

1. 获取进程的pid
```go
package main

import (
	"fmt"
	"os"
)

func main() {
	fmt.Fprintf(os.Stdout, "pid: %d\n", os.Getpid())
}
```

1. 从输入读取命令并执行
```go
package main

import (
	"bytes"
	"log"
	"os"
	"os/exec"
)

func main() {
	args := os.Args
	if len(args) != 2 {
		log.Println("usage: run cmd")
		os.Exit(1)
	}

	cmdPath, err := exec.LookPath(args[1])
	CheckErr(err)

	cmd := exec.Command(cmdPath)

	var b bytes.Buffer
	cmd.Stdout = &b
	cmd.Stderr = &b

	err = cmd.Start()
	CheckErr(err)

	log.Println("Waiting for command to finish...")
	err = cmd.Wait()
	CheckErr(err)
	log.Printf("Command finished with output: %s\n", string(b.Bytes()))
}

func CheckErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
```

1. 获取每秒的时钟滴答数
```go
package main

import (
	"fmt"
)

/*
#include <unistd.h>
#include <sys/types.h>
#include <pwd.h>
#include <stdlib.h>
*/
import "C"

func main() {
	var sc_clk_tck C.long
	sc_clk_tck = C.sysconf(C._SC_CLK_TCK)
	fmt.Printf("SysConf Clock Ticks: %d\n", sc_clk_tck)
}
```

## 进程的地址空间
在操作系统中,每个进程都是独占内存,互相之间不干扰即有独立的进程内存空间. 可通过pamp命令查看进程的内存空间布局.

进程的地址空间构成:
1. 代码段(Code Segment)/文本段 : 放可执行代码
1. 数据段

   1. 数据 : 已初始化好的变量
   1. bss : 已初始化为零值的变量
1. 堆(heap) : 程序可从该区域(由`malloc()`)动态分配额外内存. 生长方向: 低 -> 高.
1. 栈段(Stack segment)

   存放: 局部变量, 函数参数, 函数调用的返回地址. 生长方向: 高 -> 低.

只有进程使用内存的时候,才会使用内存管理的系统调用来申请,但是这还不代表真的就有了对应的物理内存. 实际上只有真的写入数据的时候,发现没有对应物理内存才会触发一个缺页中断来分配
物理内存.

在堆里面分配内存的系统调用是brk和mmap:
1. 当分配的内存数量比较小的时候使用 brk,会和原来的堆的数据连在一起
1. 当分配的内存数量比较大的时候使用 mmap,会重新划分一块区域

> linux使用伙伴系统(buddy system)来维护空闲分页, 可通过`/proc/buddyinfo`查看伙伴系统的信息.

### 分页回收
分页回收(page reclaiming) : 进程请求不到有效的分页时, kernel将尝试释放一定数量的分页(之前使用但不再使用且基于某些原因仍被标记为活跃的分页), 然后将这些分页分配给该进程.

linux kernel通过内核线程kswapd和内核函数`try_to_free_page()`来回收分页.

## FAQ
### 进程备忘
- jbd(journaling block driver)是文件系统的日志功能，jbd2是ext4文件系统版本.  

	常用的文件系统使用日志功能来保证文件系统的完整性，在写入新的数据到磁盘之前，会先将元数据写入日志；这样做可以保证在写入真实数据前后，一旦发生错误的话, 日志功能将很容易回滚到之前的状态，确保不会发生文件系统崩溃的情况.
	对文件系统的操作太频繁，导致IO压力过大.