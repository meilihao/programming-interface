# ELF
ELF (Executeable and Linkable Format,可执行与可链接格式)是linux 下二进制可执行程序的格式, 可通过`readelf -a xxx`查看.

![程序编译过程](/images/compile/1671100-20190512202937314-1323961004.jpg)

### 可重定位文件 (Relocatable File),
即编译时生成的`.o`文件, ELF 的一种类型

ELF 文件的头是用于描述整个文件的. 这个文件格式在内核中有定义,分别为 `struct elf32_hdr 和 struct elf64_hdr`.

节头部表(Section Header Table)是sections的元数据, 在代码里面的定义是`struct elf32_shdr 和 struct elf64_shdr`

文件的各section:
- .text:放编译好的二进制可执行代码, 进程代码段不仅包括`.text`, 还有`.init`, `.fini`等.
- .data:已经初始化好的全局变量
- .bss:未初始化的全局变量,运行时会分配空间并置零, 因此比`.data`节省空间
    `.bss`的size仅表示程序加载器在加载程序时候, 需要为该段分配的空间大小
- .rodata:只读数据,例如字符串常量、const 的变量
- .symtab:符号表,保存了符号信息, 可通过`readelf -s xxx`查看
- .strtab:字符串表、保存的是被`.symtab`引用的符号名称
- .shstrtab: 用于保存section header中用到的字符串
- .comment :注释信息段
- .node.GUN-stack :堆栈提示段
- .debug: 一个调试符号表
- .eh_frame: 记录调试和异常处理时用到的信息
- 以`.rec`开头的 sections 里面装载了需要重定位的符号

![.o文件的ELF](/images/compile/1671100-20190512203047832-334199166.jpg)

### 可执行文件(Executable File)
ELF 的第二种格式

这个格式和.o 文件大致相似,还是分成一个个的 section,并且被节头表描述. 只不过这些
section 是多个.o 文件合并过的. 但是这个文件已经是可以加载到内存里面执
行的文件了,因而这些 section 被分成了需要加载到内存里面的代码段、数据段和不需要加载到
内存里面的部分,**将小的 section 合成了大的段 segment**,并且在最前面加一个段头表
(Segment Header Table). 在代码里面的定义为 `struct elf32_phdr 和 struct elf64_phdr`,这里
面除了有对于段的描述之外,最重要的是 p_vaddr,这个是这个段加载到内存的虚拟地址. 在 ELF 头里面有一项 e_entry,也是个虚拟地址,是这个程序运行的入口

![可执行程序的ELF](http://scand75.gz01.bdysite.com/l/?n=8&i=blog/1671100/201905/1671100-20190512203151552-476702079.jpg)


基于动态连接库创建出来的二进制文件格式:
- 多了一个.interp 的 Segment,这里面是 ld-linux.so,这是动态链接器, 即运行时的链接动作都是它做的
- ELF 文件中还多了两个 section,一个是.plt,过程链接表(Procedure Linkage Table,PLT),一个是.got.plt,全局偏移量表(Global Offset Table,GOT)

由于是运行时才去找,编译的时候,压根不知道被调用函数在哪里,所以就在 PLT 里面建立一项PLT[x]. 这一项也是一些代码,有点像一个本地的代理,在二进制程序里面,不直接调用
具体的被调函数,而是调用 PLT[x] 里面的代理代码,这个代理代码会在运行的时候找真正的被调函数.

查找具体被调函数的方法: GOT也会为 被调 函数创建一项 GOT[y], 它是运行时 被调 函数在内存中真正的地址. 如果这个地址在, 程序 调用 PLT[x] 里面的代理代码,代理代码调用 GOT 表中对应项 GOT[y],调用的就是加载到内存中的 xxx.so 里面的 具体 函数了.

GOT如何找到具体函数: GOT[y]开始时也没有地址, 但它又回调 PLT, 这个时候 PLT 会转而调用 PLT[0],也即第一项,PLT[0] 转而调用 GOT[2],这里面是 ld-linux.so 的
入口函数,这个函数会找到加载到内存中的 xxx.so 里面的 具体 函数的地址,然后把这个地址放在 GOT[y] 里面. 下次,PLT[x] 的代理函数就能够直接调用了.

### 静/动态链接(Shared Object File)
静态链接库一旦链接进去,代码和变量的 section 都合并了,因而程序运行的时候,就不依赖于这个库是否存在. 但是这样有一个缺点,就是相同的代码段,如果被多个程序使用的话,在内存里面就有多份,而且一旦静态链接库更新了,如果二进制执行文件不重新编译,也不随着更新.

因而就出现了另一种,动态链接库 (Shared Libraries),不仅仅是一组对象文件的简单归档,而
是多个对象文件的重新组合,可被多个程序共享.

> 动态链接库是 ELF 的第三种类型,共享对象文件 (Shared Object)
> 当运行有动态链接的程序时, 首先寻找动态链接库,然后加载它. 默认情况下,系统在 /lib 和/usr/lib 文件夹下寻找动态链接库. 如果找不到就会报错,我们也可以设定 LD_LIBRARY_PATH 环境
变量,程序运行时会在此环境变量指定的文件夹下寻找动态链接库.

### 可执行文件转进程
sys_execve -> do_execve -> load_elf_binary -> 具体程序

> PID 1 的进程是init 进程 systemd,PID 2 的进程是内核线程 kthreadd, 其中用户态的不带中括号,内核态的带中括号. `ps -ef`的tty列是`?`表示不是前台启动的,一般都是后台的服
务
> 用户态的进程,祖先都是 1 号进程; 所有带中括号的内核态的进程,祖先都是 2 号进程

### 线程
参考:
- [programming with posix threads]

对于任何一个进程来讲,即便我们没有主动去创建线程,进程也是默认有一个主线程的.

使用进程实现并行执行的问题:
1. 创建进程占用资源太多
1. 进程之间的通信需要数据在不同的内存空间传来传去, 共享起来复杂

线程的数据:
1. 线程栈上的本地数据 : 栈的大小可以通过命令 ulimit -a 查看,默认情况下线程栈大小为 8192(8MB); 也可通过`pthread_attr_setstacksize()`修改
    主线程在内存中有一个栈空间,其他线程栈也拥有独立的栈空间. 为了避免线程之间的栈空间踩踏,线程栈之间还会有小块区域,用来隔离保护各自的栈空间. 一旦另一个线程踏入到这个隔离区,就会引发**段错误**
1. 在整个进程里共享的全局数据
    需要Mutex解决并发操作
1. 线程私有数据 (Thread Specific Data), 可通过`pthread_key_create()`创建

> pthread_mutex_lock()会阻塞
> pthread_mutex_trylock()不阻塞, 而是等待通知, 当它接到了通知,来操作共享资源的时候,还是需要抢互斥锁,因为可能很多人都受到了通知,都来访问了,所以**条件变量和互斥锁是配合使用**的