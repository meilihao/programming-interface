# lib
现代 UNIX 系统提供两种类型的对象库:静态库和共享库.

**gcc在编译时默认使用动态库**.

有关环境变量：

LIBRARY_PATH ： 指定程序静态链接库文件搜索路径
LD_LIBRARY_PATH ： 指定程序动态链接库文件搜索路径

## 静态库
本质上说来,静态库是对已编译目标模块的一种结构化整合, 其后缀一般为“.a”. 使用时需要在创建程序的链接命令中指定相应的库.

链接器在解析了引用情况后,会从静态库中抽取所需目标模块的副本,将其复制到最
终的可执行文件中,这就是所谓静态链接.

不足之处:
1. 在不同的可执行文件中,可能都存有相同目标代码的副本, 浪费存储和内存.
1. 如果对库函数进行了修改,需要重新加以编译、生成新的静态库,而所有需要调用该函数`更新版`的应用,都必须与新生成的静态库重新链接.

优点: 链接静态库后, 程序在运行时也就不需要库文件了.

### 使用
生成静态库：
```
// 把file1.o和file2.o打包生成静态库libxxx.a
ar cr libxxx.a file1.o file2.o  
```

使用静态库：
```
gcc -o test test.c -L<path> -lxxx
```

### 链接时搜索路径顺序
1. ld(链接器)会去找GCC命令中的参数-L
2. 环境变量LIBRARY_PATH
3. 指定目录/lib,/usr/lib,/usr/local/lib,这些路径是固化在gcc内的.

## 共享库
设计共享库的目的是为了解决静态库所存在的问题, 动态库一般后缀名为“.so”.

如果将程序链接到共享库, 仅是在可执行文件中写入一条记录,以表明可执行文件在运行时需要使用该共享库. 程序载入内存时,一款名为`动态链接器`的程序会确保将可执行文件所需的动态库找到,
并载入内存, 随后实施运行时链接, 解析可执行文件中的函数调用, 将其与共享库中相应的函数
定义关联起来. 在运行时,共享库代码在内存中只需保留一份,且可供所有运行中的程序使用.

### 使用
生成动态库：
```
gcc -fPIC -shared file1.c -o libxxx.so    
```
即:
```
gcc -fPIC -c file1.c
gcc -shared file1.o -o libtest.so
```

使用动态库(和使用静态库相同)：
```
gcc -o test test.c -L<path> -lxxx
```

### 动态链接时、执行时搜索路径顺序:

1. 编译目标代码时指定的动态库搜索路径
2. 环境变量LD_LIBRARY_PATH
3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径
4. 默认的动态库搜索路径/lib
5. 默认的动态库搜索路径/usr/lib

## 扩展

由于链接动态库和静态库的时候使用的方法是一样的，所以如果在库中有同名的静态库文件和动态库文件，
比如libtest.a和libtest.so，根据gcc链接时默认优先选择动态库，会链接libtest.so，
如果想要让gcc选择链接libtest.a那么需要指定一个选项`-static`,这样就会强制gcc找静态库文件了.