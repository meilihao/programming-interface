# lib
现代 UNIX 系统提供两种类型的对象库:静态库和共享库.

**gcc在编译时默认使用动态库**.

有关环境变量：

LIBRARY_PATH ： 用于在程序**编译期间**查找动态链接库时指定查找共享库的路径
LD_LIBRARY_PATH ： 用于在程序**加载运行期间**查找动态链接库时指定除了系统默认路径之外的其他路径

> xxx.so和xxx.a是给程序编译时用的; 而xxx.h是给开发者调用该lib中的接口时用的, 编译时可以不存在

## 静态库
本质上说来,静态库是对已编译目标模块的一种结构化整合, 其后缀一般为“.a”. 使用时需要在创建程序的链接命令中指定相应的库.

链接器在解析了引用情况后,会从静态库中抽取所需目标模块的副本,将其复制到最
终的可执行文件中,这就是所谓静态链接.

不足之处:
1. 在不同的可执行文件中,可能都存有相同目标代码的副本, 浪费存储和内存.
1. 如果对库函数进行了修改,需要重新加以编译、生成新的静态库,而所有需要调用该函数`更新版`的应用,都必须与新生成的静态库重新链接.

优点: 链接静态库后, 程序在运行时也就不需要库文件了.

### 使用
生成静态库：
```
// 把file1.o和file2.o打包生成静态库libxxx.a
ar cr libxxx.a file1.o file2.o
```

使用静态库：
```
gcc -o test test.c -L<path> -lxxx
```

### 链接时搜索路径顺序
1. ld(链接器)会去找GCC命令中的参数-L
2. 环境变量LIBRARY_PATH
3. 指定目录/lib,/usr/lib,/usr/local/lib,这些路径是固化在gcc内的.

## so/动态库
设计动态库的目的是为了解决静态库所存在的问题, 动态库一般后缀名为`.so`.

如果将程序链接到动态库, 仅是在可执行文件中写入一条记录,以表明可执行文件在运行时需要使用该动态库. 程序载入内存时,一款名为`动态链接器`的程序会确保将可执行文件所需的动态库找到,
并载入内存, 随后实施运行时链接, 解析可执行文件中的函数调用, 将其与共享库中相应的函数
定义关联起来. 在运行时,共享库代码在内存中只需保留一份,且可供所有运行中的程序使用. 因此当多个程序使用同一个动态链接库时，既能节约可执行文件的大小，也能减少运行时的内存占用.

> Linux中的.so文件类似于Windows中的DLL，是动态链接库，也有人译作共享库(因so的全称为Shared Object). 

### 使用
生成动态库：
```
gcc -fPIC -shared file1.c -o libxxx.so    
```
即:
```
gcc -fPIC -c file1.c
gcc -shared file1.o -o libtest.so
```

使用动态库(和使用静态库相同)：
```
gcc -o test test.c -L<path> -lxxx
```

### 动态链接时、执行时搜索路径顺序:

1. 编译目标代码时指定的动态库搜索路径
2. 环境变量LD_LIBRARY_PATH
3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径, 比如`/etc/ld.so.conf.d/*.conf`

    `/etc/ld.so.conf.d`下改动需要执行`sudo ldconfig`刷新
4. 默认的动态库搜索路径/lib
5. 默认的动态库搜索路径/usr/lib

### so存放位置

Linux中绝大多数.so文件都存放在/lib、/usr/lib/（见Linux目录结构），对于64位和32位共存的系统，32位的动态库可能会放在/lib32、/usr/lib32，完整的动态库存放路径列表可通过/etc/ld.so.conf文件配置.（如果修改了配置，需要用 /sbin/ldconfig 命令更新缓存）

**应注意动态库搜寻路径并不包括当前文件夹，所以当即使可执行文件和其所需的so文件在同一文件夹，也会出现找不到so的问题**,如:`./chrome: error while loading shared libraries: libnss3.so.1d: cannot open shared object file: No such file or directory`

此时可用LD_LIBRARY_PATH环境变量做临时设置，如：

```shell
# 将当前目录路径加入LD_LIBRARY_PATH
export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
```

也有些so文件是在程序执行时临时加载的（如插件），它们的路径就比较灵活，只要可执行文件能找到它就行了.

### 程序链接的动态库

Linux下查看so动态链接库的常用命令:
- ldd  查看可执行文件链接(依赖)了哪些系统动态链接库,**推荐**
- nm用来列出目标文件的符号清单.
- ar命令可以用来创建、修改库，也可以从库中提出单个模块。
- objdump：显示目标文件中的详细信息(`objdump -d <command>`，可以查看这些工具究竟如何完成这项任务)
- readelf 显示关于 ELF 目标文件的信息(`readelf -d libffmpeg.so | grep NEEDED`)

### 版本

动态库的版本总是个问题，如果编译时链接的库和执行时提供的不一样，难免会导致程序的执行发生诡异的错误。为解决此问题，Linux系列的做法是这样的：

首先，每个so文件有一个文件名，如libABC.so.x.y.z，这里ABC是库名称，x.y.z是文件的版本号，一般来说：[2]

    第一位x表示了兼容性，x不一样的so文件是不能兼容的
    第二位y的变化表示可能引入了新的特性（Feature），但总的来讲还是兼容的
    第三位z的变化一般表示仅是修正了Bug
    并非所有.so文件都遵循此规则，但其应用确实很普遍

在系统中，会存在一些符号链接：

```
libpam.so -> libpam.so.0.83.0
libpam.so.0 -> libpam.so.0.83.0
```

其中第一个主要在使用该库开发其它程序时使用，比如gcc想连接PAM库，直接连libpam.so就行了，不必在链接时给出它的具体版本. 第二个则主要用在运行时，因为前面说了第一位版本一样的库是互相兼容的，所以程序运行时只要试图连接libpam.so.0就够了，不必在意其具体的版本, ldconfig可以自动生成这些链接.

那么编译程序时gcc在链接一个so文件（如libpam.so）时，如何知道该程序运行时链接哪个文件呢（上例中是libpam.so.0）？原来产生so文件时，可以指定一个soname，一般形如libABC.so.x. 有人编译可执行文件时，如果链接了某个so，存在可执行文件里的.so文件名并不是其全名，而是这个soname. 比如上例中，这个soname就是libpam.so.0. 看一下ldd的结果，可以印证这一现象.

有时还会看到形如libABCn.so，即版本号出现在.so前面的库文件，如libXaw6.so. 此类文件一般是为开发者着想，比如GTK+ 3已经推出，但很多开发者还是想用GTK+ 2开发软件. 由于编译时只连接无版本号的.so文件，就只有把版本号放在.so前面了.

## 扩展

由于链接动态库和静态库的时候使用的方法是一样的，所以如果在库中有同名的静态库文件和动态库文件，
比如libtest.a和libtest.so，根据gcc链接时默认优先选择动态库，会链接libtest.so，
如果想要让gcc选择链接libtest.a那么需要指定一个选项`-static`,这样就会强制gcc找静态库文件了.

1. ld的库搜索顺序
    ```
    $ ld --verbose | grep SEARCH
    ```
1. 如何确定编译的目标target
    ```
    $ ./config.guess # 大部分需编译的软件都会携带该脚本, 比如gcc
    ```