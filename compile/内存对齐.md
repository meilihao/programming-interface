# 内存对齐
参考:
- [golangci-lint : 内存布局优化检查](https://ms2008.github.io/2019/08/01/golang-memory-alignment/)
- [也谈内存对齐](https://tonybai.com/2005/08/09/also-talk-about-memory-alignment/)

现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量. 但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是内存对齐.

为什么:
1. 平台（移植性）
   
   不是所有的硬件平台都能够访问任意地址上的任意数据. 例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况, 比如[go中在 32bit 平台下进行 64bit 原子操作要求必须 8 字节对齐，否则程序会 panic](https://ms2008.github.io/2019/08/01/golang-memory-alignment/).
1. 性能
   
   若**访问未对齐的内存，将会导致 CPU 进行两次内存访问**，并且要花费额外的时钟周期来处理对齐及运算. 而本身就**对齐的内存仅需要一次访问**就可以完成读取动作，这显然高效很多，是标准的空间换时间做法

   ![](/misc/img/compile/T90bhybyeI.png)

> 实际上 CPU 并不会以一个一个字节去读取和写入内存，而是一块一块读取的，块的大小可以为 2、4、6、8、16、32 字节等大小，块(chunk)大小我们称其为内存访问粒度. 假设访问粒度为 4，那么 CPU 就会以每 4 个字节大小的访问粒度去读取和写入内存.

默认情况下,编译器会将结构,栈中的成员数据进行内存对齐. 在不同平台上的编译器都有自己默认的"对齐系数". 一般来讲, 我们常用的 x86 平台的系数为 4；x86_64 平台系数为 8. 需要注意的是，除了这个默认的对齐系数(可通过`#pragma pack(n), n=1,2,4,8,16,32`修改)外，还有不同数据类型的对齐系数, 而且数据类型的对齐系数在不同平台上可能会不一致. 例如，在 x86_64 平台上，int64 的对齐系数为 8，而在 x86 平台上其对齐系数就是 4.

规则：
1、数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照`#pragma pack(n)`指定的数值和这个数据成员自身长度中的较小值的进行对齐, 即`数据结构的每个成员相对结构体首地址的偏移量(offset)%min(当前成员的大小,对齐系数)==0`
2、结构(或联合)的整体对齐(也称作二次对齐)规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中的较小值进行, 即`结构体整体大小 % min(最大成员的大小,对齐系数) == 0`.
3、结合1、2颗推断：当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果.

> 有效对齐值N是最终用来决定数据存放地址方式的值. 有效对齐N表示`对齐在N上`，即该数据的`距离首地址的偏移量offset%N=0` = `(0/(上一个数据成员的结束地址+1)+padding)%N=0, 要求padding最小`.

> 嵌套数据结构, 按照将全部成员展开到顶层再进行对齐即可.

### 指定对齐值的大小
1. `#pragma pack(n), n=1,2,4,8,16,32`

我们可以通过使用#pragma pack(n) 来指定对齐值的大小.  比如:
```c
#pragma pack(1) // 设置对齐值为1
struct mystruct {
    char c;
    int i;
    short s;
};
#pragma pack() // 取消指定对齐, 采用默认对齐方式
```
#pragma pack(1)将结构体及其成员的对齐值设为1, 也就是说结构体中的成员可以从任意的地址位置开始, 此时mystruct的大小为7.

2. `__attribute__((aligned(n)))`
`__attribute__((aligned(n)))` : 让所作用的结构成员对齐在n字节自然边界上. 如果结构中有成员的长度大于n，则按照最大成员的长度来对齐
 `__attribute__((packed))` : 取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐
```c
// 对齐值为16
struct mystruct {
    char c;
    int i;
}__attribute__((aligned(16)));

// 对齐值为4(以i为对齐值)
struct mystruct2 {
    char c;
    int i;
}__attribute__((aligned(2)));

// 按实际占用字节对齐(即1)
struct mystruct3 {
    char c;
    int i;
}__attribute__((packed));
```

## tools
- [golang-sizeof.tips : 可视化 go struct的内存布局](http://golang-sizeof.tips/)
- [structlayout](https://github.com/dominikh/go-tools/tree/master/cmd/structlayout)
- [Golang beautify data display for Humans](https://github.com/go-ffmt/ffmt)
