# stack
![stack 布局](/misc/img/stack_64_2.png)
![stack 布局](/misc/img/stack_64_3.png)

栈是程序运行的基础. 每当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被称为帧（frame）. 栈是自顶向下增长的，一个程序的调用栈最底部，除去入口帧（entry frame），就是 main() 函数对应的帧，而随着 main() 函数一层层调用，栈会一层层扩展；调用结束，栈又会一层层回溯，把内存释放回去.

在调用的过程中，一个新的帧会分配足够的空间存储寄存器的上下文. 在函数里使用到的通用寄存器会在栈保存一个副本，当这个函数调用结束，通过副本，可以恢复出原本的寄存器的上下文. 此外，函数所需要使用到的局部变量，也都会在帧分配的时候被预留出来.

栈通常指保存局部变量，具有先进后出 (FILO) 特性的一段高内存地址空间，维护这个栈结构会使用两个寄存器：栈指针 rsp(stack pointer, 追踪当前栈顶即栈的增长端)、帧指针 rbp. 当程序调用层数比较深时，栈内存呈现出一块一块连续空间，每一块空间属于某一个调用对像，这个块可以称之为帧(stack frame), 即栈帧表示程序的函数调用记录, 用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）.

> 栈的生长方向是从高地址到低地址.
> pop操作后，栈中的数据并没有被清空，只是该数据我们无法直接访问
> 用户栈(user stack)来表示此处所讨论的栈,以便与内核栈区分开来. 内核栈是每个进程保留在内核内存中的内存区域,在执行系统调用的过程中供(内核)内部函数调用使用.

通常所有参数直接用寄存器传递, 而使用栈帧的情况:
- 调用过程中需要的存储空间**超出**寄存器能够存放的大小(最多6个整型参数)时
- 一个局部变量使用了指针
- 某些局部变量是数组或struct

> 通过栈传递参数时, 所有的数据大小都要向8的倍数对齐. 而引用传参时调用代码必定要分配一个栈帧.

寄存器使用顺序: `rdi, rsi, rdx, rcx, r8, r9`

被调用函数的返回结果只能是通过`rax`寄存器返回给调用函数，因此C/C++函数只能返回一个值.

栈帧的大小由编译器决定. 在编译并优化代码的时候，一个函数就是一个最小的编译单元. 在这个函数里，编译器得知道要用到哪些寄存器、栈上要放哪些局部变量，而这些都要在编译时确定. 所以编译器就需要明确每个局部变量的大小，以便于预留空间. 即**在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上**. 比如字符串的数据结构，在编译时大小不确定，运行时执行到具体的代码才知道大小. 因此无法把字符串本身放在栈上，只能先将其放在堆上，然后在栈上分配对应的指针，引用堆上的内存.

**当需要动态大小的内存时，只能使用堆，比如可变长度的数组、列表、哈希表、字典，它们都分配在堆上**. 堆上分配内存时，一般都会预留一些空间，这是最佳实践, 比如go的slice `make(int,0,10)`, 这是因为堆上内存分配会使用 libc 提供的 malloc() 函数，其内部会请求操作系统的系统调用，来分配内存. **系统调用的代价是昂贵的**，所以要避免频繁地 malloc().

除了动态大小的内存需要被分配到堆上外，**动态生命周期的内存(rust)也需要分配到堆上**. 因为栈上内存的生命周期是不受开发者控制的，并且局限在当前调用栈. 而**堆上分配出来的每一块内存需要显式地释放，这就使堆上内存有更加灵活的生命周期，可以在不同的调用栈之间共享数据**.

如果手工管理堆内存的话，堆上内存分配后忘记释放，就会造成内存泄漏. 如果堆上内存被多个线程的调用栈引用，需要加锁以独占访问，来避免潜在的问题. 比如说，一个线程在遍历列表，而另一个线程在释放列表中的某一项，就可能访问野指针，导致堆越界（heap out of bounds）. 而堆越界是第一大内存安全问题. 如果堆上内存被释放，但栈上指向堆上内存的相应指针没有被清空，就有可能发生使用已释放内存（use after free）的情况，程序轻则崩溃，重则隐含安全隐患. 根据微软安全反应中心（MSRC）的研究，这是第二大内存安全问题.

对于存入栈上的值，它的大小在编译期就需要确定. 栈上存储的变量生命周期在当前调用栈的作用域内，无法跨调用栈引用. 理论上说，编译器只要可能，就会把变量分配到栈上，这样可以达到更好的运行速度. 但也会考虑到调用栈的大小，避免栈溢出（stack overflow）, 比如递归函数没有妥善终止.

一句话对比总结就是：**栈上存放的数据是静态的，静态大小，静态生命周期；堆上存放的数据是动态的，动态大小，动态生命周期**.

## 堆内存安全解决
堆上存储的变量，其生命周期从分配后开始，一直到释放时才结束，因此堆上的变量允许在多个调用栈之间引用. 但也导致堆变量的管理非常复杂，手工管理会引发很多内存安全性问题，而自动管理，无论是 GC 还是 ARC(Automatic Reference Counting)，都有性能损耗和其它问题.

常见有两种:
1. gc: 以 golagn, Java 为首的一系列编程语言，采用了追踪式垃圾回收（Tracing GC）的方法，来自动管理堆内存. 这种方式通过定期标记（mark）找出不再被引用的对象，然后将其清理（sweep）掉，来自动管理内存，减轻开发者的负担.

1. arc: 而 OjbC 和 Swift 则走了另一条路：[自动引用计数（Automatic Reference Counting）](https://en.wikipedia.org/wiki/Automatic_Reference_Counting).在编译时，它为每个函数插入 retain/release 语句来自动维护堆上对象的引用计数，当引用计数为零的时候，release 语句就释放对象

对比来看: 从效率上来说，GC 在内存分配和释放上无需或少量额外操作，而 ARC 添加了大量的额外代码处理引用计数，所以 GC 效率更高，吞吐量（throughput）更大. 但GC 释放内存的时机是不确定的，释放时引发的 STW（Stop The World），也会导致代码执行的延迟（latency）不确定. 所以一般携带 GC 的编程语言，不适于做嵌入式系统或者实时系统。当然，Erlang VM是个例外， 它把 GC 的粒度下放到每个 process，最大程度解决了 STW 的问题.

	> 常说的性能是吞吐量和延迟的总体感知，和实际性能是有差异的，GC 和 ARC 就是典型例子. GC 分配和释放内存的效率和吞吐量要比 ARC 高，但因为偶尔的高延迟，导致被感知的性能比较差

## 函数调用栈
- 参数从右向左依次入栈
- call function = push rip + jmp function
- 抬高栈顶，分配临时数据区: `subq &xx, %rsp`

## c stack
参考:
- [函数调用栈](https://www.jianshu.com/p/0299f56edab5)
- [探秘“栈”之旅](https://linux.cn/article-9645-1.html)

不超过6个参数:
```c
#include<stdio.h>

int add(int a, int b, int c) { // 3 个参数相加
    int sum = a + b + c;
    return sum;
}

int main(void) {
    int i = 10;
    int j = 20;
    int sum = add(1, 2, 3);
    return 0;
}
```

`gcc -S demo1.c`:
```asm
	.file	"demo1.c"
	.text
	.globl	add
	.type	add, @function
add:                            ; 参数: %edi,a ; %esi,b ; %edx,c
.LFB0:
	.cfi_startproc              ; 用在每个函数的开始，用于初始化一些内部数据结构, `.cfi`开头的伪指令是辅助汇编器创建栈帧的.
	pushq	%rbp                ; 保存调用者的%rbp = `subq $8, %rsp` + `movq %rbp, (%rsp)`
	.cfi_def_cfa_offset 16		; 表示此处（rsp）距离 CFA 16 字节. CFA（Canonical Frame Address）是标准框架地址,指调用者栈帧中调用点处的栈指针值
	.cfi_offset 6, -16
	movq	%rsp, %rbp          ; 让新的%rbp指向栈顶
	.cfi_def_cfa_register 6
	movl	%edi, -20(%rbp)     ; a 入栈, 从左往右入栈
	movl	%esi, -24(%rbp)     ; b 入栈
	movl	%edx, -28(%rbp)     ; c 入栈
	movl	-20(%rbp), %edx     ; 将a放入%edx
	movl	-24(%rbp), %eax     ; 将b放入%eax
	addl	%eax, %edx          ; a+b放入%edx
	movl	-28(%rbp), %eax     ; 将c放入%eax
	addl	%edx, %eax          ; %edx+c放入%eax
	movl	%eax, -4(%rbp)      ; 将计算结果z, 放入紧靠%rbp的位置,
	movl	-4(%rbp), %eax      ; 将z放入%eax
	popq	%rbp                ; 恢复旧%rbp = `movq (%rsp), %rbp`(读数据)+`addq $8, %rsp`
	.cfi_def_cfa 7, 8
	ret                         ; = popq %rip, 继续执行
	.cfi_endproc 				; 在函数结束的时候使用与.cfi_startproc相配套使用
.LFE0:
	.size	add, .-add
	.globl	main
	.type	main, @function
main:
.LFB1:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	$10, -4(%rbp)   ; i入栈
	movl	$20, -8(%rbp)   ; j入栈
	movl	$3, %edx        ; 第3个参数, 从右往左传参
	movl	$2, %esi        ; 第2个参数
	movl	$1, %edi        ; 第1个参数
	call	add             ; pushp %rip(%rip已是call指令的下一条指令的地址, 通过gdb可了解) + jump add地址入口
	movl	%eax, -12(%rbp)
	movl	$0, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE1:
	.size	main, .-main
	.ident	"GCC: (Debian 6.3.0-18+deb9u1) 6.3.0 20170516"
	.section	.note.GNU-stack,"",@progbits
```

> 使用`gcc -g -O0 demo1.c`生成代码, 之后再用`objdump -S a.out`反汇编后代码比`gcc -S demo1.c`可读性更好
> 对比发现gcc生成的asm比`clang-8 -S demo1.c`的可读性更好.
> .cfi_startproc 和 .cfi_endproc 分别是 dwarf2 CFI 的初始过程和结束过程指令，它们隐藏了一些 CFI 有关的操作

超过6个参数:
```c
#include<stdio.h>

int add(int a, int b, int c, int d, int e, int f, int g, int h) { // 8 个参数相加
    int sum = a + b + c + d + e + f + g + h;
    return sum;
}

int main(void) {
    int i = 10;
    int j = 20;
    int k = i + j;
    int sum = add(11, 22,33, 44, 55, 66, 77, 88);
    int m = k; // 为了观察 %rax Caller Save 寄存器的恢复
    return 0;
}
```

`gcc -S demo2.c`:
```asm
	.file	"demo2.c"
	.text
	.globl	add
	.type	add, @function
add:                         ; 参数: %edi,a ; %esi,b ; %edx,c; %ecx,d; %r8d,e ; %r9d,f
.LFB0:
	.cfi_startproc
	pushq	%rbp             ; 保存调用者的%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp       ; 让新的%rbp指向栈顶
	.cfi_def_cfa_register 6
	movl	%edi, -20(%rbp)  ; 将a~f 入栈
	movl	%esi, -24(%rbp)
	movl	%edx, -28(%rbp)
	movl	%ecx, -32(%rbp)
	movl	%r8d, -36(%rbp)
	movl	%r9d, -40(%rbp)
	movl	-20(%rbp), %edx
	movl	-24(%rbp), %eax
	addl	%eax, %edx      ; 计算a+b -> %edx
	movl	-28(%rbp), %eax
	addl	%eax, %edx
	movl	-32(%rbp), %eax
	addl	%eax, %edx
	movl	-36(%rbp), %eax
	addl	%eax, %edx
	movl	-40(%rbp), %eax
	addl	%eax, %edx      ; %edx = a + b + c + d + e + f
	movl	16(%rbp), %eax  ; 跳过调用者的%rbp和返回地址, 到上一个frame里取g
	addl	%eax, %edx
	movl	24(%rbp), %eax  ; 取h
	addl	%edx, %eax
	movl	%eax, -4(%rbp)  ; 将结果保存到sum
	movl	-4(%rbp), %eax  ; 将sum返回
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	add, .-add
	.globl	main
	.type	main, @function
main:
.LFB1:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$32, %rsp           ; 栈帧分配32B空间
	movl	$10, -4(%rbp)       ; 10 入栈
	movl	$20, -8(%rbp)       ; 20 入栈
	movl	-4(%rbp), %edx      ; 10 -> %edx 
	movl	-8(%rbp), %eax      ; 20 -> %eax
	addl	%edx, %eax          ; %eax += %edx 
	movl	%eax, -12(%rbp)     ; %eax 入栈(k)
	pushq	$88                 ; 第8个参数入栈(h)
	pushq	$77                 ; 第7个参数入栈(g)
	movl	$66, %r9d           ; 小于等于6个参数使用寄存器
	movl	$55, %r8d
	movl	$44, %ecx
	movl	$33, %edx
	movl	$22, %esi
	movl	$11, %edi
	call	add
	addq	$16, %rsp           ; 回收空间
	movl	%eax, -16(%rbp)     ; 将add返回值sum入栈
	movl	-12(%rbp), %eax     ; k -> %eax ,因为x64禁止mov的两个操作数都指向内存, 因此将一个内存值复制到另一个内存位置需要两条指令, 中间通过寄存器中转
	movl	%eax, -20(%rbp)     ; 给m赋值
	movl	$0, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE1:
	.size	main, .-main
	.ident	"GCC: (Debian 6.3.0-18+deb9u1) 6.3.0 20170516"
	.section	.note.GNU-stack,"",@progbits
```

## go stack
参考:
- [golang 汇编](https://lrita.github.io/2017/12/12/golang-asm/)

go 汇编中有4个核心的伪寄存器，这4个寄存器是编译器用来维护上下文、特殊标识等作用的：
- FP(Frame pointer): arguments and locals
- PC(Program counter): jumps and branches
- SB(Static base pointer): global symbols
- SP(Stack pointer): top of stack

所有用户空间的数据都可以通过FP(局部数据、输入参数、返回值)或SB(全局数据, 用来保存函数或全局变量)访问. 通常情况下，不会对SB/FP寄存器进行运算操作，通常情况以会以SB/FP作为基准地址，进行偏移解引用 等操作

golang多值返回:
```go
package main

import "fmt"

func test(i, j int) (int, int) {
	a := i + j
	b := i - j
	return a, b
}

func main() {
	a, b := test(2, 1)
	fmt.Println(a, b)
}
```

> `go tool compile -N -l -S demo.go` 和 `go build -gcflags '-N -l' -S demo.go`生成的是过程中的汇编，最终的机器码的汇编可以通过`go tool objdump -N -l demo.go`生成. `-N`,不优化; `-l`,不自动内联函数; `-m`, 开启逃逸分析日志, 逃逸时汇编代码中会出现`CALL    runtime.newobject`, 这里没用`-m`.

`go tool compile -N -l -S demo.go > demo.s`:
```asm
; go version go1.12.6 linux/amd64 
"".test STEXT nosplit size=90 args=0x20 locals=0x18
	0x0000 00000 (demo.go:5)	TEXT	"".test(SB), NOSPLIT|ABIInternal, $24-32  ; 函数的声明以 TEXT 标识开头，以 `{package}·{function}`为函数名. NOSPLIT告诉编译器不要插入分裂栈检查点. 这里可以不用检查栈的大小, 因为需要的栈很小, 只有24B. `24−32`中的24代表需要的栈大小，0表示不需要栈. `32`代表传入和返回对象的总字节长度
	0x0000 00000 (demo.go:5)	SUBQ	$24, SP 								  ; 栈上分配 24B 的空间
	0x0004 00004 (demo.go:5)	MOVQ	BP, 16(SP) 								  ; 保存caller的BP
	0x0009 00009 (demo.go:5)	LEAQ	16(SP), BP 							      ; 取16(SP)的地址赋值给BP
	0x000e 00014 (demo.go:5)	FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x000e 00014 (demo.go:5)	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x000e 00014 (demo.go:5)	FUNCDATA	$3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
	0x000e 00014 (demo.go:5)	PCDATA	$2, $0
	0x000e 00014 (demo.go:5)	PCDATA	$0, $0
	0x000e 00014 (demo.go:5)	MOVQ	$0, "".~r2+48(SP) ; "".~r2 即 (SP+48) 的别名, 这里就是 初始化a, 返回值顺序(右->左) = 地址顺序(高 - > 低)
	0x0017 00023 (demo.go:5)	MOVQ	$0, "".~r3+56(SP)
	0x0020 00032 (demo.go:6)	MOVQ	"".i+32(SP), AX 						  ; 到上一帧取的i, `.i`是助记符
	0x0025 00037 (demo.go:6)	ADDQ	"".j+40(SP), AX 						  ; 到上一帧取的j + AX -> AX
	0x002a 00042 (demo.go:6)	MOVQ	AX, "".a+8(SP) 							  ; AX -> a
	0x002f 00047 (demo.go:7)	MOVQ	"".i+32(SP), AX
	0x0034 00052 (demo.go:7)	SUBQ	"".j+40(SP), AX 						  ; i - j -> AX
	0x0039 00057 (demo.go:7)	MOVQ	AX, "".b(SP) 							  ; AX -> b
	0x003d 00061 (demo.go:8)	MOVQ	"".a+8(SP), AX 							  ; a -> AX
	0x0042 00066 (demo.go:8)	MOVQ	AX, "".~r2+48(SP) 						  ; a -> (SP+48)
	0x0047 00071 (demo.go:8)	MOVQ	"".b(SP), AX
	0x004b 00075 (demo.go:8)	MOVQ	AX, "".~r3+56(SP) 						  ; b -> (SP+56)
	0x0050 00080 (demo.go:8)	MOVQ	16(SP), BP 							  	  ; 恢复caller BP
	0x0055 00085 (demo.go:8)	ADDQ	$24, SP 							      ; 销毁test使用的stack
	0x0059 00089 (demo.go:8)	RET 							  				  ; popq PC, 继续执行
	0x0000 48 83 ec 18 48 89 6c 24 10 48 8d 6c 24 10 48 c7  H...H.l$.H.l$.H.
	0x0010 44 24 30 00 00 00 00 48 c7 44 24 38 00 00 00 00  D$0....H.D$8....
	0x0020 48 8b 44 24 20 48 03 44 24 28 48 89 44 24 08 48  H.D$ H.D$(H.D$.H
	0x0030 8b 44 24 20 48 2b 44 24 28 48 89 04 24 48 8b 44  .D$ H+D$(H..$H.D
	0x0040 24 08 48 89 44 24 30 48 8b 04 24 48 89 44 24 38  $.H.D$0H..$H.D$8
	0x0050 48 8b 6c 24 10 48 83 c4 18 c3                    H.l$.H....
"".main STEXT size=337 args=0x0 locals=0xa8
	0x0000 00000 (demo.go:11)	TEXT	"".main(SB), ABIInternal, $168-0 ; TEXT 在 plan9 汇编里作为一个指令来定义函数，这里定义函数 main
	0x0000 00000 (demo.go:11)	MOVQ	(TLS), CX 						 ; 将线程本地存储(thread local storage) 传送到 CX 寄存器
	0x0009 00009 (demo.go:11)	LEAQ	-40(SP), AX
	0x000e 00014 (demo.go:11)	CMPQ	AX, 16(CX) 						 ; 检查栈帧的大小是否超过目前分配的大小
	0x0012 00018 (demo.go:11)	JLS	327
	0x0018 00024 (demo.go:11)	SUBQ	$168, SP 						 ; 栈上分配 168 字节的空间
	0x001f 00031 (demo.go:11)	MOVQ	BP, 160(SP) 					 ; 将基址指针存储到栈上,位置是160(SP)
	0x0027 00039 (demo.go:11)	LEAQ	160(SP), BP 					 ; 把 160(SP) 的地址放到 BP 里
	0x002f 00047 (demo.go:11)	FUNCDATA	$0, gclocals·f5be5308b59e045b7c5b33ee8908cfb7(SB) ; FUNCDATA和PCDATA指令用来包含一些垃圾收集器需要的信息, 它们由编译器产生. `$0` 表示是用于局部函数调用的参数，需要进行回收
	0x002f 00047 (demo.go:11)	FUNCDATA	$1, gclocals·f1233af8662e2f52a3fb188ed54a06e7(SB)
	0x002f 00047 (demo.go:11)	FUNCDATA	$3, gclocals·f6aec3988379d2bd21c69c093370a150(SB)
	0x002f 00047 (demo.go:11)	FUNCDATA	$4, "".main.stkobj(SB)
	0x002f 00047 (demo.go:12)	PCDATA	$2, $0
	0x002f 00047 (demo.go:12)	PCDATA	$0, $0
	0x002f 00047 (demo.go:12)	MOVQ	$2, (SP) 				; 将i=2入栈, 位置(SP), 入栈后参数排列顺序与c语言一致, 但golang通过stack传参
	0x0037 00055 (demo.go:12)	MOVQ	$1, 8(SP) 				; 将j=1入栈, 位置(SP)
	0x0040 00064 (demo.go:12)	CALL	"".test(SB) 			; 调用 test 方法 = pushp PC + jump add
	0x0045 00069 (demo.go:12)	MOVQ	16(SP), AX 				; a -> AX
	0x004a 00074 (demo.go:12)	MOVQ	AX, ""..autotmp_2+72(SP)
	0x004f 00079 (demo.go:12)	MOVQ	24(SP), AX 				; b -> AX
	0x0054 00084 (demo.go:12)	MOVQ	AX, ""..autotmp_3+64(SP)
	0x0059 00089 (demo.go:12)	MOVQ	""..autotmp_2+72(SP), AX
	0x005e 00094 (demo.go:12)	MOVQ	AX, "".a+56(SP)
	0x0063 00099 (demo.go:12)	MOVQ	""..autotmp_3+64(SP), AX
	0x0068 00104 (demo.go:12)	MOVQ	AX, "".b+48(SP)
	0x006d 00109 (demo.go:13)	MOVQ	"".a+56(SP), AX
	0x0072 00114 (demo.go:13)	MOVQ	AX, (SP)
	0x0076 00118 (demo.go:13)	CALL	runtime.convT64(SB)
	0x007b 00123 (demo.go:13)	PCDATA	$2, $1
	0x007b 00123 (demo.go:13)	MOVQ	8(SP), AX
	0x0080 00128 (demo.go:13)	PCDATA	$2, $0
	0x0080 00128 (demo.go:13)	PCDATA	$0, $1
	0x0080 00128 (demo.go:13)	MOVQ	AX, ""..autotmp_5+96(SP)
	0x0085 00133 (demo.go:13)	MOVQ	"".b+48(SP), AX
	0x008a 00138 (demo.go:13)	MOVQ	AX, (SP)
	0x008e 00142 (demo.go:13)	CALL	runtime.convT64(SB)
	0x0093 00147 (demo.go:13)	PCDATA	$2, $1
	0x0093 00147 (demo.go:13)	MOVQ	8(SP), AX
	0x0098 00152 (demo.go:13)	PCDATA	$2, $0
	0x0098 00152 (demo.go:13)	PCDATA	$0, $2
	0x0098 00152 (demo.go:13)	MOVQ	AX, ""..autotmp_6+88(SP)
	0x009d 00157 (demo.go:13)	PCDATA	$0, $3
	0x009d 00157 (demo.go:13)	XORPS	X0, X0
	0x00a0 00160 (demo.go:13)	MOVUPS	X0, ""..autotmp_4+128(SP)
	0x00a8 00168 (demo.go:13)	XORPS	X0, X0
	0x00ab 00171 (demo.go:13)	MOVUPS	X0, ""..autotmp_4+144(SP)
	0x00b3 00179 (demo.go:13)	PCDATA	$2, $1
	0x00b3 00179 (demo.go:13)	PCDATA	$0, $2
	0x00b3 00179 (demo.go:13)	LEAQ	""..autotmp_4+128(SP), AX
	0x00bb 00187 (demo.go:13)	PCDATA	$0, $4
	0x00bb 00187 (demo.go:13)	MOVQ	AX, ""..autotmp_8+80(SP)
	0x00c0 00192 (demo.go:13)	TESTB	AL, (AX)
	0x00c2 00194 (demo.go:13)	PCDATA	$2, $2
	0x00c2 00194 (demo.go:13)	PCDATA	$0, $5
	0x00c2 00194 (demo.go:13)	MOVQ	""..autotmp_5+96(SP), CX
	0x00c7 00199 (demo.go:13)	PCDATA	$2, $3
	0x00c7 00199 (demo.go:13)	LEAQ	type.int(SB), DX
	0x00ce 00206 (demo.go:13)	PCDATA	$2, $2
	0x00ce 00206 (demo.go:13)	MOVQ	DX, ""..autotmp_4+128(SP)
	0x00d6 00214 (demo.go:13)	PCDATA	$2, $1
	0x00d6 00214 (demo.go:13)	MOVQ	CX, ""..autotmp_4+136(SP)
	0x00de 00222 (demo.go:13)	PCDATA	$2, $0
	0x00de 00222 (demo.go:13)	TESTB	AL, (AX)
	0x00e0 00224 (demo.go:13)	PCDATA	$2, $1
	0x00e0 00224 (demo.go:13)	PCDATA	$0, $6
	0x00e0 00224 (demo.go:13)	MOVQ	""..autotmp_6+88(SP), AX
	0x00e5 00229 (demo.go:13)	PCDATA	$2, $2
	0x00e5 00229 (demo.go:13)	LEAQ	type.int(SB), CX
	0x00ec 00236 (demo.go:13)	PCDATA	$2, $1
	0x00ec 00236 (demo.go:13)	MOVQ	CX, ""..autotmp_4+144(SP)
	0x00f4 00244 (demo.go:13)	PCDATA	$2, $0
	0x00f4 00244 (demo.go:13)	MOVQ	AX, ""..autotmp_4+152(SP)
	0x00fc 00252 (demo.go:13)	PCDATA	$2, $1
	0x00fc 00252 (demo.go:13)	PCDATA	$0, $0
	0x00fc 00252 (demo.go:13)	MOVQ	""..autotmp_8+80(SP), AX
	0x0101 00257 (demo.go:13)	TESTB	AL, (AX)
	0x0103 00259 (demo.go:13)	JMP	261
	0x0105 00261 (demo.go:13)	MOVQ	AX, ""..autotmp_7+104(SP)
	0x010a 00266 (demo.go:13)	MOVQ	$2, ""..autotmp_7+112(SP)
	0x0113 00275 (demo.go:13)	MOVQ	$2, ""..autotmp_7+120(SP)
	0x011c 00284 (demo.go:13)	PCDATA	$2, $0
	0x011c 00284 (demo.go:13)	MOVQ	AX, (SP)
	0x0120 00288 (demo.go:13)	MOVQ	$2, 8(SP)
	0x0129 00297 (demo.go:13)	MOVQ	$2, 16(SP)
	0x0132 00306 (demo.go:13)	CALL	fmt.Println(SB)
	0x0137 00311 (demo.go:14)	MOVQ	160(SP), BP
	0x013f 00319 (demo.go:14)	ADDQ	$168, SP
	0x0146 00326 (demo.go:14)	RET
	0x0147 00327 (demo.go:14)	NOP
	0x0147 00327 (demo.go:11)	PCDATA	$0, $-1
	0x0147 00327 (demo.go:11)	PCDATA	$2, $-1
	0x0147 00327 (demo.go:11)	CALL	runtime.morestack_noctxt(SB) ; 扩大栈帧空间
	0x014c 00332 (demo.go:11)	JMP	0
```

> `go tool compile`省略`-N -l`参数时`CALL	"".test(SB)`会被优化成其他代码.

结论: 被调函数读写的传入&返回参数均来自caller的栈帧.

// TODO [闭包](https://cloud.tencent.com/developer/article/1072910), [defer](https://zhuanlan.zhihu.com/p/69455275)