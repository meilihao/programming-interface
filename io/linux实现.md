# io
## 用设备控制器屏蔽设备差异
计算机系统里, CPU 并不直接和设备打交道，而是通过设备控制器（Device Control Unit）的组件中转.

输入输出设备大致可以分为两类:
1. 块设备（Block Device） : 块设备将信息存储在固定大小的块中，每个块都有自己的地址. 硬盘就是常见的块设备.

    由于块设备传输的数据量比较大，控制器里往往会有缓冲区.

1. 字符设备（Character Device）: 字符设备发送或接收的是字节流, 而不用考虑任何块结构，没有办法寻址. 鼠标就是常见的字符设备.

CPU 同控制器的寄存器和数据缓冲区通信的方式: 
1. 每个控制寄存器被分配一个 I/O 端口，之后可以通过特殊的汇编指令（例如 in/out 类似的指令）操作这些寄存器
1. 数据缓冲区，可内存映射 I/O，可以分配一段内存空间给它，就像读写内存一样读写数据缓冲区. 如果去看内存空间的话，有一个区域 ioremap，就是做这个的.

对于 CPU 来讲，这些外部设备都有自己的大脑，可以自行处理一些事情，但是有个问题是，当cpu给设备发了一个指令，让它读取一些数据，它读完的时候，怎么通知cpu呢？控制器的寄存器一般会有状态标志位，可以通过检测状态标志位，来确定输入或者输出操作是否完成. 第一种方式就是轮询等待，就是一直查，一直查，直到完成. 当然这种方式很不好，于是有了第二种方式，就是可以通过中断的方式，通知操作系统输入输出操作已经完成.

为了响应中断，一般会有一个硬件的中断控制器，当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU，一个中断产生了，CPU 需要停下当前手里的事情来处理中断. 中断有两种，一种软中断，例如代码调用 INT 指令触发，一种是硬件中断，就是硬件通过中断控制器触发的.

有的设备需要读取或者写入大量数据. 如果所有过程都让 CPU 协调的话，就需要占用 CPU 大量的时间，比方说，磁盘就是这样的. 这种类型的设备需要支持 DMA 功能，也就是说，允许设备在 CPU 不参与的情况下，能够自行完成对内存的读写. 实现 DMA 机制需要有个 DMA 控制器帮 CPU 来做协调，就像下面这个图中显示的一样.

CPU 只需要对 DMA 控制器下指令，说它想读取多少数据，放在内存的某个地方就可以了，接下来 DMA 控制器会发指令给磁盘控制器，读取磁盘上的数据到指定的内存位置，传输完毕之后，DMA 控制器发中断通知 CPU 指令完成，CPU 就可以直接用内存里面现成的数据了. 内存的 DMA 区域，就是这个作用.

![](/misc/img/io/1ef05750bc9ff87a3330104802965335.jpeg)

## 用驱动程序屏蔽设备控制器差异
os用设备驱动程序来对接各个设备控制器.

设备控制器不属于操作系统的一部分，但是设备驱动程序属于操作系统的一部分. 操作系统的内核代码可以像调用本地代码一样调用驱动程序的代码，而驱动程序的代码需要发出特殊的面向设备控制器的指令，才能操作设备控制器. 设备驱动程序中是一些面向特殊设备控制器的代码, 不同的设备不同. 但是对于操作系统其它部分的代码而言，设备驱动程序应该有统一的接口.

设备做完了事情会通过中断来通知操作系统，而os有一个统一的流程来处理中断，使得不同设备的中断使用统一的流程. 一般的流程是，一个设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数. 而中断的时候，触发的函数是 [handle_irq](https://elixir.bootlin.com/linux/v5.8-rc3/source/arch/x86/kernel/irq.c#L226), 这个函数是中断处理的统一入口. 在这个函数里面，可以找到设备驱动程序注册的中断处理函数 Handler，然后执行它进行中断处理.

![](/misc/img/io/aa9d074d9819f0eb513e11014a5772c0.jpg)

> 设备的中断处理函数在驱动中.

> do_IRQ deleted on 7c1d7cdcef1b54f4a78892b6b99d19f12c4f398e for "x86: unify do_IRQ() "

另外，对于块设备来讲，在驱动程序之上，文件系统之下，还需要一层通用设备层, 它里面的逻辑和磁盘设备没有什么关系，可以说是通用的逻辑. 在写文件的最底层，可看到了 BIO 字眼的函数，但是好像和设备驱动也没有什么关系. 是的，因为块设备类型非常多，而 Linux 操作系统里面一切是文件, 要不想文件系统以下，就直接对接各种各样的块设备驱动程序，这样会使得文件系统的复杂度非常高
, 通过在中间加了一层通用块层，将与块设备相关的通用逻辑放在这一层，维护与设备无关的块的大小，然后通用块层下面对接各种各样的驱动程序.

## 用文件系统接口屏蔽驱动程序的差异
上面从硬件设备到设备控制器，到驱动程序，到通用块层，到文件系统，层层屏蔽不同的设备的差别，最终到涉及对用户使用接口，也要统一. 虽然操作设备，都是基于文件系统的接口，也要有一个统一的标准.

首先要统一的是设备名称. 所有设备都在 /dev/ 文件夹下面创建一个特殊的设备文件. 这个设备特殊文件也有 inode，但是它不关联到硬盘或任何其他存储介质上的数据，而是建立了与某个设备驱动程序的连接. /dev/sdb 是一个设备文件, 这个文件本身和硬盘上的文件系统没有任何关系. 这个设备本身也不对应硬盘上的任何一个文件，/dev/sdb 其实是在一个特殊的文件系统 devtmpfs 中. 但是将 /dev/sdb 格式化成一个文件系统 ext4 的时候，就会将它 mount 到一个路径下面, 例如在 /mnt/sdb 下面. 这个时候 /dev/sdb 还是一个设备文件在特殊文件系统 devtmpfs 中，而 /mnt/sdb 下面的文件才是在 ext4 文件系统中，只不过这个文件系统是在 /dev/sdb 设备上的.

`ls -al /dev`, 如果是字符设备文件，则以 c 开头，如果是块设备文件，则以 b 开头. 其次是里面的两个号，一个是主设备号，一个是次设备号. 主设备号定位设备驱动程序，次设备号作为参数传给启动程序，选择相应的单元.

从ls列表可以看出来，mem、null、random、urandom、zero 都是用同样的主设备号 1，也就是它们使用同样的字符设备驱动，而 vda、vda1、vdb、vdc 也是同样的主设备号，也就是它们使用同样的块设备驱动. 有了设备文件，就可以使用对于文件的操作命令和 API 来操作设备了. 例如，`cat /dev/urandom | od -x`.

在 Linux 上面，如果一个新的设备从来没有加载过驱动，也需要安装驱动. Linux 的驱动程序已经被写成和操作系统有标准接口的代码，可以看成一个标准的内核模块. 在 Linux 里面，安装驱动程序，其实就是加载一个内核模块. 可以用命令 lsmod，查看有没有加载过相应的内核模块.

如果没有安装过相应的驱动，可以通过 insmod/modprobe 安装内核模块. 内核模块的后缀一般是 ko.

一旦有了驱动，就可以通过命令 `mknod filename type major minor`在 /dev 文件夹下面创建设备文件，其中 filename 就是 /dev 下面的设备名称，type 就是 c 为字符设备，b 为块设备，major 就是主设备号，minor 就是次设备号. 一旦执行了这个命令，新创建的设备文件就和上面加载过的驱动关联起来，这个时候就可以通过操作设备文件来操作驱动程序，从而操作设备.

自动识别设备需要另一个管理设备的文件系统，也就是 /sys 路径下面的 sysfs 文件系统, 它把实际连接到系统上的设备和总线组成了一个分层的文件系统. 这个文件系统是当前系统上实际的设备数的真实反映.

在 /sys 路径下有下列的文件夹：
- /sys/devices 是内核对系统中所有设备的分层次的表示
- /sys/dev 目录下一个 char 文件夹，一个 block 文件夹，分别维护一个按字符设备和块设备的主次号码 (major:minor) 链接到真实的设备 (/sys/devices 下) 的符号链接文件
- /sys/block 是系统中当前所有的块设备
- /sys/module 有系统中所有模块的信息

有了 sysfs 以后，还需要一个守护进程 udev. 当一个设备新插入系统的时候，内核会检测到这个设备，并会创建一个内核对象 kobject, 这个对象通过 sysfs 文件系统展现到用户层，同时内核还向用户空间发送一个热插拔消息. udevd 会监听这些消息，在 /dev 中创建对应的文件.

![](/misc/img/io/6234738aac8d5897449e1a541d557090.jpg)

有了文件系统接口之后，不但可以通过文件系统的命令行操作设备，也可以通过程序，调用 read、write 函数，像读写文件一样操作设备. 但是有些任务只使用读写很难完成，例如检查特定于设备的功能和属性，超出了通用文件系统的限制. 所以，对于设备来讲，还有一种接口称为 ioctl，表示输入输出控制接口，是用于配置和修改特定设备属性的通用接口.