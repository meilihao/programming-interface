# filesystem
类Unix文件系统是目录和文件的一种层次结构, 像一颗倒置的树, 起点是`/`(root目录).

[linux有FHS(Filesystem Hierarchy Standard,文件系统层次结构)标准](http://refspecs.linuxfoundation.org/fhs.shtml):
![](/misc/img/fs/052049040017593.png)

**目录(directory)**是一种逻辑上包含若干文件的文件. 每个文件都会包含一个文件名(filename)和若干文件属性(文件类型, 大小, 所有者, 权限, 最后访问时间/修改时间等).

创建新目录时会自动创建两个文件名： `.`和`..`, 分别表示当前目
录和父目录; 仅在最高层次的根目录中， 两者指向相同, 都表示当前目录.

**路径名(pathname)**是由`/`分隔的若干文件名序列. 以`/`开头的路径名称为绝对路径(absolute pathname); 否则称为相对路径(relative pathname), 它是指向相对于某个文件的文件. **根目录是特殊的绝对路径, 它不包含文件名**.

## 文件类型
定义在[`#include <sys/stat.h>`](https://en.wikibooks.org/wiki/C_Programming/POSIX_Reference/sys/stat.h)里, 可通过`os.FileMode`进行位操作来判断.

- 普通文件(regular file)
- 目录文件(directory file)
- 块特殊文件(block special file)
- 字符特殊文件(character special file)
- FIFO : 管道, 用于进程间通信. 与socket类似, 以由socket取代. 
- 套接字(socket) : 用于进程间的网络通信
- 符号链接(symbolic link) : 指向另一个文件

可通过`ls -ld xxx`查看.

### 目录
在文件系统中,目录的存储方式类似于普通文件. 目录与普通文件的区别有二:
- 在其 i-node 条目中,会将目录标记为一种不同的文件类型
- 目录是经特殊组织而成的文件. 本质上说就是一个表格,包含文件名和 i-node 编号.

### 文件描述符和打开文件之间的关系
文件由内核的 3 个数据结构维护:
1. 进程级的文件描述符表

	针对每个进程,内核为其维护打开文件的描述符(open file descriptor)表, 该表的每一条目都记录了单个文件描述符的相关信息:
	- 控制文件描述符操作的一组标志(目前,此类标志仅定义了一个,即 close-on-exec 标志)
	- 对打开文件句柄的引用
1. 系统级的打开文件表

	内核对所有打开的文件维护有一个系统级的描述表格(open file description table), 有时也称之为打开文件表(open file table),并将表中各条目称为打开文件句柄(open file handle) . 一个打开文件句柄存储了与一个打开文件相关的全部信息:
	- 当前文件偏移量(调用 read()和 write()时更新,或使用 lseek()直接修改)
	- 打开文件时所使用的状态标志(即,open()的 flags 参数)
	- 文件访问模式(如调用 open()时所设置的只读模式、只写模式或读写模式)
	- 与信号驱动 I/O 相关的设置
	- 对该文件 i-node 对象的引用
1. 文件系统的 i-node 表

	每个文件系统都会为驻留其上的所有文件建立一个 i-node 表:
	- 文件类型(例如,常规文件、套接字或 FIFO)和访问权限
	- 一个指针,指向该文件所持有的锁的列表
	- 文件的各种属性,包括文件大小以及与不同类型操作相关的时间戳

同一进程的两个文件描述符指向同一个打开的文件句柄: 通过调用 dup()、dup2()或 fcntl()而形成的.
不同进程的两个文件描述符指向同一个打开的文件句柄: fork() 或 通过UNIX 域套接字将一个打开的文件描述符传递给另一进程.
不同/同一进程的不同打开文件句柄指向 i-node 表中的相同条目: 对同一文件发起了 多次 open()调用.

指向同一打开文件句柄,将共享同一文件偏移量. 因此,如果通过其中一个文件描述符来修改文件偏移量(由调用 read()、write()或 lseek()
所致),那么从另一文件描述符中也会观察到这一变化; 且打开的文件标志也共享(例如,O_APPEND、O_NONBLOCK 和 O_ASYNC, 可通过 fcntl()的 F_GETFL 和 F_SETFL 操作).

但文件描述符标志(亦即,close-on-exec 标志)为进程和文件描述符所私有, 对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符.

> i-node 在磁盘和内存中的差异: 内存i-node = 磁盘i-node + 记录了引用该 i-node 的打开文件句柄数量以及该 i-node 所在设备的主、从设
备号,还包括一些打开文件时与文件相关的临时属性,例如:文件锁. 

## [设备文件](/arch/device.md)

## inode
Linux 在生成文件的时候，内容会为每一个文件生成一个唯一的索引节点（Inode），文件的属性都会保存在这个Inode中.

## 链接
链接是一种为了共享文件和快速访问而建立起来的文件映射关系, 有**软链接(推荐)**和硬链接之分:
- 硬链接(类似于指针) : 指向目标文件的inode, 因此没有创建新文件.
	1. 只能对已存在的文件进行创建
	1. 硬链接和目标文件必须是同一文件系统(不同的文件系统有不同的inode table, i-node 编号的唯一性仅在一个文件系统之内才能得到保障)
	1. 为同一个文件创建多个硬链接即多个别名（他们有共同的 inode）
	1. 只有root才能创建执行目录的硬链接(且需要文件系统支持), 这样做是为了避免遍历目录时出现循环.
- 软链接又叫符号链接(symbol links), 类似于Windows下面的快捷键
	1. 可对不存在的文件创建软链接; 允许跨文件系统
	1. 软链接是一个新文件(包含了它所链接的另一个文件的路径)
	1. 符号链接的大小是其链接文件的路径名的字节数

> `ln`命令创建硬链接会增加链接数，`rm`命令会减少链接数.一个文件除非链接数为0，否则不会从文件系统中被物理地删除.
> 可使用`readlink`命令读取链接
> 这两种链接的本质区别关键点在于inode
> 针对目录的软链接删除: `rm -rf symbol_name(删除软链接symbol_name)` 和 `rm -rf symbol_name/(仅删除symbol_name目录下的所有文件, 其他不变)`
> 系统调用对符号链接的解释可见[Linux/UNIX系统编程手册#表 18-1 各个函数对符号链接的解释]().

大部分操作会无视符号链接的所有权和权限(创建符号链接时会为其赋予所有权限). 
是否允许操作反而是由符号链接所指代文件的所有权和权限来决定. 仅当在带有粘性权限
位的目录中对符号链接进行移除或改名操作时,才会考虑符号链接自身的所有权.

![](/misc/img/fs/7b670449a3faa6a2cdab45c2298b66dd.png)

## example
1. 列出一个目录中所有的文件
```go
package main

import (
	"io/ioutil"
	"log"
	"os"
)

func main() {
	args := os.Args
	if len(args) != 2 {
		log.Println("usage: ls directory_name")
		os.Exit(1)
	}

	// 获取所有文件
	files, err := ioutil.ReadDir(args[1])
	CheckErr(err)

	for _, file := range files {
		if file.IsDir() {
			log.Printf("%s is dir\n", file.Name())
		} else {
			log.Printf("%s is file\n", file.Name())
		}
	}
}

func CheckErr(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
```

## 有关系统统调用
对于文件的操作,下面这六个系统调用是最重要的:
1. 对于已经有的文件,可以使用open打开这个文件,close关闭这个文件;
1. 对于没有的文件,可以使用creat创建文件;
1. 打开文件以后,可以使用lseek跳到文件的某个位置;
1. 对文件的内容进行读写,读的系统调用是read,写是write

进程会为每个文件分配一个文件描述符(File Descriptor, 一个整数), 有了它我们就可以使用系统调用操作文件了

> Linux 里一切皆文件

## mount
将文件系统挂载到文件树上, 挂载的目录会映射为新加入的文件系统的根,而原目录内容就被隐藏,该目录也叫挂载点(mount point).

需永久挂载时可将信息保持到`/etcd/fstab`

umount用于卸载文件系统, 但不能卸载正处于"busy"状态的文件系统, 此时可以使用`fuser -c /xxx`查找哪个进程在使用文件.

> 通过 Linux 专有的虚拟文件/proc/mounts,可查看当前已挂载文件系统的列表, 包含了已挂载文件系统的精确信息.
> 随着引入mount namespace, 每个进程都拥有一个/proc/PID/mounts 文件, 其中会列出组成进程挂载空间的挂载点,而/proc/mounts只是指向/proc/self/mounts的符号链接.

/etc/fstab 的格式:
1. 已挂载设备名
2. 设备的挂载点
3. 文件系统类型
4. 挂载标志. 比如`rw`表示以可读写方式挂载文件系统
5. 一个数字,dump(8)会使用其来控制对文件系统的备份操作. 只有/etc/fstab 文件才会用到该字段和第 6 个字段,在/proc/mounts 和/etc/mtab 中,该字段总是为 0.
6. 一个数字,在系统引导时,用于控制 fsck(8)对文件系统的检查顺序.

## lost+found
fsck(文件系统一致性检查工具)找到一个无法确定其父目录的文件时就会将其放入其中.

## tmpfs
驻留于内存中的虚拟文件系统. 其可使用swap.

创建命令: `mount -t tmpfs ${source} ${target}`, 无需预先mkfs. source是要创建的tmpfs的名称.

tmpfs 文件系统还有以下两个特殊用途:
- 由内核内部挂载的隐形 tmpfs 文件系统,用于实现 System V 共享内存和共享匿名内存映射.
- 挂载于/dev/shm 的 tmpfs 文件系统, 被 glibc 用以实现 POSIX 共享内存和 POSIX 信号量.

## vfs
虚拟文件系统(Virtual Files System, VFS) 是驻留在用户进程和各种类型的linux 文件系统之间的一个抽象接口层.
vfs提供了访问文件系统对象的通用对象模型(比如索引节点, 文件对象, 分页缓存, 目录条目等等)和方法, 对用户进程隐藏了实现每个文件系统的差异.

脏页(dirty page): 磁盘上的数据与内存中的数据不一致, 此时内存中的数据就是脏页, 需要尽快同步到磁盘中, 以防止意外丢失.

[块层](https://zhuanlan.zhihu.com/p/25096747)处理所有与块设备操作相关的活动, 其关键数据结构是bio(block input output)结构. 它处理bio请求, 并放入`i/o`请求队列.
bio结构是在文件系统层和块层之间的一个接口.

## 特殊文件系统

### /sys
`/sys`是一种在内存中的虚拟文件系统sysfs的mount point, 提供了有关系统上可用设备, 设备的配置及其状态的信息. sysfs的指定原则之一是`/sys`里的每个文件都只表示下层设备的一个属性.

可通过`udevadm`查询设备信息, 触发事件, 控制vdevd守护进程, 以及监视udev和内核的事件, 比如查看ssd信息`udevadm info -a -n nvme0n1`.

`/sys`目录:
- block : 有关硬盘之类的块设备信息
- bus : 总线: pci-e, scsi, usb等
- class : 按设备的功能类型(比如声卡, 显卡, 输入设备, 网卡)组织的一颗树
- dev : 区分块设备和字符设备的设备信息
- devices : 正确表示所有找到的设备
- firmware : 特定于平台的子系统的接口, 如ACPI
- fs : 内核知道的一些但不是全部文件系统的目录
- hypervisor
- kernel : 内核的内部信息, 比如高速缓存和虚拟内存状态
- module : 内核动态加载的模块
- power : 系统电源状态的几种详细信息

## /proc
`/proc`文件系统是一种虚拟文件系统,以文件系统目录和文件形式,提供一个指向内核数据结构的接口, 内核产生的所有状态信息和统计信息均在里面.

> 大多数linux工具都依赖`/proc`提供的信息进行性能监控. 比如ps和top均从`/proc`读取进程状态信息, 再比如vmstat, cpuinfo等.

`/proc`: 各种系统信息
- acpi : 大多数现代桌面和笔记本支持的高级配置和电源接口. acpi主要是pc技术, 服务器上通常被禁用.
- bus : 包含总线子系统的信息, 比如pci总线或各自系统的usb接口
- irq : 系统中的中断信息. 每个子目录是一个中断, 并可能是一个连接的设备, 比如一个网卡接口. 这里可修改一个特定中断的cpu亲和力.
- net : 网络接口的大量原始统计, 比如接收的组播数据包或每个接口的路由.
- scsi : scsi子系统信息, 比如连接的设备或驱动程序版本.
- sys : 可调整的内核参数, 比如虚拟内存管理器或网络协议栈的行为.

	- abi : 文件与应用程序的二进制信息
	- dev : 特定设备的信息
	- fs : 特定的文件系统
	- kernel : 可控制一系列的内核参数
	- net : 网络和套接字的设置
	- vm : 内存管理设置, 包括buffer和cache管理
- tty : 各个虚拟终端和与它连接的物理设备信息.
- sysvipc : 有关 System V IPC 对象的信息
- partitions : 记录了系统中每个磁盘分区的主辅设备编号、大小和名称
- swaps : 查看系统中当前已激活交换区域的信息. 其中包括每个交换区域的大小,以及在用交换区域的个数
- filesystems : 查看当前为内核所知的文件系统类型
- mounts : 当前已挂载文件系统的列表
- `/proc/${pid}` : 进程信息

	- cmdline : 进程的完整命令行(以null即`\0`分隔)
	- cwd : 链接到进程当前工作目录的符号链接
	- environ : 进程的环境变量(以null分隔)
	- exe : 链接到进程可执行文件的符号链接, 指向可执行程序的绝对路径
	- fd : 包含链接到进程每个打开文件的符号链接. 链接到的管道和socket没有关联的文件名, 但有具体id
	- fdinfo : 进程中文件描述符的相关信息
		- pos 字段 : 当前的文件偏移量
		- flags : 为一个八进制数,表征文件访问标志和已打开文件的状态标志
	- maps : 内存映射信息(共享段, lib等)
	- men : 进程虚拟内存(在 I/O 操作之前必须调用 lseek()移至有效偏移量)
	- mounts : 进程的安装点
	- status : 各种信息(比如,进程 ID、凭证、内存使用量、信号)
	- stack : 主线程的内核堆栈的信息(线程内核模式堆栈位于`/proc/[PID]/task/[TID]/stack`下)
	- wchan : 表示导致进程睡眠或者等待的函数,可结合进程状态来查看
	- root : 链接到进程的根目录(由chroot设置)的符号链接
	- state : 进程的总状态信息(ps可解析该信息)
	- statm : 内存使用情况的信息
	- task : 为进程中的每个线程均包含一个子目录(始自 Linux 2.6)

> 针对进程中的每个线程,内核提供了以/proc/PID/task/TID 命名的子目录,其中 TID 是该线程的线程 ID. TID 子目录中都有一套类似于/proc/PID 目录内容的文件和目录.

## /dev/fd
对于每个进程,内核都提供有一个特殊的虚拟目录/dev/fd. 该目录中包含`/dev/fd/${n}`形式的文件名,其中 n 是与进程中的打开文件描述符相对应的编号.

打开/dev/fd 目录中的一个文件等同于复制相应的文件描述符.

> /dev/fd 实际上是一个符号链接,链接到 Linux 所专有的/proc/self/fd 目录.
> `ls | diff /dev/fd/0 oldlist`取代`ls | diff - oldlist`, 以避免部分命令未实现`-`(表示stdin/stdout)或部分命令使用`-`作为命令行选项结束的分隔符.

## ext4
文件系统由以下几部分组成:
- 引导块 : 总是作为文件系统的首块. 引导块不为文件系统所用,只是包含用来引导操作系统的信息. 操作系统虽然只需一个引导块,但所有文件系统都设有引导块(其中的绝大多数都未使用).
- 超级块:紧随引导块之后的一个独立块,包含与文件系统有关的参数信息,其中包括:
	- i 节点表容量
	- 文件系统中逻辑块的大小
	- 以逻辑块计,文件系统的大小
- i 节点表 : 文件系统中的每个文件或目录在 i 节点表中都对应着唯一一条记录. 这条记录登记了关乎文件的各种信息. 有时也将 i 节点表称为 i-list.
- 数据块 : 文件系统的大部分空间都用于存放数据,以构成驻留于文件系统之上的文件和目录

驻留于同一物理设备上的不同文件系统,其类型、大小以及参数设置(比如,块大小)都可以有所不同. 这也是将一块磁盘划分为多个分区的原因之一.

针对驻留于文件系统上的每个文件,文件系统的 i 节点表会包含一个 i 节点(索引节点的简称). 对 i 节点的标识,采用的是 i节点表中的顺续位置,以数字表示. 文件的 i 节点号(或简称为 i 号)是`ls -li`命令所显示的第一列. i 节点所维护的信息如下所示:
- 文件类型(比如,常规文件、目录、符号链接,以及字符设备等)
- 文件属主(亦称用户 ID 或 UID)
- 文件属组(亦称为组 ID 或 GID)
- 3类用户的访问权限:属主(有时也称为用户)、属组以及其他用户(属主和属组用户之外的用户)
- 3 个时间戳:对文件的最后访问时间(`ls -lu`所显示的时间)、对文件的最后修改时间(`ls -l`所显示的时间),以及文件状态的最后改变时间(`ls -lc`所显示的最后改变 i 节点信息的时间). 值得注意的是,与其他 UNIX 实现一样,大多数 Linux 文件系统不会记录文件的创建时间. 各种函数对文件时间戳的影响可见[Linux/UNIX系统编程手册#表 15-2 各种函数对文件时间戳的影响]().
- 指向文件的硬链接数量
- 文件的大小,以字节为单位
- 实际分配给文件的块数量,以 512 字节块为单位. 这一数字可能不会简单等同于文件的字节大小,因为考虑文件中包含空洞的情形,分配给文件的块数可能会低于根据文件正常大小(以字节为单位)所计算出的块数.
- 指向文件数据块的指针

## inotify
允许应用程序监控文件事件.

使用 inotify API 有以下几个关键步骤:
1. 使用 inotify_init()来创建一 inotify 实例
1. 使用 inotify_add_watch()向 inotify 实例的监控列表添加条目

	参数 mask 为一位掩码,针对 pathname 定义了意欲监控的事件
1. 为获得事件通知, 需针对 inotify 文件描述符执行 read()操作

	每次对 read()的成功调用,都会返回一个或多个 inotify_event 结构,其中各自记录了处于 inotify 实例监控之下的某一路径名所发生的事件.

	inotify 事件可见[Linux/UNIX系统编程手册#表 19-1 inotify 事件]().
1. 在结束监控时会关闭 inotify 文件描述符. 这会自动清除与 inotify 实例相关的所有监控项.

inotify 机制可用于监控文件或目录. 当监控目录时,与路径自身及其所含文件相关的事件都会通知给应用程序.

inotify 监控机制为**非递归**. 若应用程序有意监控整个目录子树内的事件,则需对该树中的每个目录发起 inotify_add_watch()调用.

可使用 epoll 以及由信号驱动的 I/O(自 Linux 2.6.25 起)来监控 inotify文件描述符.

`/proc/sys/fs/inotify/*`提供了对notify 机制的操作施以各种限制:
- max_queued_events

	inotify 实例队列中的事件数量设置上限. 一旦超出这一上限,系统将生成 IN_Q_OVERFLOW 事件,并丢弃多余的事件. 溢出事件的 wd 字段值
为−1.
- max_user_instances

	对由每个真实用户 ID 创建的 inotify 实例数的限制值
- max_user_watches

	对由每个真实用户 ID 创建的监控项数量的限制值