# 权限

## 用户id
唯一标识一个用户的整数,信息存储在[`/etc/passwd`](files/passwd.md)里.`0`属于`root`.

## 组id
唯一标识若干用户的整数,信息存储在`/etc/group`里.`0`属于`root`组.

允许多个用户在一个组里, 便于同组成员共享资源.

用户最多可在NGROUPS_MAX个组里(`sysconf(_SC_NGROUPS_MAX)`或`/proc/sys/kernel/ngroups_max`).

## SUID
SUID权限**仅对二进制可执行文件有效**,让用户在执行时具有文件所有者的权限,且该权限仅在执行该文件的过程中有效.

```
chmod u+s xxx
```

举例: passwd命令

## SGID

### SGID对目录

- 用户在此目录下的有效用户组将会变成该目录的用户组, 此时如果用户在该目录下具有 w 的权限,则其所创建的新文件的用户组与此目录的用户组相同.

用途: 文件共享

### SGID对文件

- SGID 对二进制可执行文件有效
- 用户对该文件具备 x 的权限
- 在执行的过程中将会获得该文件群组的支持

举例: locate命令

## 
saved set-user-ID 和 saved set-group-ID 允许 set-user-ID(SUID) 和
set-group-ID(SGID) 程序临时性地放弃特权,并在之后恢复特权.

## sticky bit

是在other用户的权限上设置,可以理解为防删除位,**仅对目录有效**.
如果具有可执行权限，设置sticky bit后是t；如果没有可执行权限的话，设置sticky bit后是T.

```
chmod o+t xxx
```

- 对一个目录设置了sticky-bit之后,比如`rwxrwxrwt`，当用户在该目录下建立文件或目录时, 这些文件仅准许其属主(或root)执行删除、 移动等操作.

举例: /tmp目录

## 实际用户UID和有效用户EUID(Effective UID)
实际用户指用户登录时所使用的用户.
有效用户指当前执行操作的用户,能利用su或sudo进行切换.

## 文件访问
新建/删除一个文件就必须对包含该文件的目录具有写权限和执行权限.

新文件的用户id是进程的有效用户id, 其组id是进程的有效组id/它所在目录的组id.

## example
1. 获取进程的uid和gid
```go
package main

import (
	"log"
	"os"
)

func main() {
	log.Printf("uid = %d, gid = %d\n", os.Getuid(), os.Getgid())
}
```

## rwx
检查文件权限时,内核所遵循的规则如下:
1. 对于特权级进程,授予其所有访问权限
2. 若进程的有效用户 ID 与文件的用户 ID(属主)相同,内核会根据文件的属主权限,授予
进程相应的访问权限.
3. 若进程的有效组 ID 或任一附属组 ID 与文件的组 ID(属组)相匹配,内核会根据文件的
属组权限,授予进程对文件的相应访问权限.
4. 若以上三点皆不满足,内核会根据文件的 other(其他)权限,授予进程相应权限.

### 对文件
r: 读取文件内容
w: 新增/修改文件内容. 删除文件(修改文件名等)的权限受父目录的权限控制, 和文件本身的权限无关, 因为文件名在父目录的block里.
x: 可执行. 普通用户还必须同时有r权限才能执行, root没有r权限但有x权限(ugo上的都可以)也能执行.

### 对目录
r: 浏览目录内文件(包括子目录)的权限. 没有x不能进入目录即无法`cd dir`,`ls -l`仅可看到目录名下的文件名, 属性会用问号表示
w: 增加, 删除, 修改目录内文件名的权限, 需要x配合. 要删除文件,对文件本身无需有任何权限仅关心目录权限.
x: 进入目录的权限. 没有r则无法获取文件列表; 没有w则无法新建文件

### 权限检查算法(from `Linux/Unix系统编程手册`)
1. 对于特权级进程,授予其所有访问权限
2. 若进程的有效用户 ID 与文件的用户 ID(属主)相同,内核会根据文件的属主权限,授予
进程相应的访问权限. 比方说,若文件权限掩码中的属主读权限(owner-read permission)
位被置位,则授予进程读权限, 否则,则拒绝进程对文件的读取操作
3. 若进程的有效组 ID 或任一附属组 ID 与文件的组 ID(属组)相匹配,内核会根据文件的
属组权限,授予进程对文件的相应访问权限
4. 若以上三点皆不满足,内核会根据文件的 other(其他)权限,授予进程相应权限

## 扩展属性(EA)
以名称-值对形式将任意元数据与文件 i 节点关联起来的技术.

## ACL(access control list, 访问控制列表)
`rwx+ugo`能满足大部分需求, 但不够细致, 因此有了ACL. NFSv4 ACL是事实标准, 兼容POSIX ACL, 兼容大部分windows权限位.

exte4的POSIX ACL默认是禁用, 可使用`mount -o acl`打开.

### ACL 权限检查算法
1. 若进程具有特权,则拥有所有访问权限. 与传统文件权限模型相类似,这里也有一个例外. 执行某文件时,仅当将可执行权限通过至少一条 ACL 记录授予该文件
时,系统才会向特权级进程授予该权限.
2. 若某一进程的有效用户 ID 匹配文件的属主(用户 ID),则授予该进程标记类型为
ACL_USER_OBJ 的 ACE 所指定的权限.
4. 若进程的组 ID(亦即,有效组 ID 或任一辅助组 ID)之一匹配于文件组(对应于标记类
型为 ACL_GROUP_OBJ 的 ACE),或者任一 ACL_GROUP 型记录的标记限定符,则会依
次进行如下检查,直至发现匹配项.
	1. 若进程的组 ID 之一匹配于文件组,且标记类型为 ACL_GROUP_OBJ 的 ACE 授予了
所请求的权限,则会依据此记录来判定对文件的访问权限. 如果 ACL 中还包含了标记
类型为 ACL_MASK 的 ACE,那么对该文件的访问权限将是两记录权限相与(&)后
的结果.
	2. 若进程的组 ID 之一匹配于该文件所辖 ACL_GROUP 型 ACE 的标记限定符,且该 ACE
授予了所请求的权限,那么会依据此记录来判定对文件的访问权限。如果 ACL 中包含
了 ACL_MASK 型 ACE,那么对该文件的访问权限应为两记录权限相与(&)的结果.
	3. 否则,拒绝对该文件的访问.
5. 否则,将以 ACL_OTHER 型 ACE 所记录的权限授予进程.