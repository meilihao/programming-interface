# 权限

## 用户id
唯一标识一个用户的整数,信息存储在[`/etc/passwd`](files/passwd.md)里.`0`属于`root`.

## 组id
唯一标识若干用户的整数,信息存储在`/etc/group`里.`0`属于`root`组.

允许多个用户在一个组里, 便于同组成员共享资源.

用户最多可在NGROUPS_MAX个组里(`sysconf(_SC_NGROUPS_MAX)`或`/proc/sys/kernel/ngroups_max`).

## SUID
SUID权限**仅对二进制可执行文件有效**,让用户在执行时具有文件所有者的权限,且该权限仅在执行该文件的过程中有效.

```
chmod u+s xxx
```

举例: passwd命令

## SGID

### SGID对目录

- 用户在此目录下的有效用户组将会变成该目录的用户组, 此时如果用户在该目录下具有 w 的权限,则其所创建的新文件的用户组与此目录的用户组相同.

用途: 文件共享

### SGID对文件

- SGID 对二进制可执行文件有效
- 用户对该文件具备 x 的权限
- 在执行的过程中将会获得该文件群组的支持

举例: locate命令

## 
saved set-user-ID 和 saved set-group-ID 允许 set-user-ID(SUID) 和
set-group-ID(SGID) 程序临时性地放弃特权,并在之后恢复特权.

## sticky bit

是在other用户的权限上设置,可以理解为防删除位,**仅对目录有效**.
如果具有可执行权限，设置sticky bit后是t；如果没有可执行权限的话，设置sticky bit后是T.

```
chmod o+t xxx
```

- 对一个目录设置了sticky-bit之后,比如`rwxrwxrwt`，当用户在该目录下建立文件或目录时, 这些文件仅准许其属主(或root)执行删除、 移动等操作.

举例: /tmp目录

## 实际用户UID和有效用户EUID(Effective UID)
实际用户指用户登录时所使用的用户.
有效用户指当前执行操作的用户,能利用su或sudo进行切换.

## 文件访问
新建/删除一个文件就必须对包含该文件的目录具有写权限和执行权限.

新文件的用户id是进程的有效用户id, 其组id是进程的有效组id/它所在目录的组id.

## example
1. 获取进程的uid和gid
```go
package main

import (
	"log"
	"os"
)

func main() {
	log.Printf("uid = %d, gid = %d\n", os.Getuid(), os.Getgid())
}
```

## rwx
检查文件权限时,内核所遵循的规则如下:
1. 对于特权级进程,授予其所有访问权限
2. 若进程的有效用户 ID 与文件的用户 ID(属主)相同,内核会根据文件的属主权限,授予
进程相应的访问权限.
3. 若进程的有效组 ID 或任一附属组 ID 与文件的组 ID(属组)相匹配,内核会根据文件的
属组权限,授予进程对文件的相应访问权限.
4. 若以上三点皆不满足,内核会根据文件的 other(其他)权限,授予进程相应权限.

### 对文件
r: 读取文件内容
w: 新增/修改文件内容. 删除文件(修改文件名等)的权限受父目录的权限控制, 和文件本身的权限无关, 因为文件名在父目录的block里.
x: 可执行. 普通用户还必须同时有r权限才能执行, root没有r权限但有x权限(ugo上的都可以)也能执行.

### 对目录
r: 浏览目录内文件(包括子目录)的权限. 没有x不能进入目录即无法`cd dir`,`ls -l`仅可看到目录名下的文件名, 属性会用问号表示
w: 增加, 删除, 修改目录内文件名的权限, 需要x配合. 要删除文件,对文件本身无需有任何权限仅关心目录权限.
x: 进入目录的权限. 没有r则无法获取文件列表; 没有w则无法新建文件

## 扩展属性(EA)
以名称-值对形式将任意元数据与文件 i 节点关联起来的技术.

## ACL(access control list, 访问控制列表)
`rwx+ugo`能满足大部分需求, 但不够细致, 因此有了ACL. NFSv4 ACL是事实标准, 兼容POSIX ACL, 兼容大部分windows权限位.

exte4的POSIX ACL默认是禁用, 可使用`mount -o acl`打开.