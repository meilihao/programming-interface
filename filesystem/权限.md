# 权限

## 用户id
唯一标识一个用户的整数,信息存储在[`/etc/passwd`](files/passwd.md)里.`0`属于`root`.

通常id段划分:
- 管理员 UID 为 0：系统的管理员用户
- 系统用户 UID 为 1～999： Linux 系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会有独立的系统用户负责运行，进而有效控制被破坏范围
- 普通用户 UID 从 1000 开始：是由管理员创建的用于日常工作的用户

## 组id
唯一标识若干用户的整数,信息存储在`/etc/group`里.`0`属于`root`组.

允许多个用户在一个组里, 便于同组成员共享资源.

用户最多可在NGROUPS_MAX个组里(`sysconf(_SC_NGROUPS_MAX)`或`/proc/sys/kernel/ngroups_max`).

## 文件特殊权限
Saved set-user-ID / Saved set-group-ID：这两个 ID 在 set-user-ID 与 set-group-ID 程序执行后，保存相应的 effective ID.  因此，一个 set-user-ID(SUID) 程序的 effective user ID 可以在 real user ID 与 saved set-user-ID 之间来回切换，从而可以恢复 / 抛弃特权; 同理set-group-ID(SGID)也是这样.

SUID(权限位:4) 和 SGID(权限位:2) 的写法是, 原先有执行权限则是小写 s，如果没有执行权限则是大写 S； 而 SBIT(权限位:1) 的写法则是, 原先有执行权限是
小写 t，没有执行权限是大写 T.

### SUID
SUID权限**仅对二进制可执行文件有效**,让用户在执行时临时具有文件所有者的权限,且该权限仅在执行该文件的过程中有效.

```
# chmod u+s xxx
# ls -l /bin/passwd 
-rwsr-xr-x. 1 root root 27832 Jan 29 2017 /bin/passwd
```

举例: passwd命令

### SGID

#### SGID对目录

- 在某个目录中创建的文件(前提是用户在该目录下具有 w 的权限)会自动继承该目录的有效用户组

用途: 文件共享

#### SGID对文件

- 对具备 x 权限的二进制可执行文件有效
- 在执行的过程中将会获得该文件群组的支持

举例: locate命令
```bash
$ chmod g+s xxx
$ ll /usr/bin/plocate 
-rwxr-sr-x 1 root plocate 307K  2月 17  2022 /usr/bin/plocate*
```

### sticky bit(SBIT)

是在other用户的权限上设置,可以理解为防删除位,**仅对目录有效**.
如果具有可执行权限，设置sticky bit后是t；如果没有可执行权限的话，则是T.

```bash
$ chmod o+t xxx
$ ls -ald /tmp
drwxrwxrwt 22 root root 20480 11月 16 09:05 /tmp
```

- 对一个目录设置了sticky-bit之后,比如`rwxrwxrwt`，当用户在该目录下建立文件或目录时, 这些文件仅准许其属主(或root)执行删除、 移动等操作.

举例: /tmp目录

## 文件的隐藏属性
可用chattr 命令中维护.

## 实际用户UID和有效用户EUID(Effective UID)
实际用户指用户登录时所使用的用户.
有效用户指当前执行操作的用户,能利用su或sudo进行切换.

su 命令用于切换用户身份. su 命令与用户名之间有一个减号`-`意味着完全切换到新的用户，即把环境变量信息也变更为新用户的相应信息，而不是保留原始的信息,**推荐**.
sudo 命令可把特定命令的执行权限赋予给指定用户.

## 文件访问
新建/删除一个文件就必须对包含该文件的目录具有写权限和执行权限.

新文件的用户id是进程的有效用户id, 其组id是进程的有效组id/它所在目录的组id.

## example
1. 获取进程的uid和gid
```go
package main

import (
	"log"
	"os"
)

func main() {
	log.Printf("uid = %d, gid = %d\n", os.Getuid(), os.Getgid())
}
```

## rwx
检查文件权限时,内核所遵循的规则如下:
1. 对于特权级进程,授予其所有访问权限
2. 若进程的有效用户 ID 与文件的用户 ID(属主)相同,内核会根据文件的属主权限,授予
进程相应的访问权限.
3. 若进程的有效组 ID 或任一附属组 ID 与文件的组 ID(属组)相匹配,内核会根据文件的
属组权限,授予进程对文件的相应访问权限.
4. 若以上三点皆不满足,内核会根据文件的 other(其他)权限,授予进程相应权限.

> "000"权限对root没有意义.

### 对文件
r: 读取文件内容
w: 新增/修改文件内容. 删除文件(修改文件名等)的权限受父目录的权限控制, 和文件本身的权限无关, 因为文件名在父目录的block里.
x: 可执行. 普通用户还必须同时有r权限才能执行, root没有r权限但有x权限(ugo上的都可以)也能执行.

### 对目录
r: 浏览目录内文件(包括子目录)的权限. 没有x不能进入目录即无法`cd dir`,`ls -l`仅可看到目录名下的文件名, 属性会用问号表示
w: 增加, 删除, 修改目录内文件名的权限, 需要x配合. 要删除文件,对文件本身无需有任何权限仅关心目录权限.
x: 进入目录的权限. 没有r则无法获取文件列表; 没有w则无法新建文件

### 权限检查算法(from `Linux/Unix系统编程手册`)
1. 对于特权级进程,授予其所有访问权限
2. 若进程的有效用户 ID 与文件的用户 ID(属主)相同,内核会根据文件的属主权限,授予
进程相应的访问权限. 比方说,若文件权限掩码中的属主读权限(owner-read permission)
位被置位,则授予进程读权限, 否则,则拒绝进程对文件的读取操作
3. 若进程的有效组 ID 或任一附属组 ID 与文件的组 ID(属组)相匹配,内核会根据文件的
属组权限,授予进程对文件的相应访问权限
4. 若以上三点皆不满足,内核会根据文件的 other(其他)权限,授予进程相应权限

## 扩展属性(EA)
以名称-值对形式将任意元数据与文件 i 节点关联起来的技术.

## ACL(access control list, 文件访问控制列表)
`rwx+ugo`能满足大部分需求, 但不够细致, 因此有了ACL. NFSv4 ACL是事实标准, 兼容POSIX ACL, 兼容大部分windows权限位.

exte4的POSIX ACL默认是禁用, 可使用`mount -o acl`打开.

setfacl 命令用于管理文件的 ACL 规则.
getfacl 命令用于显示文件上设置的 ACL 信息.

### ACL 权限检查算法
1. 若进程具有特权,则拥有所有访问权限. 与传统文件权限模型相类似,这里也有一个例外. 执行某文件时,仅当将可执行权限通过至少一条 ACL 记录授予该文件
时,系统才会向特权级进程授予该权限.
2. 若某一进程的有效用户 ID 匹配文件的属主(用户 ID),则授予该进程标记类型为
ACL_USER_OBJ 的 ACE 所指定的权限.
4. 若进程的组 ID(亦即,有效组 ID 或任一辅助组 ID)之一匹配于文件组(对应于标记类
型为 ACL_GROUP_OBJ 的 ACE),或者任一 ACL_GROUP 型记录的标记限定符,则会依
次进行如下检查,直至发现匹配项.
	1. 若进程的组 ID 之一匹配于文件组,且标记类型为 ACL_GROUP_OBJ 的 ACE 授予了
所请求的权限,则会依据此记录来判定对文件的访问权限. 如果 ACL 中还包含了标记
类型为 ACL_MASK 的 ACE,那么对该文件的访问权限将是两记录权限相与(&)后
的结果.
	2. 若进程的组 ID 之一匹配于该文件所辖 ACL_GROUP 型 ACE 的标记限定符,且该 ACE
授予了所请求的权限,那么会依据此记录来判定对文件的访问权限。如果 ACL 中包含
了 ACL_MASK 型 ACE,那么对该文件的访问权限应为两记录权限相与(&)的结果.
	3. 否则,拒绝对该文件的访问.
5. 否则,将以 ACL_OTHER 型 ACE 所记录的权限授予进程.