# 权限

## 用户id
唯一标识一个用户的整数,信息存储在`/etc/passwd`里.`0`属于`root`.

## 组id
唯一标识若干用户的整数,信息存储在`/etc/group`里.`0`属于`root`组.

允许多个用户在一个组里, 便于同组成员共享资源.

## SUID
SUID权限**仅对二进制可执行文件有效**,让用户在执行时具有文件所有者的权限,且该权限仅在执行该文件的过程中有效.

```
chmod u+s xxx
```

举例: passwd命令

## SGID

### SGID对目录

- 用户在此目录下的有效用户组将会变成该目录的用户组, 此时如果用户在该目录下具有 w 的权限,则其所创建的新文件的用户组与此目录的用户组相同

### SGID对文件

- SGID 对二进制可执行文件有效
- 用户对该文件具备 x 的权限
- 在执行的过程中将会获得该文件群组的支持

举例: locate命令

## sticky bit

是在other用户的权限上设置,可以理解为防删除位,**仅对目录有效**.
如果具有可执行权限，设置sticky bit后是t；如果没有可执行权限的话，设置sticky bit后是T.

```
chmod o+t xxx
```

- 对一个目录设置了sticky-bit之后,比如`rwxrwxrwt`，当用户在该目录下建立文件或目录时, 这些文件仅准许其属主(或root)执行删除、 移动等操作.

举例: /tmp目录

## 实际用户UID和有效用户EUID(Effective UID)
实际用户指用户登录时所使用的用户.
有效用户指当前执行操作的用户,能利用su或sudo进行切换.

## 文件访问
新建/删除一个文件就必须对包含该文件的目录具有写权限和执行权限.

新文件的用户id是进程的有效用户id, 其组id是进程的有效组id/它所在目录的组id.

## example
1. 获取进程的uid和gid
```go
package main

import (
	"log"
	"os"
)

func main() {
	log.Printf("uid = %d, gid = %d\n", os.Getuid(), os.Getgid())
}
```

## rwx
### 对文件
r: 读取文件内容
w: 新增/修改文件内容. 删除文件(修改文件名等)的权限受父目录的权限控制, 和文件本身的权限无关, 因为文件名在父目录的block里.
x: 可执行. 普通用户还必须同时有r权限才能执行, root没有r权限但有x权限(ugo上的都可以)也能执行.

### 对目录
r: 浏览目录内文件(包括子目录)的权限. 没有x不能进入目录即无法`cd dir`,`ls -l`仅可看到目录名下的文件名, 属性会用问号表示
w: 增加, 删除, 修改目录内文件名的权限, 需要x配合.
x: 进入目录的权限. 没有r则无法获取文件列表; 没有w则无法新建文件