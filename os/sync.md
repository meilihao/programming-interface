# 同步原语
ref:
- [基本功 | 一文讲清多线程和多线程同步](https://my.oschina.net/meituantech/blog/11585606)

## 互斥锁
这种任意时刻只允许至多一个线程访问的方式被称为互斥访问(mutual exclusion), 而保证互斥访问共享资源的代码区域被称为临界区(critical section).

在单核环境, 在进入临界区前关闭中断, 避免当前线程被其他线程抢占, 离开后再开启中断, 便能够避免当前执行临界区代码的线程被打断,保证任意时刻只有一个线程执行临界区.

在现代cpu上, 有提供硬件解决方案即用硬件提供的原子操作（atomic operation）设计新的软件算法来解决临界区问题. 最常见的原子操作包括比较与置换（Compare-And-Swap, CAS）、拿取并累加（Fetch-And-Add, FAA）等.

在Intel平台, 应用程序主要通过使用带lock前缀的指令来保证操作的原子性; ARM采用了Load-Link/Store-Conditional(LL/SC)的指令组合, ARMv8中支持了LSE（Large System Extension)即单条指令完成原子操作.

利用硬件保证的原子操作, 可以实现互斥锁（mutex lock）夹解决临界区问题. 互斥锁的实现种类繁多, 不同的互斥锁被用于不同的场景, 以达到最好的性能表现. 比如, 利用原子CAS实现的自旋锁（spin lock）与利用原子FAA实现的排号自旋锁（ticket lock）.

自旋锁并不能保证有限等待, 即自旋锁不具有公平性

从自旋锁的实现可以看出, 自旋锁并非按照申请的顺序决定下一个获取锁的竞争者, 而是让所有的竞争者均同时尝试完成原子操作, 而原子操作的成功与否完全取决于硬件特性, 比如arm的大小核架构上.

排号自旋锁采取了一种更加公平的选择策略: 按照锁竞争者申请锁的顺序传递锁.

## 条件变量
条件变量（condition variable)是一种提供挂起/唤醒来避免循环等待(busy looping)的机制, 以节省cpu资源.

条件变量必须搭配一个互斥锁一起使用, 该互斥锁用于保护对条件的判断与修改. linux使用futex机制实现的互斥锁能降低开销: 在竞争程度较低时, 直接使用原子操作完成加锁; 而在竞争程度较高时, 应用程序能够通过系统调用挂起并等待被后续锁持有者唤醒. futex机制不仅可以用于避免互斥锁中的循环等待, 还能用于实现条件变量等各类同步原语.

条件变量提供了两个接口: cond_wait和cond_signal, 分别用于挂起当前线程与唤醒等待在该条件变量上的线程.

件变量一般还提供广播（cond_broadcast）, 用于唤醒所有等待在条件变量上的线程.

## 信号量
条件变量与信号量提供了类似的操作接口. 信号量是由条件变量, 互斥锁以及计数器实现的, 而这个计数器就是信号量的核心, 用于表示当前可用资源的数量. 因此可以理解为: 信号量利用条件变量实现了更高层级的抽象.

互斥锁用于保证多个线程对一个共享资源的互斥访问, 而信号量则用于协调多个线程对一系列共享资源的有序操作.

## 读写锁
## RCU
RCU（Read-Copy Update）是一种在kernel中广泛使用的同步原语， 其有效地减少了reader在关键路径上的性能开销.

RCU中的reader不会被writer阻塞且无须使用耗时的同步操作, 因此RCU中的reader的开销更小.

## 锁问题
### 死锁
死锁（deadlock）就是指这一组中的每一个线程都在等待组内其他线程释放资源从而造成的无限等待.

### 活锁
同死锁类似, 出现活锁时, 锁的竞争者很一段时间都无法获取锁进入临界区.

### 优先级反转
优先级反转（priority inversion）是由于同步导致线程执行顺序违反预设优先级的问题.

在现代操作系统中, 通常采用的方法是使用优先级继承协议（Priority Inheritance Protocol, PIP）来避免.