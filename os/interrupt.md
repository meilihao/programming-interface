# interrupt

## cpu识别中断
x86处理器通过INTR和NMI 两个引脚分别接收外部中断请求信号: INTR接收可屏蔽中断, NMI接收不可屏蔽中断请求. 标志寄存器EFLAGS中的IF标志决定是否屏蔽可屏蔽中断请求.

在SMP结构中, 每个处理器都包含一个IOAPIC(高级可编程中断控制器), 外部设备产生中断请求时, 通过该中断控制器并传递给cpu.

有两个与IF标志相关的函数, local_irq_enable和local_irq_disable, 它们通过设置或清除本地cpu的EFLAGS的IF标志来控制是否使能本地中断.

## 中断处理程序
每个中断都可以有自己的中断处理程序, 这些程序集中存储构成了中断描述表(Interrupt Descriptor Table, IDT). 它包含了256个中断描述符, 用数组idt_table表示.

中断描述符由struct gate_desc表示, 有GATE_INTERRUPT, CATE_TRAP, GATE_CALL和GATE_TASK几种, idt_table就是gate_desc类型的数组. 系统启动时会为idt_table赋值, 然后将它的地址写入寄存器. 当中断发生时, cpu会根据该地址和中断号, 计算得到对应的中断处理程序的地址并执行.

在256个中断中, 前32个(`0x00~0x1F`)是x86预留的, X86_LOCAL_APIC使能的情况下, `0xec~255`供APIC使用, 其余的(非专用)则由os使用.

kernel定义了多种专用的中断描述符, 多以idt_data数组的形式存在, 比如early_idts, def_idts, apic_idts, 系统初始化过程中会调用idt_setup_from_table将这些数组的元素信息转换为idt_table对应的元素信息.

内核在中断初始化的过程中可以给`0x20~0xeb`号中断指定具体的中断处理程序, 此时由system_vectors位图来表示一个中断是否已指定, 没有指定的会被设为默认值.

所有的中断处理程序必须即能正确处理中断, 有能保证处理完毕后可以返回中断前的程序继续执行. 因此, 中断处理必须完成3个任务:
1. 保存现场以便恢复
1. 调用已注册的中断服务例程(isr)处理中断
1. 恢复现场继续原有程序

中断处理程序和中断服务例程的区别: 中断处理程序包括中断处理的整个过程, 而中断服务例程是该过程中对产生中断的设备的处理逻辑. 并不是所有的中断处理程序都需要对应的中断服务例程, 中断服务例程是为了方便外设驱动利用内核提供的函数编程. 有了中断服务例程, dirver只需要专注处理设备自身的中断而不需要关系整个过程.