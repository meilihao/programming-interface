# os
计算机(冯·诺依曼体系结构)组成:
- 硬件

  由cpu(控制器+运算器), 存储(内存+外存), i/o组成.
- 软件
  
  - 系统软件: os, 编译器等
  - 应用软件

![Linux操作系统层次结构](/misc/img/os/20190430163149125_TYWCZD.jpg)

对 UNIX 的定义通常有两种:
1. 指通过 SUS 所规范的官方一致性测试,且由OPEN GROUP(UNIX 商标的持有者)正式授权冠以“UNIX”的操作系统. 目前尚无开源的 UNIX 实现(比如,Linux 和 FreeBSD)获得了“UNIX”冠名.
1. 指那种运作方式类似于经典 UNIX 系统(比如,最初的 Bell实验室 UNIX 系统,及其后来的主要分支 System V 和 BSD)的操作系统. 根据这一定义, 一般会将 Linux 视为 UNIX 系统(如同现代 BSD 系统一样).

os标准: POSIX, Single UNIX Specification V4:2018(基于POSIX), Linux Standard Base

os: 为上层软件提供抽象, 管理计算机硬件与软件资源的系统软件, 包括内核层和应用层:
- 内核层: 

  主要负责控制硬件设备, 分配系统资源, 为应用层提供鲁棒接口, 保障应用程序正常运行等全局性工作, 包括:
  - 引导启动
  
    在bios上电自检到跳转至内核执行前的阶段, 由bootloader负责. 它主要负责计算机硬件检测, 配置内核运行参数. 常见的bootloader有grub2, coreboot+[LinuxBoot](https://linux.cn/article-10257-1.html).
  - 内存管理
  
    linux的slab算法可算一种稳定成熟的内存管理算法, 可以长时间保障内存稳定分配, 且防止内存碎片过多. linux还使用红黑树管理内存线性地址空间, 它兼顾了搜索时间和插入时间.
  - 异常/中断处理
  
    异常即程序运行时的错误, 比如除零, 段溢出, 页错误, 无效指令, 调试错误等, 需根据错误类型和程序逻辑进行相应的处理.
    
    中断处理是处理器收到硬件设备发出/软件模拟的请中断请求并进行相应的处理, 相关效率会影响系统整体性能. 通常，中断处理会被分为中断上半部和中断下半部: 中断上半部要求快速响应中断，在取得必要的数据和信息后尽早开启中断，以使处理器能够再次接收中断请求信号; 中断下半部被用来执行剩余中断内容, 像数据解析、驱动程序状态调整等更耗时的内容. 为了让更紧迫的进程优先执行，中断下半部还可将处理内容安放在一个进程中，以让更高优先级的进程得到快速执行.
    
  - 进程管理
  
    进程调度, 比如linux的cfs完全公平调度策略.
    [进程间通信](/process/进程间通信.md)
  - 设备驱动
  
    通常仅将必须的驱动编入kernel, 其他以modules形式加载, 以减小内核体积, 加快系统启动速度.

  - 文件系统

    linux的vfs, ext4, btrfs, xfs.
- 应用层: 系统api和应用程序, 主要负责人机交互

  - 系统api: 符号posix规范, 为应用提供便捷的调用接口.
  - 应用程序

编写os需要的知识:
  - 硬件
  
    掌握硬件电路、处理器和外围设备的芯片手册即可. 其中，掌握硬件电路就可以知道处理器如何连接及控制外围设备，以及采用何种方式与它们通信; 处理器芯片手册会介绍如何初始化处理器、如何切换处理器工作模式等一系列操作处理器的信息与方法，这些知识为操作系统运行提供技术指导; 硬件芯片手册会对设备上的所有寄存器功能进行描述，根据这些寄存器功能方可编写出驱动程序.
  - 软件

    - 汇编
    
      主要用于控制和配置cpu, 例如引导启动处理器、配置处理器运行状态、进程切换、中断和异常处理程序、设备I/O端口操作等必须操作寄存器的工作，或者是对性能要求极为苛刻的场景.
    - c语言/rust

  - 算法

> coreboot+linuxboot参考: [Using LinuxBOOT and coreboot as bootloader](https://www.eltan.com/downloads/bootloader-topics/356-linuxboot-coreboot.html), [coreboot Payloads](https://www.coreboot.org/Payloads).

![操作系统整体结构图](/misc/img/os/02.d01z.001.png)

> 抽象是管理复杂性的一个关键, 比如类nix的一切皆是文件.
> os的资源管理采用两种方法实现多路复用: 1. 时间上, 比如时间分片,共享打印机; 2. 空间, 比如进程空间.
> io设备 = 设备控制器 + 设备本身.

`count = read(fd, buffer, nbytes)`:
![系统调用](/misc/img/os/system_call.png)

![](/misc/img/os/1920px-OS-structure2.png)
os分类:
- 宏内核 : 所有的模块都在同一个内核空间上运行
- 微内核 : 将许多OS服务放入分离的进程，如文件系统，设备驱动程序，而进程通过消息传递调用OS服务.
- 混合内核

中断：在计算机执行程序的过程中，当出现异常情况或者特殊请求时，计算机停止现行的程序的运行，转而对这些异常处理或者特殊请求的处理，处理结束后再返回到现行程序的中断处，继续执行原程序.
中断向量（Interrupt vector, 向量即指针）是中断服务程序的入口地址.

忙等待(busy waiting): 连续测试一个变量直到某个值出现为止.
自旋锁(spin lock): 用于忙等待的锁. 线程反复检查锁变量是否可用. 由于线程在这一过程中保持执行，因此是一种忙等待. 一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁. 读写自旋锁的存储内存或寄存器的操作必须是原子的, 通常用test-and-set等原子操作来实现.

kernel职能:
- 进程调度
- 内存管理
- 设备管理
- 文件系统
- 网络
- system call

用户态和内核态:
现代处理器架构一般允许 CPU 至少在两种不同状态下运行,即:用户态和内核态(有
时也称之为监管态 supervisor mode). 执行硬件指令可使 CPU 在两种状态间来回切换. 与
之对应,可将虚拟内存区域划分(标记)为用户空间部分或内核空间部分. 在用户态下运
行时,CPU 只能访问被标记为用户空间的内存,试图访问属于内核空间的内存会引发硬件
异常. 当运行于核心态时,CPU 既能访问用户空间内存,也能访问内核空间内存.

### 实时性
为支持实时性应用,POSIX.1b 定义了多个 POSIX.1 扩展,其中包括异步 I/O、共享内存、
内存映射文件、内存锁定、实时性时钟和定时器、备选调度策略、实时性信号、消息队列以及信号量等.

## 进程和线程
### 调度
抢占式/非抢占式调度:
- 抢占式 ：当前进程运行时，有一个更高优先级的任务出现时，如果当前内核允许抢占，则可以将当前任务挂起去执行优先级更高的进程.
- 非抢占式：高优先级的进程不能中止正在内核中运行的低优先级的进程而抢占CPU运行. 当前进程除非自愿放弃CPU，否则该进程将一直运行下去，直至完成或退出内核.

抢占式的意义：首先，这是实时系统所必需的. 实时系统对响应时间有严格的限定，当一个实时进程被实时设备的硬件中断唤醒后，它应在限定的时间内被调度执行.

批处理系统的调度:
1. 先来先服务(first-come first served)
1. 最短作业优先(shortest job first)
1. 最短剩余时间优先(shortest remaining time next)

交互式系统的调度:
1. 时间片轮转(round robin)
1. 优先级

   避免高优先级长时间运行: 1. 每隔时钟滴答降低优先级 2. 运行运行的最长时间
1. 彩票调度
1. 公平分享调度

实时系统的调度:

> 硬实时(hard real time)和软实时(soft real time), 前者必须满足绝对的截止时间.
> `机制` 回答的是 what，`策略` 回答的是 how.
> 为了调度最优, 采用了调度机制(scheduling mechanism)和调度策略(scheduling policy)分离的方法, 即将调度算法参数化, 可配置.

## 内存管理
空闲内存管理:
1. 位图法: 位图大小取决于内存大小和分配单元的大小.
1. 链表法: 各维护一个已分配内存段和空闲内存段的链表, 链表按照地址排序.

虚拟内存(virtual memory)思想:

每个进程有自己的**连续完整**地址空间, 但实际上该空间被分成了很多块, 每个块是一个页(page, 通常是4k), 这些页通过(Memory Management Unit, MMU))被映射到物理内存上,在内存中对应的单元叫页框(page frame), 通常页与页框大小一致, 但并不是所有的页都必须在内存中才能运行程序. 但程序引用的一部分地址不在物理内存上时,os会先将缺失的部分装入物理内存并重新执行. 它使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率.

> x86-84支持4K, 2M, 1G的page. 4K用于程序, 1G的用于kernel.
> 实际硬件中会用一个"在/不在"(present/absent bit)记录页面在内存中的实际存在情况.

程序访问一个未映射的页面时, MMU触发缺页中断或缺页错误(page fault).

操作系统虚拟内存到物理内存的映射表被称为页表, 它与cpu架构密切相关, 每个进程都有(每个进程都有一个虚拟内存), 其目的是将虚拟页面映射为页框.

虚拟地址被分为虚拟页号(高位部分)和偏移量(低位部分). 虚拟页号可作为页表的索引.
![页表项](/misc/img/os/OBQiScL.png)

加速分页的方法: 快表.

针对大内存的页表:
1. 多级分页
1. 倒排页表

页面置换: 发生缺页中断时, os选择内存中的一个页面将其换出内存, 以便为即将换入的page腾出空间.

页面置换算法:
1. 最近未使用(Not Recently Used) : LRU的很粗略的近似
1. 先进先出(FIFO, First-In First-Out) : 可能换出常用页面
1. 第二次机会(second chance) : 比FIFO有较大改善
1. 时钟
1. 最近最少使用(LRU, Least Recently Used) : 很好, 但很难实现(依赖特定硬件的实现)
1. 最不经常使用(NFU) : LRU的相对粗略的近似
1. **工作集时钟** : 好的有效算法
1. **老化** : 非常近似LRU的有效算法

> 参考: 现代操作系统v4的图3-21

> 一个进程当前正在使用的页面的集合成为工作集.

分页系统中的设计问题:
1. 共享库 : 只使用相对偏移量的代码即位置无关代码(position-independent code)

os会在四个时间里进行分页相关工作:
1. 进程创建
1. 进程执行
1. 缺页中断
1. 进程终止

## 文件系统

## io
io设备通常由两部分组成设备控制器(`device controller`/`adapter`) + 设备本身, 两者不一定在一起, 比如raid卡和scsi硬盘.

cpu与设备控制器的寄存器及数据缓冲区通讯的方法:
1. 每个控制器分配一个io端口(io port), cpu指令通过port操作控制器, 且内存地址空间和io地址空间是不同的. 早期计算机采用.
1. 内存映射io(memory-mapped io): 将控制器映射到内存空间. 在大多数系统中, 分配给控制器的地址位于或接近地址空间的顶端. x86体系采用.
