# os
计算机(冯·诺依曼体系结构)组成:
- 硬件

  由cpu(控制器+运算器), 存储(内存+外存), i/o组成.
- 软件
  
  - 系统软件: os, 编译器等
  - 应用软件

![Linux操作系统层次结构](/misc/img/os/20190430163149125_TYWCZD.jpg)

对 UNIX 的定义通常有两种:
1. 指通过 SUS 所规范的官方一致性测试,且由OPEN GROUP(UNIX 商标的持有者)正式授权冠以“UNIX”的操作系统. 目前尚无开源的 UNIX 实现(比如,Linux 和 FreeBSD)获得了“UNIX”冠名.
1. 指那种运作方式类似于经典 UNIX 系统(比如,最初的 Bell实验室 UNIX 系统,及其后来的主要分支 System V 和 BSD)的操作系统. 根据这一定义, 一般会将 Linux 视为 UNIX 系统(如同现代 BSD 系统一样).

os标准: POSIX, Single UNIX Specification V4:2018(基于POSIX), Linux Standard Base

os: 为上层软件提供抽象, 管理计算机硬件与软件资源的系统软件.

> 抽象是管理复杂性的一个关键, 比如类nix的一切皆是文件.
> os的资源管理采用两种方法实现多路复用: 1. 时间上, 比如时间分片,共享打印机; 2. 空间, 比如进程空间.
> io设备 = 设备控制器 + 设备本身.

`count = read(fd, buffer, nbytes)`:
![系统调用](/misc/img/os/system_call.png)

![](/misc/img/os/1920px-OS-structure2.png)
os分类:
- 宏内核 : 所有的模块都在同一个内核空间上运行
- 微内核 : 将许多OS服务放入分离的进程，如文件系统，设备驱动程序，而进程通过消息传递调用OS服务.
- 混合内核

中断：在计算机执行程序的过程中，当出现异常情况或者特殊请求时，计算机停止现行的程序的运行，转而对这些异常处理或者特殊请求的处理，处理结束后再返回到现行程序的中断处，继续执行原程序.
中断向量（Interrupt vector, 向量即指针）是中断服务程序的入口地址.

忙等待(busy waiting): 连续测试一个变量直到某个值出现为止.
自旋锁(spin lock): 用于忙等待的锁. 线程反复检查锁变量是否可用. 由于线程在这一过程中保持执行，因此是一种忙等待. 一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁. 读写自旋锁的存储内存或寄存器的操作必须是原子的, 通常用test-and-set等原子操作来实现.

kernel职能:
- 进程调度
- 内存管理
- 设备管理
- 文件系统
- 网络
- system call

用户态和内核态:
现代处理器架构一般允许 CPU 至少在两种不同状态下运行,即:用户态和内核态(有
时也称之为监管态 supervisor mode). 执行硬件指令可使 CPU 在两种状态间来回切换. 与
之对应,可将虚拟内存区域划分(标记)为用户空间部分或内核空间部分. 在用户态下运
行时,CPU 只能访问被标记为用户空间的内存,试图访问属于内核空间的内存会引发硬件
异常. 当运行于核心态时,CPU 既能访问用户空间内存,也能访问内核空间内存.

## 进程和线程
### 调度
抢占式/非抢占式调度:
- 抢占式 ：当前进程运行时，有一个更高优先级的任务出现时，如果当前内核允许抢占，则可以将当前任务挂起去执行优先级更高的进程.
- 非抢占式：高优先级的进程不能中止正在内核中运行的低优先级的进程而抢占CPU运行. 当前进程除非自愿放弃CPU，否则该进程将一直运行下去，直至完成或退出内核.

抢占式的意义：首先，这是实时系统所必需的. 实时系统对响应时间有严格的限定，当一个实时进程被实时设备的硬件中断唤醒后，它应在限定的时间内被调度执行.

批处理系统的调度:
1. 先来先服务(first-come first served)
1. 最短作业优先(shortest job first)
1. 最短剩余时间优先(shortest remaining time next)

交互式系统的调度:
1. 时间片轮转(round robin)
1. 优先级

   避免高优先级长时间运行: 1. 每隔时钟滴答降低优先级 2. 运行运行的最长时间
1. 彩票调度
1. 公平分享调度

实时系统的调度:

> 硬实时(hard real time)和软实时(soft real time), 前者必须满足绝对的截止时间.
> `机制` 回答的是 what，`策略` 回答的是 how.
> 为了调度最优, 采用了调度机制(scheduling mechanism)和调度策略(scheduling policy)分离的方法, 即将调度算法参数化, 可配置.

## 内存管理
空闲内存管理:
1. 位图法: 位图大小取决于内存大小和分配单元的大小.
1. 链表法: 各维护一个已分配内存段和空闲内存段的链表, 链表按照地址排序.

虚拟内存(virtual memory)思想:

每个进程有自己的**连续完整**地址空间, 但实际上该空间被分成了很多块, 每个块是一个页(page, 通常是4k), 这些页通过(Memory Management Unit, MMU))被映射到物理内存上,在内存中对应的单元叫页框(page frame), 通常页与页框大小一致, 但并不是所有的页都必须在内存中才能运行程序. 但程序引用的一部分地址不在物理内存上时,os会先将缺失的部分装入物理内存并重新执行. 它使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率.

> x86-84支持4K, 2M, 1G的page. 4K用于程序, 1G的用于kernel.
> 实际硬件中会用一个"在/不在"(present/absent bit)记录页面在内存中的实际存在情况.

程序访问一个未映射的页面时, MMU触发缺页中断或缺页错误(page fault).

操作系统虚拟内存到物理内存的映射表被称为页表, 它与cpu架构密切相关, 每个进程都有(每个进程都有一个虚拟内存), 其目的是将虚拟页面映射为页框.

虚拟地址被分为虚拟页号(高位部分)和偏移量(低位部分). 虚拟页号可作为页表的索引.
![页表项](/misc/img/os/OBQiScL.png)

加速分页的方法: 快表.

针对大内存的页表:
1. 多级分页
1. 倒排页表

页面置换: 发生缺页中断时, os选择内存中的一个页面将其换出内存, 以便为即将换入的page腾出空间.

页面置换算法:
1. 最近未使用(Not Recently Used) : LRU的很粗略的近似
1. 先进先出(FIFO, First-In First-Out) : 可能换出常用页面
1. 第二次机会(second chance) : 比FIFO有较大改善
1. 时钟
1. 最近最少使用(LRU, Least Recently Used) : 很好, 但很难实现(依赖特定硬件的实现)
1. 最不经常使用(NFU) : LRU的相对粗略的近似
1. **工作集时钟** : 好的有效算法
1. **老化** : 非常近似LRU的有效算法

> 参考: 现代操作系统v4的图3-21

> 一个进程当前正在使用的页面的集合成为工作集.

分页系统中的设计问题:
1. 共享库 : 只使用相对偏移量的代码即位置无关代码(position-independent code)

os会在四个时间里进行分页相关工作:
1. 进程创建
1. 进程执行
1. 缺页中断
1. 进程终止

## 文件系统

## io
io设备通常由两部分组成设备控制器(`device controller`/`adapter`) + 设备本身, 两者不一定在一起, 比如raid卡和scsi硬盘.

cpu与设备控制器的寄存器及数据缓冲区通讯的方法:
1. 每个控制器分配一个io端口(io port), cpu指令通过port操作控制器, 且内存地址空间和io地址空间是不同的. 早期计算机采用.
1. 内存映射io(memory-mapped io): 将控制器映射到内存空间. 在大多数系统中, 分配给控制器的地址位于或接近地址空间的顶端. x86体系采用.

### 块设备(block device) / 字符设备(character device)
- 块设备(**可寻址**) : 提供对设备(比如磁盘,蓝光光盘)带缓冲的访问, 每次访问以固定长度(块)为单位进行.
- 字符设备(**不可寻址**) : 接收或输出字符流的设备, 需**按顺序操作, 不支持随机操作**, 用于键盘, 串口, 打印机, 调制解调器等.