# 虚拟化
虚拟化是一种资源管理技术.

分类方式:
- 软硬件实现

    - 软件虚拟化: qemu, 性能较弱
    - 硬件虚拟化: intel vt
- 是否需要修改客户机内核

    - 半虚拟化 : 客户机需要更改系统内核才得以实现虚拟化, 比如virtio,xen
    - 全虚拟化 : 不需要修改客户机内核
- 虚拟层是直接位于硬件之上还是hostos上
    1. 主机级虚拟化
        1. Type 1类型 : 裸机架构虚拟化, 它是运行在服务器硬件之上, 比如阿里云的神龙架构(X-Dragon), 微软的Hyper-v、VMware vSphere的ESXi和Citrix的XenServer
        1. Type 2类型 : HostOS构虚拟化层, 它是运行在HostOS之上,  比如KVM, VMware Workstion, Oracle VM VirtualBox
    1. 容器级虚拟化, 比如docker

> 提供虚拟化的软件层称为 Hypervisor

> kvm因为其独特的设计是横跨在Type 1和Type 2之间的.

Linux查看机器是否虚拟机:
```sh
$ dmesg |grep -i virtual
[    0.029424] Booting paravirtualized kernel on KVM # 物理机是`Booting paravirtualized kernel on bare hardware`
[    0.660281] systemd[1]: Detected virtualization kvm.
# virt-what
# systemd-detect-virt
# cat /sys/class/dmi/id/sys_vendor
```

# qemu
参考:
- [一文读懂 Qemu 模拟器](https://www.jianshu.com/p/db8c20aa6a69)
- [Qemu KVM(Kernel Virtual Machine)学习笔记](https://github.com/yifengyou/learn-kvm)

qemu是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备, 虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件.

因为 Qemu 是纯软件实现的，所有的指令都要经 Qemu 过一手，性能非常低，所以，在生产环境中，大多数的做法都是配合 KVM 来完成虚拟化工作，因为 **KVM 是硬件辅助的虚拟化技术，主要负责 比较繁琐的 CPU 和内存虚拟化，而 Qemu 则负责 I/O 虚拟化**，两者合作各自发挥自身的优势，相得益彰.

从本质上看，虚拟出的每个虚拟机对应 host 上的一个 Qemu 进程，而虚拟机的执行线程（如 CPU 线程、I/O 线程等）对应 Qemu 进程的一个线程. 下面通过一个虚拟机启动过程看看 Qemu 是如何与 KVM 交互的:
```c
// 第一步，获取到 KVM 句柄
kvmfd = open("/dev/kvm", O_RDWR);
// 第二步，创建虚拟机，获取到虚拟机句柄.
vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);
// 第三步，为虚拟机映射内存，还有其他的 PCI，信号处理的初始化. ioctl(kvmfd, KVM_SET_USER_MEMORY_REGION, &mem);
// 第四步，将虚拟机镜像映射到内存，相当于物理机的 boot 过程，把镜像映射到内存.
// 第五步，创建 vCPU，并为 vCPU 分配内存空间.
ioctl(kvmfd, KVM_CREATE_VCPU, vcpuid);
vcpu->kvm_run_mmap_size = ioctl(kvm->dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);
// 第五步，创建 vCPU 个数的线程并运行虚拟机.ioctl(kvm->vcpus->vcpu_fd, KVM_RUN, 0);
// 第六步，线程进入循环，并捕获虚拟机退出原因，做相应的处理.
for (;;) {  
  ioctl(KVM_RUN)  
  switch (exit_reason) {      
    case KVM_EXIT_IO:  /* ... */      
    case KVM_EXIT_HLT: /* ... */  
  }
}
// 这里的退出并不一定是虚拟机关机，
// 虚拟机如果遇到 I/O 操作，访问硬件设备，缺页中断等都会退出执行，
// 退出执行可以理解为将 CPU 执行上下文返回到 Qemu.
```

## Qemu 源码结构

Qemu 软件虚拟化实现的思路是采用二进制指令翻译技术，主要是提取 guest 代码，然后将其翻译成 TCG 中间代码，最后再将中间代码翻译成 host 指定架构的代码.

所以，从宏观上看，源码结构主要包含以下几个部分：
- /vl.c：最主要的模拟循环，虚拟机环境初始化，和 CPU 的执行
- /target-arch/translate.c：将 guest 代码翻译成不同架构的 TCG 操作码
- /tcg/tcg.c：主要的 TCG 代码
- /tcg/arch/tcg-target.c：将 TCG 代码转化生成主机代码
- /cpu-exec.c：主要寻找下一个二进制翻译代码块，如果没有找到就请求得到下一个代码块，并且操作生成的代码块

## Qemu 的使用
```bash
$ git ls-remote -t git://git.qemu-project.org/qemu.git
$ git clone -b v5.0.0-rc3 --depth=1 git://git.qemu-project.org/qemu.git # from https://www.qemu.org/download/#source
$ cd qemu
$ git submodule init
$ git submodule update --recursive
$ ./configure --help
--enable-kvm：编译 KVM 模块，使 Qemu 可以利用 KVM 来访问硬件提供的虚拟化服务
--enable-vnc：启用 VNC
--enalbe-werror：编译时，将所有的警告当作错误处理
--target-list：选择目标机器的架构。默认是将所有的架构都编译，但为了更快的完成编
$ ./configure  --enable-kvm --enable-debug --enable-vnc --enable-werror  --target-list="x86_64-softmmu"
$ make
$ sudo make install
```

生成的相关程序:
- ivshmem-client/server：这是一个 guest 和 host 共享内存的应用程序，遵循 C/S 的架构
- qemu-ga：这是一个不利用网络实现 guest 和 host 之间交互的应用程序（使用 virtio-serial），运行在 guest 中
- qemu-io：这是一个执行 Qemu I/O 操作的命令行工具
- qemu-system-x86_64：Qemu 的核心应用程序，虚拟机就由它创建的

    使用 qemu-system-x86 来启动 x86 架构的虚拟机:`qemu-system-x86_64 test-vm-1.qcow2`, 因为 test-vm-1.qcow2 中并未给虚拟机安装操作系统，所以会提示 “No bootable device”，无可启动设备.

    启动 VM 安装操作系统镜像: `qemu-system-x86_64 -m 2048 -enable-kvm test-vm-1.qcow2 -cdrom ./Centos-Desktop-x86_64-20-1.iso`:
    - -m 指定虚拟机内存大小，默认单位是 MB
    - -enable-kvm 使用 KVM 进行加速
    - -cdrom 添加 fedora 的安装镜像

    iso安装完成后重起虚拟机便会从硬盘 ( test-vm-1.qcow2 ) 启动.
- qemu-img：创建虚拟机镜像文件的工具

    虚拟机镜像用来模拟虚拟机的硬盘，在启动虚拟机之前需要创建镜像文件. 镜像文件创建完成后，可使用 qemu-system-x86 来启动x86 架构的虚拟机.

    `qemu-img create -f qcow2 test-vm-1.qcow2 10G`:
    - -f 选项用于指定镜像的格式，qcow2 格式是 Qemu 最常用的镜像格式，采用来写时复制技术来优化性能
    - test-vm-1.qcow2 是镜像文件的名字
    - 10G是镜像文件大小

- qemu-nbd：磁盘挂载工具

# kvm
kvm(Kernel-based Virtual Machine), 是基于内核的虚拟化, 是采用硬件虚拟化(intel vt/amd v)的全虚拟化解决方案.

![kvm和qemu架构](/misc/img/os/virt/xLEwiKumTSA5HvW.png)


> 一个kvm vm对应一个linux进程, 每个vCPU是该进程下的一个线程, 还有单独的io处理线程. 因此可通过linux的各种进程调度来实现不同vm的权限限定, 优先级等.

> kvm vm看到的硬件是qemu模拟的(不包括VT-d透传的设备), 由qemu截获并转换为对实际设备的驱动操作.

![Xen, KVM, QEMU架构对比](/misc/img/os/virt/c5TkF1QHGyvS3dz.png)

相比于Xen架构，KVM架构有三大的优势：
1. 同等硬件资源环境下，KVM的性能表现更优
1. KVM架构天然的继承Linux内核更新迭代带来的系统优化，几乎不费力气，就完成了一次功能升级, 但对于Xen架构来说，每一次Xen Hypervisor内核或者Linux内核版本升级，Xen架构需要同步优化联调Xen Hypervisor内核和特权域(基于Linux的内核)，才能实现整个虚拟化内核的升级
1. 目前云厂商均使用kvm, 是趋势. 

![VirtIO](/misc/img/os/virt/WqYaSrQ3C8eEKuh.png)

## kvm特性
1. 内存管理

    vm的"物理内存"就是对应宿主机进程的虚拟内存.
    vm自身内存访问落实到真实的宿主机的物理内存的机制叫影子页表(shadow page table), kvm Hypervisor为每个vm准备一份影子页表, 与vm自身页表建立一一对应关系. 因为性能原因, 目前影子页表的映射转换(`GPA->HPA`)已由硬件完成(intel ept/amd npt), 默认开启.

    > - kvm内存映射转换: GVA(guest virtual address, 客户机虚拟地址)->GPA(guest physical address)->HVA(host virtual address, 宿主机虚拟地址)->HPA(host physical address).

    > - vm自身页表描述的是GVA->GPA; 影子页表描述的是GPA->HPA.
1. kvm image格式

    确切的说是qemu的功能.
    kvm的image格式是qcow2, 支持快照(包括多级快照), 压缩和加密.
1. 实时迁移

    在宿主机间迁移vm而不中断服务.
1. 设备驱动程序

    - 支持半虚拟化的驱动程序(virtio标准)来提高io性能.
    - 支持intel VT-d, 通过将宿主机的pci总线上的设备透传(pass-through)给vm.
1. 性能和可伸缩性

    继承了linux的性能和可伸缩性
