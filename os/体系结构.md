# 计算机体系结构
参考:
- [深入理解计算机系统v3]

计算机的三个根本性基础:
1. 计算机是输入, 运算, 输出的机器
1. 程序是指令和数据的集合
1. 计算机的处理方式有时与人的思维方式不一致 : 比如计算机处理的一切皆是数字.

> 机器语言是二进制语言, 是计算机可以直接识别的语言. 汇编是机器语言的助记符.
> 计算机系统中的所有信息皆是数值, 区分这些数值含义的唯一方法是了解信息的上下文.

程序的三种流程:
1. 顺序
1. 条件分支
1. 循环

面向对象三要素:
- 继承 : 通过继承已存在的类所拥有的成员而生成新的类
- 封装 : 在类所拥有的成员中,隐藏掉那些没有必要展现给该类调用者的成员
- 多态 : 针对同一种消息,不同的对象可以进行不同的操作

> 类是对象的定义,而对象是类的实例(Instance)

区分计算机体系结构和微结构:
- 体系结构(computer architecture)定义的是硬件和软件的接口，并没有指定实现. RISC-V即定义的体系结构.
- 微结构(processor microarchitecture)则描述的是如何设计一个处理器来符合一个体系结构. 体系结构并不定义微结构.

## 硬件
计算机构成:
1. 总线
    总线是计算机多个系统功能部件之间进行数据传送的公共通路,比如主板上密密麻麻的线路.
    总线按系统总线传输信息的不同可分为三类：数据总线(收发数据)、地址总线(寻址)和控制总线(收发中断信号)

    > PCIE的地址总线和数据总线是分时复用的, 是串行总线架构. pcie总线发明之前大多是共享总线架构, 需仲裁器决定哪个设备可以使用总线
1. I/O设备
    系统与外部的联系渠道

    每个I/O设备都是通过控制器或适配器与I/O总线相连. 控制器或适配器的区别主要在于封装方式:  控制器是设备本身或主板上的芯片组; 适配器是主板插槽上的扩展卡
1. 内存
    可以看成一个线性的Byte数组
1. CPU
    指令集描述机器代码指令的效果
    处理器的微体系结构描述处理器是如何实现的

DMA(直接存储器存取) : 设备独立地直接读写系统内存，而不需中央处理器（CPU）介入处理.

![存储金字塔](/misc/img/storage_speed.jpg)
![存储器level](/misc/img/storage_level.png)

常见硬件性能参数:
|类别 | 耗时 |
|-|-|
|访问L1 Cache|0.5ns|
|分支预测失败|5ns|
|访问L2 Cache|7ns|
|Mutex 加锁/解锁|100ns|
|内存访问|100ns|
|千兆网络发送1MB数据|10ms|
|从内存顺序读取1MB数据|0.25ms|
|机房内网络来回|0.5ms|
|异地机房之间网络来回|30～100ms|
|SATA磁盘寻道|10ms|
|从SATA磁盘顺序读取1MB数据|20ms|
|固态盘SSD访问延迟|0.1～0.2ms|

## 操作系统
功能:
1. 防止应用直接访问硬件导致损坏
1. 管理系统资源

抽象:
- 指令集是cpu的抽象
- 文件系统是I/O设备的抽象
- 虚拟内存是内存和磁盘i/O设备的抽象
    它为每个进程提供一个假象: 每个进程能独占整个内存. 其地址空间称为虚拟地址空间, 空间的最上面(地址高位处)是内核空间, 所有进程都一样且对用户代码不可见
- 进程是cpu, 内存, I/O设备的抽象
- 虚拟机是操作系统的抽象

OS保持跟踪的进程运行所需的所有状态信息成为上下文, 因此其实现的进程切换执行的机制叫上下文切换.

大端和小端:
- Little-Endian : 低位字节排放在内存的低地址端，高位字节排放在内存的高地址端, 数值描述形式与内存地址增长方向相反. 比如intel cpu, **主流**.

    1. 内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（比如把int的4字节强制转换成short的2字节时，就直接把int数据存储的前两个字节给short就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑）
    1. CPU做数值运算时从内存中依顺序依次从低位到高位取数据进行运算，直到最后刷新最高位的符号位，这样的运算方式会更高效
- Big-Endian : 高位字节排放在内存的低地址端，低位字节排放在内存的高地址端, 数值描述形式与内存地址增长方向一致. 比如Sun的SPARC.

    符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小.

> 其各自的优点就是对方的缺点，正因为两者彼此不分伯仲，因此在多字节存储顺序上始终没有一个统一的标准
> 部分cpu支持双端, 但一旦选定os, 其使用的字节序也就固定了. 比如使用arm的Android, iso都使用小端模式.
> 大小端影响: 1. 不同端机器的网络传输(可依照网络传输标准解决) 2. 汇编代码的阅读
> cpu支持的指令和指令的字节级编码被称为指令集体系结构(ISA).

### [Linux x64虚拟地址布局](https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt)
参考:
- [虚拟内存[00] 虚拟内存地址空间](https://durant35.github.io/2017/11/06/VM0_AddressSpace/)
- [Linux X86_64位虚拟地址空间布局与试验](https://blog.csdn.net/Wu_Roc/article/details/77203480)
- [内存-用户空间](https://jin-yang.github.io/post/kernel-memory-management-from-userspace-view.html)

在x86_64下面，虚拟地址空间最大为16EB, 但其实际只使用了48位, 所以C程序里打印的地址都是只有12位16进制, 48位地址长度也就是对应了256TB的地址空间.

> `gcc -m32 main.c`兼容32/64位, `gcc -m64 main.c`仅支持64位, 即由该程序如何编译决定其支持什么样的机器.

而在Linux下有效的地址区间是从 `0x00000000 00000000 ~ 0x00007FFF FFFFFFFF` 还有 `0xFFFF8000 00000000 ~ 0xFFFFFFFF FFFFFFFF` 两个地址区间, 而每个地址区间都有128TB的地址空间可以使用，所以总共是256TB的可用空间. 地址空间的划分就如下所示:
```text
    ffffffff ffffffff     _____________   
                          |            |   
                          |   内核空间  |   
    ffff8000 00000000     |____________|   
                          |            |   
                          |   未使用    |   
                          |   的空间    |   
                          |            |   
    00007fff ffffffff     |____________|   
                          |            |   
                          |   用户空间  |   
    00000000 00000000     |____________|
```

快速记忆: 内核高高在上.

![64 位系统下进程地址空间布局](/misc/img/space_linux_x64.png)

Memory Mapping Segment : 用于把文件映射进内存用的，如果二进制的执行文件依赖于某个so，就是在这个区域里面将 so 文件映射到了内存中的.

普通进程的视角会觉着整个空间是它独占的，没有其他进程存在, 因为它们是相互隔离的. 但是通过syscall到了内核里面，无论是从哪个进程进来的，看到的都是同一个内核空间，看到的都是同一个进程列表. 虽然内核栈是各用各的，但是如果想知道的话，还是能够知道每个进程的内核栈在哪里的. 所以，如果要访问一些公共的数据结构，需要进行锁保护.

内核的代码访问内核的数据结构，大部分的情况下都是使用虚拟地址的，**虽然内核代码权限很大，但是能够使用的虚拟地址范围也只能在内核空间**，也即内核代码访问内核数据结构.

> 经典内存布局方式的不足(本质是32位地址空间有限): 32经典内存布局下, 进程的栈从地址0xc0000000（3G）向低地址发展，同时内存映射区域(MMR)从0×40000000（1G）向高地址发展, 因此它们合计约有2GB左右的映射空间; 进程堆的起始点大于BSS段的结束点，并向高地址发展，因为0×40000000以上已用作内存映射用，因此堆的大小只有约1G, **空间不足**.
> 栈所用内存相对较小(通常小于100MB, 可通过`ulimit -s`查看栈的默认大小, 默认是`8M`)
> 空间默认布局与经典布局的区别: MMAP 区域的增长方向, 由`vm.legacy_va_layout`控制, 推荐使用默认布局. 默认布局让栈空间的固定，而堆区域和 MMAP 区域公用一个空间，这在很大程度上增长了堆区域的大小, 弥补了经典内存布局方式的不足.
> ASLR，全称为 Address Space Layout Randomization，地址空间布局随机化,由`kernel.randomize_va_space`控制. 它将进程的某些内存空间地址进行随机化来增大入侵者预测目的地址的难度，从而降低进程被成功入侵的风险, 主要防止缓冲区溢出攻击.
> ASLR 不负责代码段以及数据段的随机化工作，由 PIE 机制(在编译时开启) 负责. 但是只有在开启 ASLR 之后，PIE 才会生效.
> 查看可执行程序有没有开pie可通过`readelf -l xxx`查看,对应如下:
    Elf 文件类型为 DYN (共享目标文件) ===> 对应开启了pie
    Elf 文件类型为 EXEC (可执行文件)  ===> 对应未开启pie
>　内核中有两个参数会影响内存的布局：`vm.legacy_va_layout`和`kernel.randomize_va_space`.

一个程序的内存布局，可以通过以下命令查看:
```sh
$ cat /proc/<pid>/maps
$ pmap <pid> -X
```

> [vDSO](http://man7.org/linux/man-pages/man7/vdso.7.html)全称是virtual dynamic shared object，是一种内核将一些本身应该是系统调用的直接映射到用户空间，这样对于一些使用比较频繁的系统调用，直接在用户空间调用可以节省开销.

## 并发/并行
并发是时间段概念; 并行是时刻概念.

实现方式:
1. 线程级并发
    1. 多核
    1. 超线程
1. 指令级并行
1. 单指令, 多数据并行(SIMD)
    多用于多媒体

## 进制
数值 ＝ 该数值各数位的数值 × 基数的若干幂次(即位权):
```
(1010.1)10 = 1×10^3+ 0×10^2+ 1×10^1+ 0×10^0 + 1*10^-1
(1010)2 = l×2^3 + 0×2^2+ l×2^1+0 × 2^0 = (10)10
```

### X进制转二进制
整数部分: 除基取余法, 用基数相除, 然后反序取余数
小数部分: 乘基取整法, 用基数相乘, 然后正序取整数

X进制加减乘除与十进制类似.

### 原/反/补码

负数的反码 = 在其原码的基础上, 符号位不变，其余各个位取反 = 该值的绝对值取反
负数的补码 = 负数的反码 + 1
负数的原码 = 在其补码的基础上, 符号位不变，其余各个位取反 + 1

> [+1] = [00000001]原 = [00000001]反 = [00000001]补
> [-1] = [10000001]原 = [11111110]反 = [11111111]补

### 计算机减法
计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂, 于是人们想出了将符号位也参与运算的方法(通过是否溢出来取舍计算结果的符号位).

为了解决原码做减法的问题, 出现了反码:
```
1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0
```

但是`[0000 0000]原 = +0`也表示`0`, 而补码的出现解决了0的符号以及两个编码的问题:
```
1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原
```

计算机使用加法来实现减法运算的数学原理: 同余
```
两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余
记作 a ≡ b (mod m)
读作 a 与 b 关于模 m 同余
```

假设模长就是m=2^N(N=8,16,32,64,即计算机整数的比特长度):
```
a-b = a+m-b = a + (m-1-b+1) = a + (~b+1)
m - 1 =  2^N -1 => (2^N -1) - b = ~b // 即全是1的序列中扣除b, 正好是~b
```

### 类型
[C数据类型的大小](https://github.com/meilihao/tour_book/blob/master/c/base.md#数据类型)

### 移位
左移不区分逻辑算术 : 移出去的位丢弃，空缺位（vacant bit）用 0 填充

右移:
- 逻辑 : 移走的位填充为0
- 算术(编译器默认) : 移走的位填充与符号位有关，如果为负数，则移走的位填充为1.

符号扩充 : 在保持数值不变的前提下扩充类型长度(int16->int32), 只需要用符号位填充高位即可.

> 移位运算时常用`()`解决优先级问题.

### 计算机小数运算出错误的原因
有一些十进制的小数无法转换成二进制数,转化后只能得到近似值, 比如`0.1`.

避免方法: 先换算成整数, 计算后再转回去

### 浮点(IEEE 754)
参考:
- [解析IEEE 754 标准](https://www.cnblogs.com/HDK2016/p/10506083.html)
- <<x86/x64体系探索及编程#1.2数据类型>>

![浮点描述](/misc/img/floating_point.png)

浮点数 = 符号位（sign bit）* 2^指数偏移值(exponent bias) * `1.fraction`
浮点数存储格式(32/64 bit): 符号位（sign bit, 1）+ exponent(指数, 8/11) + `fraction`(尾数, 23/52)
扩展双精度浮点数格式(80bit): 符号位（sign bit, 1）+ exponent(指数, 15) + `1.fraction`(尾数, 64)

> 指数偏移值(采用Excess系统表现, 长度为8/11/15) : exponent - 偏移量(biased notation, 127/1023/16383) = 阶码(指明了小数点在数据中的位置,即左移/右移多少位), 避免出现1.0*2^-1比1.0*2^1大(因为-1是0xFF>1)
> 尾数格式`1.fraction`(将小数点前的值固定为1的表达式, 称为j-bit,其中小数部分fraction为计算机实际存储的内容, 长度为23/52, 扩展双精度浮点数的j-bit是显示的)
> 指数在尾数前便于可快速的使用exponent(整数)比较来比较浮点数.

精度: float, 23bit; double, 52bit; 扩展双精度浮点数, 64bit. x87 fpu会将数值转为扩展双精度浮点数再进行处理.

ieee754定义的实数编码格式:
1. zero
1. denormal : 不合规格的数, 有时也被称为tiny(极小)数
1. nomal : 合规格的数, 这是一个finite(有限的)取值范围
1. infinite : 无限数, 包括正负无穷大
1. NaN : 不是数值, 包括SNaN和QNaN
