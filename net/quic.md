# quic
- [quic status](https://datatracker.ietf.org/wg/quic/about/)

HTTP 2.0 是基于 TCP 协议的, 而TCP 协议在处理包时是有严格顺序的. 虽然 HTTP 2.0 通
过多个 stream使得逻辑上一个 TCP 连接可并行传输内容, 然而没有关联的数据到了tcp层, 一前一后进行传输时, stream x 的帧没有收到, 但其他 stream 的帧也会因此阻塞.

quic原理:
- 自定义连接机制

    以一个 64 位的随机数作为 ID 来标识, 而不是类似TCP 连接的四元组标识(源 IP、源端口、目的 IP、目的端口), 而且 UDP 是无连接的,所以当 IP 或者端口变化的时候,只要 ID 不变,就不需要重新建立连接.
- 自定义重传机制

    TCP 为了保证可靠性,通过使用序号和应答机制,来解决顺序问题和丢包问题. 发送超时是通过采样往返时间 RTT不断调整的, 但重传时返回相同序号的ack, 此时无法确定ack的对应发送次序, 因此RTT不好计算.

    QUIC 也有个序列号,是递增的. 任何一个序列号的包只发送一次,下次就要加一. 此时RTT 计算相对准确. 此时需要使用offset来确定不同序号的包的内容是否相同: QUIC 也是面向连接的,也就像 TCP 一样,是一个数据流,发送的数据在这个数据流里面有个偏移量 offset,可以通过 offset 查看数据发送到了哪里,这样只要这个 offset 的包没有来,就要重发;如果来了,按照 offset 拼接,还是能够拼成一个流.
- 无阻塞的多路复用

    同一条 QUIC 连接上可以创建多个 stream, 多个 stream 之间没有顺序依赖.

- 自定义流量控制

    TCP 的流量控制是通过滑动窗口协议. TCP 的 ACK 机制是基于序列号的累计应答, 只要前面的没到,后面的到了也不能 ACK,就会导致后面的到了,也有可能超时重传,浪费带宽.
    
    QUIC 的流量控制也是通过 window_update,来告诉对端它可以接受的字节数. 但是 QUIC 的窗口是适应自己的多路复用机制的,不但在一个连接上控制窗口,还在一个连接中的每个 steam 控制窗口.

    QUIC 的 ACK 是基于 offset 的,每个 offset 的包来了,进了缓存,就可以应答,应答后就不会重发,中间的空挡会等待到来或者重发即可,而窗口的起始位置为当前收到的最大 offset,从这个 offset 到当前的 stream 所能容纳的最大缓存,是真正的窗口大小. 显然,这样更加准确.