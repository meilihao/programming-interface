# net
参考:
- [太厉害了，终于有人能把TCP/IP协议讲的明明白白了](http://developer.51cto.com/art/201906/597961.htm)
- [wireshark使用教程及过滤语法总结](https://www.zhoulujun.cn/html/theory/network/2016_1130_7908.html)
- [以太网技术联盟宣布完成 800Gb 以太网规范](https://my.oschina.net/u/4313784/blog/3434387)

![全协议关系图](/misc/img/net/network_protocal_all.png)
![TCP/IP协议关系图](/misc/img/net/tcpip_protocal_r.png)
![protocols](/misc/img/net/protocols.pdf)
[TCP/IP详解 卷1：协议](http://www.52im.net/topic-tcpipvol1.html)

计算机网络就是将多个独立工作的计算机系统通过通信线路相互连接构成的集合, 即其由计算机设备, 网络设备, 传输介质以及支持这些硬件的软件组成.

## 概念
数据包:
- 帧 : 表示数据链路层中数据传输的单位
- 数据包 : IP 和 UDP 等网络层以上的分层中数据传输的单位
- 段 : TCP 数据流中的信息
- 消息 : 应用协议中数据的单位

通信识别:
- mac : 识别同一链路中不同的计算机
- ip : 用来识别 TCP/IP 网络中互连的主机和路由器
- 端口 + protocol:　用来识别同一台计算机中进行通信的不同应用程序

地址类型:
- 单播(unicast) : 代表一台网络接口的地址
- 组播(multicast, 即多播) : 代表一组主机的地址, 有利于实现视频会议等应用, 基于UDP.

    IP地址范围为224.0.0.0～239.255.255.255。多播MAC地址以十六进制值01-00-5E打头，余下的6个十六进制位根据IP多播组地址的最后23位转换得到
- 广播(broadcast) : 代表本地网络上所有主机的地址, 基于UDP.
- 任播(anycast) : 代表一组主机中任意之一的地址

Gateway（网关）在 TCP/IP 的世界里就是路由器的意思.

广播地址（ broadcast address）是一种特殊的地址, 广播地址设为接收方地址时, 会发送到网络中所有的设备上. MAC 地址中的 FF:FF:FF:FF:FF:FF和 IP 地址中的 255.255.255.255 都是广播地址.

相比于广播, 组播(多播)既可以穿透路由器, 也可以实现只给那些必要的组发送数据包.
组播建立: 进程发送 IGMP 包,所在网络的路由器就能收到这个包,知道有个机器上有个进程在监听这个组播地址. 当路由器收到这个组播地址的时候就会将包转发给这台机器,这样就实现了跨路由器的组播.

DHCP是自动设置 IP 地址、统一管理 IP 地址分配的机制.

NAT用于在本地网络中使用私有地址，在连接互联网时转而使用公网 IP 地址的技术, 是为正在面临地址枯竭的 IPv4 而开发的技术. 不过，在 IPv6 中为了提高网络安全也在使用 NAT.

IP 隧道是在网络层的首部后面追加网络层首部/IPv6首部的通信方法.

vpn(virtual private network)是在公用网络上建立虚拟私有网的技术.

点对点: 通信双方直接相连, 中间没有其他任何设备.

端到端: 两个终端系统的连接, 中间经过至少一个路由器.

### 分层结构
![OSI(Open System Interconnect, 开放系统互连参考模型) vs TCP/IP model](/misc/img/net/OSI-vs-TCP-IP-model.jpg)
![OSI, TCP/IP, protocol](/misc/img/net/tcp_ip_layers.png)
![各层数据封装,像俄罗斯套娃](/misc/img/net/package_layers.png)
![各层数据封装2](/misc/img/net/packet_layer2.png)
![各层硬件](/misc/img/net/tcp_ip_hardware.png)

> 分层(是计算机领域的常用技巧)是为了隔离, 过分层划分职能, 解问题, 与层之间约定接口, 蔽实现细节. 每个分层在发送时都会对所发送的数据附加一个包首部, 本层协议解读提供的必要信息, 发送的目标地址以及协议相关信息, 而从上一层收到的内容被认为是本层的数据.
> ISO七层是理论, TCP/IP四层是实践
> 物理层与数据链路层区别: 物理层是物理链路; 数据链路层是基于物理层的逻辑链路. 有点类似与http2中的connection与stream的关系.
> 数据链路层的主要作用是**在互连同一种数据链路**的节点之间进行包传递
> 网络层可以跨越不同的数据链路, 使是在不同的数据链路上也能实现两端节点之间的数据包传输
> 网络传输是以包(统称)为单位的,二层叫帧,网络层叫包,传输层叫段.

七层model各层作用:
7. 给用户应用提供接口
6. 进行数据格式的转换, 比如加解密, 压缩等
5. 会话管理
4. 从端对端透明地传送报文段, 常用就是tcp, udp
3. 分组传输和路由选择

    路由技术主要是指路由选择算法、因特网的路由选择协议.

    路由选择算法可以分为静态路由选择算法和动态路由选择算法.

    因特网的路由选择协议划分为两大类：内部网关协议（IGP,具体的协议有RIP和OSPF等）和外部网关协议（EGP,使用最多的是BGP）.

    动态路由协议可以按照工作范围分为IGP以及EGP。IGP工作在同一个AS内，主要用来发现和计算路由，为AS内提供路由信息的交换；而EGP工作在AS与AS之间，在AS间提供无环路的路由信息交换.
2. 在链路上无错地传输帧, 常见设备网卡, 网桥, 二层交换机
1. 将数据以比特流的形式在物理介质上传输, 常见设备网线, 光纤

常说的L1, L2(网络设备驱动负责), L3(ipv4/ipv6等), L4(tcp, udp等), L7(https)分别对应OSI7中的物理层, 数据链路层, 网络层, 传输层, 应用层.

计算机网络分类:
- 按照网络覆盖的地理范围
    1. 局域网(LAN, Local Area Network), 比如常见的无线局域网(WLAN)
    1. 城域网(MAN, Metropolitan Area Network)
    1. 广域网(WAN, Wide Area Network), 比如Internet
- 按照网络管理模式
    1. 对等网(PTP)
    1. C/S网
- 按照传输方式
    1. 点对点传输, 比如modem使用的PPOE
    1. 广播式传输

## 网络架构
### 传统网络架构
传统三层网络架构即分级的互联网络模型（Hierarchical Inter-networking Model）

这种架构的优点是，可以把复杂的网络设计问题抽象为几个层面来解决，每个层面又聚焦于某些特定的功能。这样就能把复杂而庞大的网络问题拆解成比较好解决的子问题.

三层网络架构设计主要包括核心层、汇聚层、接入层这三个层:
1. 核心层

    交换层的核心交换机为进出数据中心的数据包提供高速转发的功能，为多个汇聚层提供连通性，同时也为整个网络提供灵活的 L3 路由网络
2. 汇聚层

    汇聚交换机与接入交换机相连，提供防火墙、SSL 卸载、入侵检测、网络分析等其他服务。
3. 接入层

    接入交换机通常位于机架的顶部，因此它们也被称为 ToR 交换机，并且它们与服务器物理连接。


核心层和汇聚层这种骨干网络需要承担的流量是蛮大的，流量大意味着对交换性能、效率有更高的要求.

经典的 IP 网络是逐跳转发数据的。转发数据时，每台路由器都要根据包头的目的地址查询路由表，以获得下一跳的出口, 这个过程显然是繁琐低效的. 另外，转发路径也不够灵活，为了加以改善，在第二层之上、第三层之下引入一个 2.5 层的技术方案，即多协议标签交换（MPLS）技术.

MPLS（Multiprotocol Label Switching）利用标签进行数据转发，而不是向传统路由决策那样每次数据包进行解包，大大减少了路由决策的时间。当分组进入MPLS网络时，为其分配固定长度的短标记，并将标记与分组封装在一起，在整个转发过程中，交换节点仅根据标记进行转发

MPLS 通过 LDP 标签分发协议. 这相当于把快递标签“贴在”了快递盒子上了，后续只需要读取标签，就能知道这个数据要转发到哪里去了。这样就避免了传统路由网络中每路过一个经手人（每一跳），都要把快递盒子打开看一看的额外开销.

MPLS 技术虽然也解决了问题，但也加重了耦合，并且存在资源利用率低、复杂度高、价格昂贵等缺点. 所以后来 SR（Segment Routing）技术又应运而生，而随着 IPv6 的演进，用 SRv6 替代 MPLS 技术也是大势所趋.

解决传统三层网络架构带来的挑战的答案其实在贝尔实验室的 Charles Clos 博士在 1953 年的《无阻塞交换网络研究》之中. 论文中提到的核心思想是：用多个小规模、低成本的单元，构建复杂、大规模的网络.

借鉴 Fattree 和 CLOS 模型的思想，目前业界衍生出了叶脊（Spine-Leaf）网络架构。目前通过 FaceBook、Google 等公司大量实践的事实已经证明，Spine-Leaf 网络架构可以提供高带宽、低延迟、非阻塞、可扩展的服务器到服务器连接. 这种新一代架构在工程实践中的代表之一，则正是 [Google 的 B4 网络](https://time.geekbang.org/column/article/404013).

### 模拟
SDN 分为控制面和数据面，对应到开源实现中 ONOS 就是控制面的具体实现，而 Mininet 对应的就是数据面实现。Mininet 是由斯坦福大学基于 Linux 容器架构开发的一个云原生虚拟化网络仿真工具.

> ONOS 是一个开源的、分布式的网络操作系统控制平台，可以满足运营商对网络业务的电信级需求

使用 ONOS+Mininet 可以快速创建一个包含主机、交换机、SDN 控制器以及链路的虚拟网络，并且 Mininet 创建的交换机也是支持上文讲到的 OpenFlow 协议的，这也使得它具备了高度的灵活性. [使用这个工具，可以在本地轻松搭建一个 SDN 开发、调试环境](https://time.geekbang.org/column/article/404013).

## 物理层
双绞”(双绞线)是为了抑制噪声.

### 交换机
~~集线器只具有原样转发功能(广播模式), 在同一时刻只能有两个端口传送数据, 他端口只能等待, **已被交换机取代**.~~
交换机是通过 MAC 头部中的接收方 MAC 地址来判断转发目标的, 而路由器则是根据 IP 头部中的 IP 地址来判断的.

交换机是最重要的信息交换网络设备，主要功能包括:
- 学习设备MAC地址
- 二层转发
- 三层转发
- ACL
- QoS
- 消除回路

随着SDN和NFV的发展，现在已经有越来越多的功能都放到了虚拟交换机上来。最常见的虚拟交换机是Open vSwitch

#### l2 交换机
![二层交换原理](/misc/img/net/l2_switch.png)
交换机(二层)是**基于以太网设计的, 工作在数据链路层**, 是将以太网连接形成更大的以太网.

交换机端口的 **MAC 模块不具有 MAC 地址**, 它会根据帧中的目的MAC查 CAM表(MAC与交换机端口的映射表), 后将信号发送到相应的端口.

> CAM表构建(即交换机学习): 通过帧的源MAC和广播数据帧后接收方应答的数据帧中的MAC构建的, 其表项有过期时间.
> VLAN(虚拟局域网)中, 交换机的CAM表为(MAC地址, VLAN ID, 交换机端口), 为了提高广播查找效率, 它还会建立VLAN配置表(VLAN ID,该VLAN包含的所有交换机端口)

#### l3交换机
l3交换机 = 二层交换机 + 路由功能, 可以划分子网.

#### 白牌交换机
随着SDN的兴起，白牌交换机（WhiteBox Switch）逐渐兴起。白牌交换机是指不贴标签的交换机，并且像PC一样，硬件和软件分离。用户从厂商拿到硬件后，可以安装自定义的软件（如OpenSwitch、OPX、Sonic等）。比如，用户可以选择

硬件使用Broadcom、Cavium、盛科等
而软件使用Cumulus、BigSwitch、Pica8、Snaproute、OPX、OpenSwitch等
白牌交换机的优势

成本低，白牌交换机的总体成本低于品牌设备
更大的灵活性，软件可以自定义，方便针对特定需求和场景做定制开发
避免厂商绑定
当然了，并不是所有的软件都适用于所有的硬件，这还有待软硬件厂商进一步协作提升开放性

### 路由器
路由器是**基于 IP 设计的, 作在网络层**, 是数据传输过程中的指路人, 是能够连接不同的广域网形成更大的广域网.

网关(Gateway)又称网间连接器/**协议转换器**. 网关在网络层以上实现网络互连, 是最复杂的网络互连设备, 用于两个高层协议不同的网络互连, 充当翻译功能.

路由器会忽略主机号, 匹配网络号(使用最长匹配).
路由表中子网掩码为`0.0.0.0`的记录表示`默认路由`.
地址转换NAT的基本原理是在转发网络包时对 IP 头部中的 IP 地址和端口号 进行改写.

MAC 地址是一个局域网内才有效的地址. 因而,MAC 地址只要过网关,就必定会改变. 不改变 IP 地址的网关称为转发网关;改变 IP 地址的网关称为NAT 网关.

为什么路由器发出的数据包包含mac:
ip是网络层使用的, mac是链路层使用的, ip包最终还是要通过物理链接进行交互的即通过mac地址.

数据包传输过程中MAC地址以及IP地址的变化情况:
![](/misc/img/net/b6c31475059204.png)

### frame
![frame](/misc/img/net/frame.png)
每个包的前面都有报头和起始帧分界符（SFD）, 头用来测定时机, FD 用来确定帧的起始位置.

> 制定以太网标准的组织 IEEE 出于历史原因使用了“帧”而不是“包”, 此在以太网术语中都是说“帧”,可以认为两者等价.

线路收发控制,即控制在往链路上发数据的时候,谁先发、谁后发的问题,防止发生混乱. 方法是多路访问协议:
- 信道划分协议
- 随机接入协议, 以太网在使用.
- 轮流协议
### mac(全局唯一)
作用:
1. 寻址(mac地址)
1. 解决网络中多个用户争抢公用传输通道

寻址需要依靠arp. mac帧分三种:
1. 单播 : 目的mac地址是一个单播mac地址的帧
1. 广播帧 : 目的mac地址是一个广播mac地址(全是`1`)的帧
1. 多播帧 : 目的mac地址是一个多播mac地址的帧

> 为了避免每次都用 ARP 请求,机器本地也会进行 ARP 缓存(缓存有过期时间)
> ARP请求是广播，ARP被动应答是单播, ARP主动扩散是广播.

为什么有了mac,还要有ip, 不能直接用mac通信:
一个网络包要从一个地方传到另一个地方,除了要有确定的地址(mac),还需要有定位功能(ip), 简单的比喻就是mac酒店里有很多房间(ip). 且MAC 地址的通信范围比较小,局限在一个子网里面, 因为mac无法路由.

## 协议栈
协议栈即网络控制软件, 它是根据套接字中记录的控制信息来工作的.
协议栈发送数据的时机选择:
1. 每个网络包能容纳的数据长度, 协议栈会根据MTU来进行判断. 长度优先,可能产生延迟
2. 协议栈的内部计时器的时间. 时间优先, 可能降低网络效率

实际如何判断发送时机是由协议栈的实现决定的. 而且仅靠协议栈来判断发送的时机可能会带来一些问题, 因此协议栈也给应用程序保留了控制发送时机的余地.

> 当在1500B的以太网标准下增加MTU的大小, 此时的数据包就是巨帧(Jumbo Frames), 千兆网络上, 性能提升明显, 但现实的大部分网络设备不支持该功能.
> bonding(将多块网卡虚拟成为一块网卡，使其具有相同的ip地址，来实现提升主机的网络吞吐量或者是提高可用性等作用)驱动可实现负载均衡和容错.

## TCP/IP 协议
TCP/IP协议族是一组协议的集合, 用来实现互联网上主机之间的相互通信.

包收发操作: 应用数据 <-> tcp模块 <-> ip模块 <-> 网络硬件.

IP 模块会添加**IP 头部和 MAC 头部这两种头部**. IP 头部中包含 IP 协议规定的、 根据 IP 地址将包发往目的地所需的控制信息； MAC 头部包含通过以太网的局域网将包传输至最近的路由器所需的控制信息: 使用的协议类型, 目标和源mac地址.

IP 模块也不关心 TCP 的操作阶段, 对于包的乱序和丢失也一概不知.
总之, IP 的职责就是将委托的东西打包送到对方手里, 或者是将对方送来的包接收下来, 仅此而已.

TCP 模块在收发数据时会分为好几个阶段, 并为各个阶段设计了实现相应功能的网络包, 但 IP 的包收发操作都是相同的, 并不会因包本身而有所区别,即它将TCP 头部和数据块看作一整块二进制数据, 在执行收发操作时并不关心其中的内容.

IP 头部格式见<<网络是怎样连接的>>表2.2

> IP 头部包含目的地的ip地址, 由tcp模块提供(实际最初来源是应用程序), IP模块不负责判断目的地ip地址的可用性.
> MAC 头部很容易被误解为是由网卡来处理的, 实际上它是由 TCP/IP 软件来负责的.


## ip协议
IP 数据包结构(不包括选项字段的 IP 头部长度为 20B, 如果使用了ip选项, ipv4报头最长可达60B, 仅了解, **重点关注ipv6**):
![](/misc/img/net/ip_package.png)
各字段的含义：
- 4 位版本号，指协议版本号，值为4代表 IPv4
- 4 位首部长度，每一个计量单位是 32bit（4 byte），指的是包括选项字段在内的 IP 首部长度，由于是 4bit，所以 **IP 首部最长只能是 60 字节（15 * 4）**
- 8 位服务类型（TOS），包括 3bit 优先权字段（现在已经不用了），4bit TOS字段， 1bit 备用位. 4bit TOS位分别代表：最小时延、最大吞吐量、最高可靠性和最小费用，只能设置其中 1bit，如果所有 4bit 均为0，那么就表示是一般服务.
- 16 位 IP 数据包长度，计量单位 byte，包括首部和数据部分能表示的最大长度为 65535，且这个字段是必须的，**当 IP 数据包小于 46 字节时在以太网帧中数据将会被填充到 46 字节**，这时候如果没有这个字段我们接收到帧后便不能得到正确的 IP 数据包
- 16 位标识字段，是数据包的唯一标识，通常主机每发送一个数据包就会 +1 ，**在分片时会被复制到每一个分片中**
- 3 位标志字段和 13 位(片)偏移字段，用于数据包分片和重组. 3 位标志字段，0bit 保留；1bit 为 DF ：0表示可以分片，1表示不能分片；2bit 为 MF:0表示最后一个分片，1表示还有分片
- 13位(片)偏移字段，指示了这个分片在所属数据包中的位置，分片偏移以 8byte 做为计量单位，第一个分片偏移为 0.
- 8 位生存时间TTL(Time to Live, 生存时间),设置了数据包可以经过的最多路由器数量,即包的有效期
- 8 位协议字段，前面已经提过了，标识上层协议的字段, 比如0x6表示tcp
- 16 位首部校验和(CRC)，**根据 IP 首部计算的检验和码，它不对首部后面的数据进行计算**, 采用的是 16bit 二进制反码求和
- 32 位源 IP 地址和32位目标 IP 地址
- 选项字段，可变长的数据信息，具体选项定义请查询相关文档. **尤其注意的是，选项必须以 32bit 作为计量单位，不满 32bit 需要填充 0**.

> 分片重组: 根据IP头部的ID和分片偏移量, 在所有分片全部收到之后, 就可以将它们还原成原始的包的操作.

IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层, 其有三大作用模块, 们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包.

IP 地址是网际层唯一标识通信端的id, 其由网络号和主机号两部分标识组成.

#### `ip addr`解读
```sh
$ ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: wlp2s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether a0:c5:89:49:d6:d5 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.18/24 brd 192.168.1.255 scope global noprefixroute dynamic wlp2s0
       valid_lft 250245sec preferred_lft 250245sec
    inet6 fe80::eb43:c06d:27e0:4df5/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
```
解读:
- `enp0s25` : 可预测的网络接口(Predictable Network Interface).  接口名称取决于硬件的物理位置: 接口类型,en是网线接口,wl是无线; p 是以太网卡的总线编号; s 是插槽编号. 所以该名称会透露其正在使用的硬件的信息
- scope
    - global, 可以与其他机器通信
    - host, 仅本机内部相互通信使用
    - site, 只站点本地地址通信 (IPv6)
    - link, 仅在该设备上有效
- net_device flags,网络设备的状态标识: `<BROADCAST,MULTICAST,UP,LOWER_UP>`
    - LOOPBACK，仅是自己这个host使用
    - BROADCAST, 这个网卡有广播地址,可以发送广播包
    - MULTICAST, 网卡可以发送多播包
    - UP, 网络接口已启用, 可以接收网络请求
    - LOWER_UP, 设备已连接至网络.
- MTU: 最大传输单元, 是二层 MAC 层的概念.
- qdisc : 全称是queueing discipline(排队规则), 内核如果需要通过某个网络接口发送数据包,它都需要按照为这个接口配置的 qdisc(排队规则)把数据包加入队列, 具体算法有:
    - noqueue : 不会进行排队
    - noop : 该interface处于blackhole模式，所有的请求都会在到达的时候被立即丢弃
    - pfifo/bfifo : 它不对进入的数据包做任何的处理,数据包采用先入先出的方式通过队列. 使用先进先出算法的排队规则都有一个缓存，这是为了在数据包（或数据）无法及时发送出去时，暂时保存这些数据包（或数据）. 当使用基于数据包的 pfifo 时，缓存大小的单位就是数据包个数；当使用基于字节的 bfifo 时，缓存大小的单位就是字节.
    - pfifo_fast(默认) : pfifo_fast 源于 FIFO，它在 FIFO 的基础之上增加了三条具有不同优先级的通道(band)，每一条通道都是一个先入先出队列. 最高优先级的数据包（如交互型应用）应该通过具有最高优先级的0号通道. 类似地，1号通道优先级低于0号通道而又高于2号通道，2号通道的优先级最低. 系统会首先发送高优先级通道中的数据包，当高优先级通道中没有数据包后，才会发送更低优先级通道中的数据包. 数据包会按照服务类型(Type of Service,TOS, IP 头里面的一个字段代表了当前包的高优先级)被分配到这三个band里面的.
- state UP : 网络接口已启用
- group default : 接口组
- qlen 1000 : 传输队列长度
- link/ether a0:c5:89:49:d6:d5 : 接口的 MAC（硬件）地址
- brd ff:ff:ff:ff:ff:ff : 广播地址
- inet 192.168.1.18/24 : IPv4 地址
- brd 192.168.1.255 : 广播地址
- noprefixroute : 不为该地址的网络前缀分配路由，当移除该地址的时候也不去搜索对应的路由
- flags是内核设置的值, 具体有:
    - secondary : 为输出的数据包选择默认源地址时, 内核不使用这个地址
    - dynamic : 该地址是通过无状态的自动配置分配的(stateless autoconfiguration), 有时间限制. preferred_lft期满后，地址就会变成 deprecated状态；valiid_lft期满后，地址将失效.
    - deprecated : 地址虽然有效，但是不能用于创建新的连接
    - tentative : 由于重复地址监测还没有完成或者监测失败，这个地址无法使用
- valid_lft 250245sec : IPv4 地址的有效使用期限
- preferred_lft 250245sec : : IPv4 地址的首选生存期
- inet6 fe80::eb43:c06d:27e0:4df5/64 : IPv6 地址
- valid_lft forever : IPv6 地址的有效使用期限
- preferred_lft forever : IPv6 地址的首选生存期

> **iproute2 已取代 net-tools**.

#### ip地址配置
```
$ sudo ip addr add 10.0.0.1/24 dev eth1
$ sudo ip link set up eth1
```

将本机ip设为其他网段ip, 向原网段的其他机器发包的结果是目标机器没收到数据包, 原因:
Linux 首先会判断目标地址和本机是否同一网段(通过CIDR和子网掩码, 即匹配网络号):
- 是,它才会通过`arp缓存/发送 ARP 请求`获取 MAC 地址然后将包发送到网络上, 目标机器接收
- 不是, 尝试将包发送到网关:
    - 有网关, 则由网关路由. 即使目标机器与路由器共用物理链路, 对于它来说, 也会因为原IP不是它的网段ip而丢弃该数据包.
    - 没有, 压根就发不出去.

> linux配置网关地址的前提: 网关要和当前的网络至少一个网卡是同一个网段的.

#### DHCP 的工作方式
数据包均以目的 IP 地址是 255.255.255.255, 目标mac是ff;ff;ff;ff;ff;ff的广播包形式通信.

1. DHCP Discover: 新机器使用 IP 地址 0.0.0.0 发送了一个广播包. 广播包封装在UDP 里面,UDP 封装在 BOOTP 里面, 其实 DHCP 是 BOOTP 的增强版.
1. DHCP Offer: DHCP Server发送一个广播包应答, 应答包里有预分配的ip地址. 新机器再发送广播应答, 表明选中的地址, 目的是告诉所有 DHCP Server 它将接受哪一台服务器提供的 IP 地址, 因为网络里可能有多个 DHCP Server(它会选择其中一个 DHCP Offer,一般是最先到达的那个).
1. DHCP ACK: DHCP Server 接收到客户机的 DHCP request 之后,会广播返回给客户机一个 DHCP ACK 消息包, 表明已经接受客户机的选择,并将这个IP 地址的合法租用信息和其他的配置信息都放入该广播包,发给客户机.

> 续租是在租期过去 50%的时候进行.

预启动执行环境(PXE, Pre-boot Execution Environment)工作过程:
![](/misc/img/net/1533816393401474.png)

1. 启动 PXE 客户端. 第一步是通过 DHCP 协议向 DHCP Server请求地址. DHCP Server 便租给它一个 IP 地址,同时也给它 PXE 服务器的地址、启动文件 `pxelinux.0`.
1. PXE 客户端知道要去 PXE 服务器下载这个文件后就可以初始化机器, 下载过程通过TFTP 协议.
1. PXE 客户端收到这个文件后,就开始执行这个文件. 这个文件会指示 PXE 客户端,向 TFTP 服务
器请求计算机的配置信息 pxelinux.cfg(里面会说内核在哪里、initramfs 在哪里等信息).
1. PXE 客户端会根据pxelinux.cfg请求所需文件. 最后,启动 Linux 内核. 一旦启动了操作系统,以后就啥都好办了.

### ICMP和 ARP
IP 中包括 ICMP(Internet Control Message Protocol) 协议和 ARP 协议.

ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息; ARP 用于根据 IP 地址查询相应的以太网 MAC 地址; RARP是逆地址解析协议, 用是完成硬件地址到IP地址的映射.

在同一局域网下, 计算机之间通信需要知道对方的硬件地址, 可以通过ARP协议进行查找. 为了提高查找和数据转发的效率，每台主机或交换机会维护一个ARP表(ARP转发表)，用于记录主机硬件地址与转发接口之间的映射.

二层交换机之间通信，每经过一台设备，都会更改数据帧的源、目mac地址，即将从ARP表中查找到的硬件地址存入目的地址，当前转发硬件接口地址作为源MAC地址. 但是三层路由器之间通信时，无论经过什么设备，都不会改变源、目的IP地址字段的值.

> icmp在ipv4中仅用于报告错误和提示信息; 在ipv6中, 可被用于其他目的, 如邻居发现(ND, neighbour discovery), 组播侦听器发现(MLD, Multicast Listener Discovery)等.

> traceroute是利用ICMP检查链路情况的工具.
>
> Traceroute 判断能否到达目的主机的方法: 会发送一份 UDP 数据报给目的主机,但它会选择一个不可能的值作为 UDP 端口号(大于 30000). 当该数据报到达时,将使目的主机的 UDP 模块
产生一份“端口不可达”错误 ICMP 报文;如果数据报没有到达,则可能是超时.
>
> traceroute 还有一个作用是故意设置不分片从而确定路径的 MTU, 因为出错则会收到CMP 网络差错包,类型为"需要进行分片但设置了不分片位".
>
> ICMP 差错报文的例子:终点不可达为 3,源抑制为 4,超时为 11,重定向为 5
>
> ARP 只适用于 IPv4. IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息.
>
> IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4. 在 IPv4 时期, 即使没有 ICMP仍然可以实现 IP 通信. 然而,  IPv6 中, ICMP 的作用被扩大, 如果没有 ICMPv6, IPv6 就无法进行正常通信.

[广播风暴](https://wiki.mbalib.com/wiki/%E7%BD%91%E7%BB%9C%E9%A3%8E%E6%9A%B4): 由于网络上过多的广播数据帧,几乎占满了网络整个带宽而导致网络速度极慢的一种故障 ,原因有网卡或其它网络接口损坏、环路、人为干扰破坏、黑客工具、病毒传播.

**集线器的工作模式易引起广播风暴, 而交换机因为有学习mac的功能而能避免(但其在网络环路的情况下也会出现广播风暴).**

为了提高网络的可靠性，交换网络通常会使用冗余链路，这会带来环路的风险。而STP和Trill就是为了解决环路问题而生的.

破除网络环路: STP 协议(Spanning Tree Protocol, 生成树的算法), 或VLAN.

STP（Spanning Tree Protocol）的基本原理是在交换机之间传输BPDU（Bridge Protocol Data Unit）报文，并使用生成树来确定网络拓扑.

STP最大的问题是二层链路利用率不足，且收敛慢，不适合大型数据中心。IETF又提出了Trill技术来克服STP的种种缺陷。Trill（TRansparent Interconnection of Lots of Links）的核心思想是将成熟的三层路由的控制算法引入到二层交换中，将原先的L2报文加一个新的封装(隧道封装)，转换到新的地址空间上进行转发。而新的地址有与IP类似的路由属性，具备大规模组网、最短路径转发、等价多路径、快速收敛、易扩展等诸多优势，从而规避STP/MSTP等技术的缺陷，实现健壮的大规模二层组网。支持TRILL技术的以太网交换机被称为RBridge.

### 路由
ref:
- [路由路由策略](https://bbs.huaweicloud.com/blogs/367050)
- [静态路由和策略路由的配置实践](https://www.amoyw.com/2019/04/12/static-routes/)

路由是指路由器从一个接口上收到数据包，根据数据包的目的地址进行定向并转发到另一个接口的过程. 它是决定数据包如何传输的关键过程.

路由器通过一定的规则，将收到的数据报以最优的路径转发出去，这个过程就是路由选路.

大概路由选路规则为：
1. 路由条目不同时（子网号和掩码不完全相同）

    路由器会一条一条匹配路由表，匹配成功则从该条路由表所指示的接口转发，如果所有路由条目都匹配失败，则丢弃该报文。 如果匹配成功多个路由条目， 此时优先采用掩码最长匹配的条目进行转发。例如条目为/24和/26的两个路由条目，选择/26的进行转发。


2. 路由条目相同时（子网号和掩码均相同）
    
    依次比较 管理距离和代价。

3. 若都相同则按照这些条目执行等价负载均衡转发

路由表是路由器转发数据包的关键.

路由器中路由表中的路由记录可以有动态路由和静态路由两种:
- 静态路由是由**人工配置**的, 不需要CPU处理时间同样也不占用线路带宽
- 动态路由是**根据路由协议自动计算生成**的, 可以自动寻找最优路径，邻居路由也可以通过学习来获得路由表，但是动态路由占用线路带宽和CPU处理时间

    由路由器与其他路由器相互交换信息时自动刷新(由路由协议构建)

动态路由要解决的两个问题:
1. AS内部路由
1. AS间路由

动态路由本质是图问题求解, 求最短路径常用的有两种方法:
1. Bellman-Ford -> 距离矢量路由算法

    问题:
        1. 加入网络快, 故障反应慢即收敛慢
        1. 每次发送的时候,要发送整个全局路由表
    被采用:
        1. RIP
        1. BGP
1. Dijkstra 算法 -> 链路状态路由算法

    只广播更新的或改变的网络拓扑,使得更新信息更小,节省了带宽和 CPU 利用率. 而且一旦一个路由器挂了,它的邻居都会广播这个消息,可以使得坏消息迅速收敛.

    被采用:
        1. OSPFv4

> 路由器中存在两种类型和层次的表，一个是路由表(routing-table)，另一个是转发表(forwording-table). 转发表是由路由表映射过来的，策略路由直接作用于转发表，路由策略直接作用于路由表.

> 在/etc/sysconfig/network配置GATEWAY=x.x.x.x表示缺省路由

发包总结来说，分为以下几步：
1. 发送方主机检查目的IP是否在本地网段，如果是就直接交付
2. 如果目的IP与自己不是同一网段，查找主机自己的路由表，将数据包发送给网关路由器
3. 路由器查找自己的路由表，将目的IP依次与路由表中的子网掩码相与，看是否有匹配的路由条目；如果匹配不上的一律交由默认路由进行转发。如果既匹配不上又没有设置默认路由，则将该数据丢弃
4. 如果能找到匹配的路由信息，则通过ARP协议，寻找下一跳路由器的硬件地址，将数据包转发给下一跳路由器

当使用CIDR（无分类编址）时，路由表中存储的信息是【网络前缀，下一跳】，这就可能出现同一个目的IP可能与多个网络前缀相匹配, 此时采用最长前缀匹配(longest-prefix matching). 网络前缀越长，其地址块就越小，因而路由就越具体(more specific) , 因此最长前缀匹配又称为最长匹配或最佳匹配.

#### 默认路由
默认路由是静态路由中的一种，是由人工配置的，表示当一个路由转发请求在路由表中匹配不到路由规则时，被默认执行的路由策略. **默认路由，也称为缺省路由或默认网关**. 

默认路由的 Destination 是 default(0.0.0.0).

#### 主机路由
路由表中指向单个 IP 地址或主机名的路由记录，其route的Flags 字段为 H即Genmask不是网段

#### 网络路由
主机可以到达的网络. 与`主机路由`的区别在于, 其route的Genmask是网段.

#### 静态路由（Static Routing）
静态路由是一种手动配置的路由方式, 管理员需要手动指定目标网络的下一跳路径来定义路由. 静态路由适用于小型网络或需要固定路由路径的场景.

静态路由的路由表(表项至少包括: 目的网络,出口设备,下一跳网关)配置:
1. 根据目的 IP 地址来配置路由(传统)
1. 策略路由(新): 依据用户自定义的策略进行报文转发, 支持多个路由表，支持按数据报属性（源地址、目的地址、协议、端口、数据包大小、内容等）选择不同路由表, 甚至在一条路由规则中,也可以走多条路径(比如多个服务提供商的情况)

路由表查询: `ip route`.

#### 策略路由(Policy Routing)
策略路由是一种根据指定的策略或条件选择数据包传输路径的路由技术, 即会根据优先级依次遍历，直到决策出下一跳.

它根据一些规则来决定数据包应该怎么走, 比如根据源IP地址/网段、目标IP地址/网段、服务类型、网络负载、报文大小、 端口、 数据包标签(MARK)等因素来选择最佳的路由路径.

策略路由有以下优点：
1. 基于源的路由可以使不同的用户选择不同的ISP
1. 灵活的操纵报文
1. 服务质量
1. 节省费用
1. 负载均衡

策略路由的特点:
1. 策略路由比所有路由的级别都高，其中包括直连路由（路由的优先级：策略路由 > 默认路由 > 动态路由）
1. 策略路由是转发层面的行为，操作的对象是数据包，匹配的是数据流，具体是指数据包中的各个字段:源IP、目标IP、协议、源端口、目标端口、802.1p优先级 、VLANID 源/目的MAC地址、IP优先级 、DSCP的优先级 、IP的协议类型字段
1. 为QoS服务. 使用route-map及策略路由可以根据数据包的特征修改其相关QoS项，进行为QoS服务.
1. 负载平衡. 使用策略路由可以设置数据包的行为，比如下一跳、下一接口等，这样在存在多条链路的情况下，可以根据数据包的应用不同而使用不同的链路，进而提供高效的负载平衡能力.

    策略路由影响的只是本地的行为，所以可能会引起“不对称路由”形式的流量。比如一个单位有两条上行链路A与B，该单位想把所有HTTP流量分担到A链路，FTP流量分担到Ｂ链路，这是没有问题的，但在其上行设备上，无法保证下行的HTTP流量分担到Ａ链路，FTP流量分担到Ｂ链路.

1. 策略路由一般针对的是接口入(in)方向的数据包，但也可在启用相关配置的情况下对本地所发出的数据包也进行策略路由.

常见的应用模式有以下几种:
1. 上网负载均衡:对于多条ISP线路，网络管理员可以在不同的路径之间根据带宽分配内网上网流量，实现负载平衡
2. 基于源地址选路:例如一个网络通过两条速度不同的线路接入BT4互联网，管理员可以指定内网中一些特定的用户使用快速线路，而普通用户使用慢速线路
3. 根据服务级别选路:对于不同服务要求(如:传送速率、吞吐量以及可靠性等)的数据，根据网络的状况进行不同的路由。如:指定语音与视频等应用走带宽大的线路，数据应用走带宽小的线路
4. VPN线路备份:安全网关的几条接入线路都可以作为VPN接入的端点，移动用户可以从任何一个接入点通过VPN隧道安全接入内网，从而实现vpn接入线路的相互备份

**本地策略路由仅对本机下发的报文进行处理，对转发的报文不起作用**.

#### 路由策略（Route Policy）
路由策略是一组定义在路由器上的规则，**改变的是路由表的内容**, 用于决定数据包如何**转发**. 它主要实现了路由过滤和路由属性设置等功能，它通过改变路由属性（包括可达性）来改变网络流量所经过的路径. 它基于数据包的属性（比如源IP地址、目标IP地址、端口号等）来匹配规则，并根据预设的策略来选择下一跳路径。路由策略常用于流量控制、负载均衡和安全策略等方面.

路由协议在发布、接收和引入路由信息时，根据实际组网需求实施一些策略，以便对路由信息进行过滤和改变路由信息的属性，如：
1. 控制路由的接收和发布

    只发布和接收必要、合法的路由信息，以控制路由表的容量，提高网络的安全性
1. 控制路由的引入

    在一种路由协议引入其它路由协议发现的路由信息丰富自己的路由信息时，只引入一部分满足条件的路由信息。（过滤别人发过来的路由信息，选择性的添加到自己的路由表中）
1. 设置特定路由的属性

    修改通过路由策略过滤的路由的属性，满足自身需要

路由策略的实现分为两个步骤：
1. 定义规则：首先要定义将要实施路由策略的路由信息的特征，即定义一组匹配规则，可以以路由信息中的不同属性作为匹配依据进行设置，如目的地址、AS号等
2. 应用规则：根据设置的匹配规则，再将它们应用于路由的发布、接收和引入等过程中

**路由策略实际上是形成路由表的另一种方式，根据一些策略改变路由属性来改变生成的路由表项**.

策略路由与路由策略不同：
1. 路由策略是路由发现规则，策略路由是数据包转发规则
1. 策略路由的操作对象是数据包，在路由表已经产生的情况下，不按照路由表进行转发，而是根据需要，依照某种策略改变数据包转发路径。
1. 路由策略的操作对象是路由信息。路由策略主要实现了路由过滤和路由属性设置等功能，它通过改变路由属性（包括可达性）来改变网络流量所经过的路径。
1. 策略路由的查找优先级比路由策略高，当路由器接收到数据包并进行转发时，会优先根据策略路由的规则进行匹配，如果能匹配上，则根据策略路由进行转发，否则按照路由表中的路由条目来进行转发。
1.  其中策略路由不改变路由表中的任何内容，它可以通过预先设置的规则来影响数据报文的转发。

以下图直观的来说，路由策略只是更改了生成的路由表，不涉及转发；在转发时，有限考虑策略路由，在策略路由不满足的情况下，再去匹配下方普通的路由表项或者被路由策略该过的表项.

![](https://img-blog.csdnimg.cn/20200310160217427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vbm9sb2d1ZXpqcA==,size_16,color_FFFFFF,t_70)

#### 路由协议
ref:
- [【重识云原生】第四章云网络4.3.7.3节——BGP协议实现原理](https://www.jianshu.com/p/d98abc96770f)

路由协议有自己的路由算法，能够自动适应网络拓扑的变化，适用于具有一定规模的网络拓扑。其缺点是配置比较复杂，对系统的要求高于静态路由，并占用一定的网络资源.

对路由协议的分类可采用以下不同标准
1. 根据作用范围

    - IGP(Interior Gateway Protocol，内部网关协议)：在一个自治系统内部运行，常见的 IGP协议包括 RIP、OSPF 和 IS-IS
    - EGP(Exterior Gateway Protocol，外部网关协议)：运行于不同自治系统之间，BGP 是目前最常用的 EGP
2. 根据使用算法

    - 距离矢量(Distance-Vector)协议：包括 RIP 和 BGP。其中，BGP 也被称为路径矢量协议(Path-Vector)
    - 链路状态(Link-State)协议：包括 OSPF 和 IS-IS
3. 根据目的地址类型

    - 单播路由协议：包括 RIP、OSPF、BGP 和 IS-IS 等
    - 组播路由协议：包括 PIM-SM、PIM-DM 等

4. 根据IP协议版本

    - IPv4 路由协议：包括 RIP、OSPF、BGP 和 IS-IS 等
    - IPv6 路由协议：包括 RIPng、OSPFv3、IPv6 BGP 和 IPv6 IS-IS 等

具体路由协议:
- ~~RIP : 适用于小型同类网络的一个自治系统(AS)内的路由消息传递, 已废弃~~
- OSPFv4 : 基于链路状态，每个路由器向其同一管理域的所有其它路由器发送链路状态广播信息，并将自制域划分为区，并根据区的位置执行区内路由选择和区间路由选择. 它是内部网关协议, 用于单个AS的路由器之间. 广泛应用在数据中心中的协议

    有时候 OSPF 可以发现多个最短的路径,可以在这多个路径中进行负载均衡,这常常被称为等价路由
- IS-IS : 链路状态路由协议，和OSPF相同，IS-IS也使用了“区域”的概念，同样也维护着一份链路状态数据库，通过最短生成树算法（SPF）计算出最佳路径
- BGPv4 : 外部网关协议，用于与其它自治域的BGP交换网络可达信息（通过TCP确保可靠性）. 用于大型网络和isp运营商

    路径矢量路由协议(path-vector protocol). 它是距离矢量路由协议的升级版. 在 BGP 里面,除了下一跳 hop 之外,还包括了自治系统 AS 的路径,从而可以避免坏消息传的慢的问题.

    BGP 又分为两类,eBGP 和 iBGP. 自治系统间,边界路由器之间使用 eBGP 广播路由; 内部网络也可通过iBGP访问其他的自治系统, 它是由边界路由器将 BGP 学习到的路由导入到内部网络的,使得内部的路由器能够找到到达外网目的地的最好的边界路由器.

    **BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议.**

    两个AS中利用BGP交换信息的路由器也被称为边界网关（Border Gateway）或边界路由器（Border Router）. 由于可能与不同的AS相连，在一个AS内部可能存在多个运行BGP的边界路由器.

    在路由协议中，只有BGP使用TCP作为传输层协议.

AS（Autonomous System，自治系统/路由选择域），是指由同一技术机构管理，使用同一选路策略的一些路由器的集合.

AS内部使用IGP来计算和发现路由，同一个AS内部的路由器之间是相互信任的，因此IGP的路由计算和信息泛洪完全处于开放状态，人工干预很少.

不同的AS之间，使用EGP来进行通信。BGP作为EGP中的一种协议，用于在AS之间进行路由控制和优先.

一个自治系统将会分配一个全局的唯一的16位号码，有时我们把这个号码叫做自治系统号（ASN）, 由IANA分配.

自治系统AS(Autonomous System), 自治系统分几种类型:
- Stub AS : 对外只有一个连接. 这类 AS 不会传输其他 AS 的包, 例如,个人或者小公司的网络.
- Multihomed AS : 可能有多个连接连到其他的 AS,但是大多拒绝帮其他的 AS 传输包, 例如一些大公司的网络
- Transit AS : 有多个连接连到其他的 AS,并且可以帮助其他的 AS 传输包, 例如主干网

IGP工作在同一个AS内，主要用来发现和计算路由，为AS内提供路由信息的交换；而EGP工作在AS与AS之间，在AS间提供无环路的路由信息交换.

### IP 分包与组包
- 每种数据链路的最大传输单元（MTU）都不尽相同, 为每个不同类型的数据链路的使用目的不同. 使用目的不同, 承载的 MTU 也就不同.
- 任何一台主机都有必要对 IP 分片进行相应的处理. 分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理
- 经过分片之后的 IP 数据报在被重组的时候, 是由目标主机进行. **路由器虽然可做分片但不会进行重组**.

> MTU(Maximum Transmission Unit) 表示一个网络包的最大长度, 在以太网中一般是 1500 字节. MTU 是**包含头部的总长度**, 因此需要从MTU 减去头部的长度, 然后得到的长度就是一个网络包中所能容纳的最大数据长度, 这一长度叫作 MSS(Maximum Segment Size). 所以当 IP 数据包长度大于 MTU 时会被拆成多个帧传输, 为"IP分片".

#### 路径 MTU 发现
- 分片机制也有它的不足, 如路由器的处理负荷加重之类. 因此, **只要条件允许,是不希望由路由器进行 IP 数据包的分片处理的**.
- 为了应对分片机制的不足, "路径 MTU"(PMTU)发现技术应运而生. 路径 MTU 指的是数据包不分片情况下动态发现传输路径上允许的最大的MTU,即路径上所有链路MTU的最小值. 进行路径 MTU 发现, 可以避免在中途的路由器上进行分片处理, 可以在 TCP 中发送更大的包.

PMTU依赖ICMP报文, 且只支持 TCP，对其他协议比如 UDP 无效

### ipv4
实际的 IPv4 地址是一串32 比特的数字, 按照 8 比特（ 1 字节）为一组分成 4 组, 常用圆点隔开的十进制表示, 但仅凭这一串数字我们无法区分哪部分是网络号, 哪部分是主机号, 因此才有了子网掩码,即子网掩码表示网络号与主机号之间的边界.

网络号(网段) = ip & 子网掩码

网络号全为`0`是保留地址.

主机号:
1. 主机号部分全部为 0 代表**整个子网**而不是子网中的某台设备
1. 主机号部分全部为 1 代表向子网上所有设备发送包, 即广播

IP 地址分为四个级别, 别为A类、B类、C类、D类, 它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分:
- A类IP 地址是首位以 `0` 开头的地址(`0`+7b网络号+24b主机号, 掩码`255.0.0.0`)
    十进制: `1.0.0.1~127.255.255.254`, 网络容量: 126,主机容量: 2^24-2 = 16777214
- B类IP 地址是前两位 `10` 的地址(`10`+14b网络号+16b主机号, 掩码`255.255.0.0`)
    十进制: `128.0.0.1~191.255.255.254`, 网络容量: 64*256,主机容量: 2^16-2 = 65534
- C类IP 地址是前三位为 `110` 的地址(`110`+21b网络号+8b主机号, 掩码`255.255.255.0`)
    十进制: `192.0.0.1~223.255.255.254`, 网络容量: 32*256*256,主机容量: 2^8-2 = 254
- D类IP 地址是前四位为 `1110` 的地址(`1110`+28b多播地址)
    十进制: `224.0.0.0~239.255.255.255`, 每个多播地址代表一个多播组, 由IGMP控制.
- E类IP 地址是前五位为 `11110` 的地址, 保留地址, 忽略

局域网ip段:
- A类局域网专用网段：10.0.0.1~10.255.255.254
- B类局域网专用网段：172.16.0.1~172.31.255.254
- C类局域网专用网段：192.168.0.1~192.168.255.254

> 广播地址区分: 直接广播(directed broadcast, 包含一个有效的网络号和一个全`1`的主机号)和有限广播(local broadcast, 也叫本地广播), 区别在于是否会路由器是否会转发广播. 通用的广播地址`255.255.255.255`为有限广播仅在子网内传播, 典型的例子就是DHCP. `直接广播`的例子是arp广播, 其可通过路由器配置来决定是否开启. 其因为会靠路由器转发广播而需注意不要造成广播风暴.

链路本地地址（Link-local address），又称链接本地地址是计算机网络中一类特殊的地址， 它仅供于在网段，或广播域中的主机相互通信使用. 这类主机通常不需要外部互联网服务，仅有主机间相互通讯的需求. IPv4链路本地地址定义在169.254.0.0/16地址块。 IPv6定义在fe80::/10地址块.

#### 无类型域间选路(CIDR)
产生原因: C类地址空间太小,不够用; C类以上地址空间太大, 浪费.

做法: 通过子网掩码区分网络号和主机号(原先是靠前缀区分).

## 传输层中的 TCP 和 UDP
ref:
- [TCP](https://tonydeng.github.io/sdn-handbook/basic/tcp.html)

TCP/IP 中有两个具有代表性的传输层协议, 别是 TCP 和 UDP.

- TCP 是面向连接的、可靠的流协议.

    流就是指不间断的数据结构(即无数据边界), 应用程序采用 TCP 发送消息时, 虽然可以保证发送的顺序, 但还是犹如没有任何间隔的数据流发送给接收端.

    TCP 为提供可靠的传输，实行了`顺序控制`, `重发控制(丢包)`. 此外还具备`流量控制`、`拥塞控制`、提供网络利用率等众多功能.

    因此掌握 TCP 协议需重点应该关注以下几个问题:
    - 顺序问题
    - 丢包问题
    - 连接维护
    - 流量控制
    - 拥塞控制

- UDP 是无连接的, 不具有可靠性的数据报协议

    细节处理它会交给上层的应用去完成. 虽然可以确保发送消息的大小(有边界), 不能保证消息一定会到达, 必要时应用需要自行进行重发处理

TCP与UDP的区别
1. TCP面向连接（如打电话要先拨号建立连接）即是有状态的;UDP是无连接的, 发送数据之前不需要建立连接
1. TCP提供可靠全双功的通信服务. UDP是半双功, 能单向传播. 
1. TCP提供可靠传输: 无差错, 不丢失, 不重复, 按序到达;UDP则是不可靠传输, 最大努力交付, 不保证: 不丢失, 按顺序到达.
1. TCP面向字节流, 实际上是TCP把数据看成一连串无结构的字节流,即没有数据边界, 可能出现粘包;UDP是面向报文的．
1. TCP具有拥塞控制和流量控制; UDP没有拥塞控制和流量控制, 此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用, IP电话, 时视频会议等）
1. 每一条TCP连接只能是点到点的; UDP比较灵活, UDP支持一对一，一对多，多对一和多对多的交互通信
1. TCP首部开销最小20字节,最大60字节;UDP的首部开销小, 有8个字节.

面向连接: 为了在客户端和服务端维护连接,而建立一定的数据结构来维护双方交互的状态,
用这样的数据结构来保证所谓的面向连接的特性.

TCP/UDP应用场景:
- tcp(通讯质量有要求) : 效率要求相对低, **有可靠传输要求**的场景. 因为传输中需要对数据确认、重发、排序等操作, 比之下效率没有UDP高.
    举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录. NSQ底层通讯就采用TCP. 对应的协议有http,imap,smtp,ssh,telnet等
- udp :  对**资源, 高速传输和实时性有较高要求**的通信或广/组播通信, 且对准确性要求相对低的场景

    1. 需要资源少, 网络情况好的内网/丢包不敏感的应用, 比如DHCP, DNS
    1. 不需要一对一, 建立连接,而是可以广/组播的应用, 比如DHCP
    1. 需要处理速度快,时延低,可以容忍少数丢包

    举几个例子：quic, 实时游戏 , IoT(物联网通信协议 Thread), 流媒体的协议, 移动通信领域(4G里的GTP-U)

    流媒体的协议: QQ聊天、在线视频、网络语音电话（即时通讯, 度要求高, 是出现偶尔断续不是太大问题, 且此处完全不可以使用重发机制）

拥塞: 通信网络负荷超出其吞吐能力, 导致该网络性能下降的情况.

拥塞控制是确保网络能承载用户的通信量, 是全局性问题, 与主机, 路由器, 交换机等网络传输性能相关的所有组成相关.
流量控制与通信双方的通信量相关, 是局部问题.

tcp/udp存在伪首部原因:
在UDP/TCP伪首部中，包含32位源IP地址，32位目的IP地址，8位填充0，8位协议，16位TCP/UDP长度.

伪首部是一个虚拟的数据结构，其中的信息是从数据报所在IP包头中提取的，既不向下传送也不向上递交，而仅仅是为计算校验和. 这样的校验和，既校验了TCP&UDP用户数据的源端口号和目的端口号以及TCP&UDP用户数据报的数据部分，又检验了IP数据报的源IP地址和目的地址.

> tcp/udp的校验和是将首部和数据部分一起都检验.

## udp
UDP 数据段结构:
![](/misc/img/net/776043-20170901104150312-2127518303.png)

有边界理解:
1. 发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层, **既不拆分，也不合并，而是保留这些报文的边界**，因此，应用程序需要选择合适的报文大小
1. 即使服务端的这个函数的缓冲区足够大，客户端分几次发送过来，服务端就必须按几次接收

## tcp
TCP 数据段结构(不计算选项字段，TCP 首部的长度为 20B):
![](/misc/img/net/tcp_segment.png)
各字段的含义如下：
- 16 位源端口与目标端口号，用于标识发送端应用程序和接收端应用程序
- 32 位序号，无符号数，用来标识从 TCP 发送端向 TCP 接收端发送的数据字节流，为**解决乱序**问题. 它表示在这个报文段中的的第一个数据字节的顺序，简单的可理解为对发送的数据（这个数据不一定是指数据字段的数据，比如建立连接时 SYN 字段设置为 1，也会消耗一个计数）按 byte 进行循环计数. 起始序号是随着时间变化的.
- 32 位确认序号，无符号数，用于表示期望收到的下一个序号，**ACK=1 时有效**, **解决不丢包**的问题.
- 4 位置首部长度，计量单位为 32bit，同 IP 首部长度字段.
- flags:
    - URG，紧急指针有效
    - ACK，确认序号已设置
    - PSH，接收方应该尽快将这个报文段交给应用层
    - RST，重建连接
    - SYN，同步序号用来发起一个连接
    - FIN，发送端完成发送，用来结束一个连接
- 16 位窗口字段，这个与 TCP 的滑动窗口流量控制以及拥塞控制有关. 由**接收方**提供.
- 16 位校验和，覆盖了整个的 TCP 报文段，包括首部和数据. 与 UDP 数据报一样，TCP 数据报段在计算校验和时也包括一个 12 字节长的伪首部.
- 16 位紧急指针，这是一个正向偏移值，和序号字段中的值相加表示紧急数据最后一个字节的序号
- 选项字段，最常见的可选字段是最长报文大小，又称为 MSS (Maximum Segment Size). 每个连接方通常都在通信的**第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项**. 它指明本端所能接收的最大长度的报文段.


![tcp握手/挥手/状态](/misc/img/net/tcp_status.jpg)
![tcp状态转换](/misc/img/net/tcp_status_change.jpg)
![TCP状态流程图](/misc/img/net/Tcp_state_diagram_fixed_new.svg)

实验环境:
```bash
$ nc -l -p 9000
$ nc localhost 9000
```
使用wireshare或tcpdump截包.

> tcp三次握手时发起方即为client; 四次分手时没有client, server之分.
> ACK起应答作用, SYN起同步作用
> 在Linux上报文段的最大生存时间通常是30秒, 2倍的MSL就是一分钟
> TCP规定, SYN报文段（SYN=1的报文段）不能携带数据(为了避免攻击), 需要消耗掉一个序号
> TCP规定, ACK报文段可以携带数据, 是如果不携带数据则不消耗序号
> TCP规定, FIN报文段即使不携带数据, 要消耗一个序号
> 确认应答（ACK）: 在 TCP 中, 发送端的数据到达接收端时, 收端会返回的已收到消息的通知
> ACK = SEQ + 传递的字节数 + 1. ack的增量为传递的字节数, 用以明确接收端接收到的字节数.

### 三次握手
![TCP连接的建立](/misc/img/net/tcp_connect_handle.png)

1. 第一次握手：建立连接. 
    client发送连接请求报文段, 将SYN位置为1, Sequence Number(随机)为x；然后, client进入SYN_SEND状态, 等待服务器的确认
2. 第二次握手：服务器端收到数据包后由标志位SYN=1知道client请求建立连接. 
    服务器收到client的SYN报文段, 需要对这个SYN报文段进行确认即设置Acknowledgment Number为x+1(Sequence Number+1)；同时, 自己还要发送SYN请求信息即将SYN位置为1, Sequence Number(随机)为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中, 一并发送给client, 此时服务器进入SYN_RECV状态；
3. 第三次握手：验证server ack并建立连接. 
    client收到服务器的SYN+ACK报文段, 验证server发回的ACK有效性, 通过后将Acknowledgment Number设置为y+1, 向服务器发送ACK报文段, 这个报文段发送完毕以后, client和server端都进入ESTABLISHED状态, 这样就完成TCP三次握手了. 
完成了三次握手, client和server就可以开始传送数据.

> tcp每个package均带有win(窗口大小, 即本端要告诉对端当前可以接受的数据量, 其不包括tcp头部大小).
> TCP Windows Update: 发送者传输数据比接收者读取快, 因此接收者需告诉发送者应以多大的速度发送数据, 从而使得数据传输与接受恢复正常.

为什么是三次: 防止了服务器端的一直等待而浪费资源. 假设握手是两次, 客户端发送连接请求因某些原因滞留, 客户端在等待超时后重新发送,服务端收到并响应,最后关闭连接通信(比如短请求像http请求之类的). 之后那个失效的连接请求抵达了服务端, 于只有两次握手, 务端会认为是新请求, 收到请求就会进入ESTABLISHED状态, 待发送数据或主动发送数据. 但此时的客户端早已进入CLOSED状态, 务端将会一直等待下去, 样浪费服务端连接资源.

由三次握手可以看出, 服务器收到 SYN 数据报文段后将为连接分配资源, 果服务器没有收到 ACK 报文段就会造成半开连接, 费服务器资源. SYN 洪水攻击就是利用 TCP 的这个缺陷, 过向服务器发送海量的 SYN 报文段而耗尽服务器资源. 详见[TCP洪水攻击（SYN Flood）的诊断和处理](https://cloud.tencent.com/developer/article/1115567)

为什么3次握手总结:
1. 能力确认

    1. client第一次发和第一次收, 确认client收发ok
    1. server第一次发和第二次收, 确认server收发ok
1. 超时控制

### 四次分手
![TCP连接的释放](/misc/img/net/tcp_close_handle.png)

1. 第一次分手：主机1（假定主机1为发起方）, 设置Sequence Number和Acknowledgment Number, 向主机2发送一个FIN报文段(表示没有数据要发送)；此时, 主机1进入FIN_WAIT_1状态
2. 第二次分手：主机2收到了主机1发送的FIN报文段, 再向主机1回一个ACK报文段, Acknowledgment Number为Sequence Number加1, 之后进入CLOSE_WAIT状态；主机1收到ACK进入FIN_WAIT_2状态(tcp_fin_timeout可处理FIN_WAIT_2超时)；主机2告诉主机1, 同意你的关闭请求
3. 第三次分手：主机2向主机1发送FIN报文段, 表示这边数据也发完并准备好关闭连接了, 同时主机2进入LAST_ACK状态；
4. 第四次分手：主机1收到主机2发送的FIN报文段, 向主机2发送ACK报文段, 然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后, 就关闭连接；此时, 主机1等待2MSL(Double Maximun Segment Life, 两倍的报文段的最大生存时间)后依然没有收到回复, 则证明主机2端已正常关闭, 那么, 主机1也可以关闭连接了.
至此, TCP的四次分手就这么愉快的完成了

> 上方介绍的是一方主动关闭, 一方被动关闭的情况, 际中还会出现双方同时发送FIN+ACK进行主动关闭的情况.
> ![tcp同时关闭](/misc/img/net/tcp_close_two.jpg)

为什么建立连接协议是三次握手, 而关闭连接却是四次握手呢? **tcp是全双工, 双方都要相互确认终止发送数据(即tcp的半关闭特性half-close)**,主机2收到FIN时可能还需要发送一些数据给对方, 这也是主机2的FIN和其响应主机1的FIN的ACK不能同时发送的原因.

三次握手过程中可以携带数据吗? 第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的. 假如第一次握手就可以放数据的话，会让服务器更加容易受到攻击了. 而对于第三次的话，此时客户端已经处于 established 状态，它认为连接已经建立，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据.

为什么要有一个 TIME_WAIT 状态？为什么不能直接到达 CLOSED 状态？
1. 可靠地实现TCP全双工连接的终止
假设没有 TIME_WAIT 这种状态. 现实中, 网络环境不是理想的. 在数据包传输的过程中, 难免会有一些延时、丢包的情况发生. 如果在主机1最后一个ACK报文段发出去之后, 于某种原因, 没有到达主机2, 这样, 主机2在超时后, 就会向主机1重新发一个 FIN 报文段, 请求重传. 由于在主机1端, 连接实际上已经断开, 就找不到与重发的FIN对应的连接. 那么在主机1收到这个报文段后, 会向主机2发送一个 RST 报文(RST表示复位, 用来异常地关闭连接). 而主机2收到该报文段后, 会认为是错误的, 它所期望收到的是ACK报文.

2. 保证让迟来的报文段有足够的时间被处理
同样在不理想的网络环境中, 有些包会在网络中有所延迟. 假如没有 TIME_WAIT 这种状态, 在关闭连接后并且建立新的连接后, 可能会收到该数据包. 由于序号不同, 接收方会要求对方重传数据包, 这样, 连接就会混乱出错. 而 TIME_WAIT 状态的时间, 一般是 2MSL 时间且端口没有释放. 这样, 前一个连接的报文段有足够的时间被识别或者丢弃, 也就不会出现这个问题.

为什么A(主机1)要先进入TIME-WAIT状态, 等待2MSL时间后才进入CLOSED状态？ 为了保证B(主机2)能收到A的确认应答.  若A发完确认应答后直接进入CLOSED状态, 那么如果该应答丢失, B等待超时后就会重新发送连接释放请求, 但此时A已经关闭了, 不会作出任何响应, 因此B永远无法正常关闭.

> 半关闭 : 当TCP链接中A向B发送 FIN 请求关闭，另一端B回应ACK之后，并没有立即发送 FIN 给A,A方处于半连接状态（半开关），此时A可以接收B发送的数据，但是A已经不能再向B发送数据.

> 半连接 : 发生在TCP三次握手中如果A向B发起链接，B也按照正常情况响应了，但是A不进行三次握手，这就是半连接. 半连接攻击（SYN攻击）：半连接会造成B分配的内存资源就一直这么耗着，直到资源耗尽. 服务器发送完SYN-ACK包，如果未收到client的确认包，服务器进行重传(1s，2s，4s，8s......)，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除.

> 半连接队列 : 服务器第一次收到客户端的 SYN 之后，就会处于SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列.

> 全连接队列 : 已经完成三次握手，建立起连接的就会放在全连接队列中. 如果队列满了就有可能会出现丢包现象.

> 半打开 : 如果一方关闭或者异常关闭（断电，断网等），而另一方并不知情，这样的链接称之为半打开, 处于半打开的连接，如果双方不进行数据通信，是发现不了问题的.解决方法是**心跳机制**.

### 可靠性
网络出现错误时, tcp协议栈会负责重传; 因此网卡、路由器、应用程序都没有错误补偿机制, 一旦检测到错误就直接丢弃相应的包. TCP 会在尝试几次重传无效之后强制结束通信, 并向应用程序报错.

TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输.

网络的错误检测和补偿机制:
1. 返回 ACK 号的等待时间（这个等待时间叫超时时间）.tcp会根据网络包平均往返时间调整 ACK 号等待时间.
2. 使用窗口有效管理 ACK 号. TCP 采用滑动窗口方式来管理数据发送和 ACK 号的操作. 所谓滑动窗口, 就是在发送一个包之后, 不等待 ACK 号返回, 而是直接发送后续的一系列包. 窗口大小一般和接收方的缓冲区大小一致.

通信结束之后,套接字并不会立即被删除, 而是会等待一段时间(通常是几分钟)之后再被删除,等待这段时间是为了防止误操作, 具体时长与包重传的操作方式有关.

#### 通过序列号/确认应答/超时重发/选择性确认(SACK)的机制提高可靠性(即是否收到了网络包)
1. 如果有确认应答, 表明数据已经成功到达对端; 反之, 数据丢失的可能性很大
1. 在一定时间内没有等待到确认应答, 发送端就可以认为数据已经丢失, 进行重发. 由此, 即使产生了丢包, 依然能够保证数据能够到达对端, 实现可靠传输. 
1. 未收到确认应答并不意味着数据一定丢失. 也有可能是数据对方已经收到, 是返回的确认应答在途中丢失. 这种情况也会导致发送端误以为数据没有到达目的地而重发数据. 
1. 此外, 有可能因为一些其他原因导致确认应答延迟到达, 源主机重发数据以后才到达的情况也屡见不鲜. 此时, 主机只要按照机制重发数据即可. 
1. 对于目标主机来说, 重复收到相同的数据是不可取的. 为了对上层应用提供可靠的传输, 目标主机必须放弃重复的数据包. 因为此我们引入了序列号. 
1. 序列号是按照顺序给发送的数据包都标上号码的编号. 接收端查询接收数据 TCP 首部中的序列号和数据的长度, 自己下一步应该接收的序列号作为确认应答返送回去. 通过序列号和确认应答号, 接收方 能够识别是否已经接收数据, 能够判断是否需要接收, 从而实现可靠传输

选择性确认(SACK): TCP确认机制中，处理非连续TCP片段的机制.

![序列号和确认应答](/misc/img/net/sequence_ack.jpg)

#### 重发超时的确定即自适应重传算法(Adaptive Retransmission Algorithm)
1. 重发超时是指在重发数据之前, 等待确认应答到来的那个特定时间间隔. 如果超过这个时间仍未收到确认应答, 发送端将进行数据重发. 最理想的是, 取到一个最小时间, 能保证"确认应答一定能在这个时间段内返回. 
1. TCP 要求不论处在何种网络环境下都要提供高性能通信, 且无论网络拥堵情况发生何种变化, 必须保持这一特性. 为此, 在每次发包时都会计算往返时间RTT及其偏差. 将这个往返时间和偏差时间相加, 重发超时的时间就是比这个总和要稍大一点的值.
1. 在 BSD 的 Unix 以及 Windows 系统中, 都以0.5秒为单位进行控制, 因此重发超时都是0.5秒的整数倍. 不过, 最初其重发超时的默认值一般设置为6秒左右.
1. 数据被重发之后若还是收不到确认应答, 会进行再次发送. 此时, 等待确认应答的时间将会以2倍、4倍的指数函数延长. 
1. 此外, 数据也不会被无限、反复地重发. 达到一定重发次数之后, 如果仍没有任何确认应答返回, 就会判断为网络或对端主机发生了异常, 强制关闭连接, 并且通知应用通信异常强行终止.

#### 以段为单位发送数据
1. 在建立 TCP 连接的同时, 可以确定发送数据包的单位, 它们也可以称其为"最大消息长度"(MSS). 最理想的情况是, 最大消息长度正好是 IP 中不会被分片处理的最大数据长度.
1. TCP 在传送大量数据时, 会以 MSS 的大小将数据进行分割发送. 重发时也是以 MSS 为单位.
1. MSS 在三次握手的时候, 在两端主机之间被计算得出. 两端的主机在发出建立连接的请求时, 在 TCP 首部中写入 MSS 选项, 告诉对方自己的接口能够适应的 MSS 的大小. 然后会在两者之间选择一个较小的值投入使用

#### 利用窗口控制提高速度
TCP 以1个段为单位，每发送一个段进行一次确认应答的处理. 这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低.

为解决这个问题，TCP 引入了窗口这个概念. 确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短. 即发送端主机在发送了一个段以后不必要一直等待确认应答，而是继续发送.

![窗口控制](/misc/img/net/tcp_window.jpg)

> 窗口大小就是指无需等待确认应答而可以继续发送数据的最大值, 即**还未被确认的数据**. 上图中窗口大小为4个段. 这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能.
> 接收方收到不连续序号时会先缓存数据到`接收窗口`待完整后提交给应用, 即仅将`接收窗口`中有效的连续的部分提交给应用.

![滑动窗口控制](/misc/img/net/tcp_window_move.jpg)

发送端窗口:
![](/misc/img/net/iwAsj.png)
接收端窗口:
![](/misc/img/net/VYsJH.png)

- 上图中的窗口内的数据即便没有收到确认应答也可以被发送出去. 不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传. 为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答.
- 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据. 当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除.
- 收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置. 这样可以顺序地将多个段同时发送提高通信性能. 这种机制也别称为滑动窗口控制.

窗口控制中的重发控制在使用窗口控制中， 出现丢包一般分为两种情况
1. 部分确认应答丢失
    ![部分确认应答丢失](/misc/img/net/tcp_window_ack_lost.jpg)
    因为接收端只对连续接收的数据段进行确认. 发送方收到`6001`即可认为1~6000都以接收即累计确认或者累计应答(cumulative acknowledgment), 可忽略丢失的`1001`和`3001`
1. 某个报文段丢失的情况
接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答. 如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回. 而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发. 这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制.
![高速重发控制](/misc/img/net/tcp_window_resend_fast.jpg)

> 拥塞窗口cwnd和滑动窗口rwnd共同控制发送的速度: LastByteSent - LastByteAcked <= min {cwnd, rwnd}

### 流控
参考:
- [TCP/IP，你必知必会的十个问题](https://www.tuicool.com/articles/3MZRFrb)

顺序问题、丢包问题、流量控制都是通过滑动窗口来解决.

### 拥塞控制
TCP 的拥塞控制主要来避免包丢失和超时重传, 通过拥塞窗口来解决.

慢启动: 发送数据时慢慢提速，避免堵塞网络.

> 拥塞的一种表现形式是丢包.

tcp中最复杂的功能, 通过tcp连接双方商定的协议来减少数据的发送而实现的, 比如知名的[bbr](https://juejin.im/entry/5b8e5308e51d45589b26be26).

## DoS(Denial of Service)攻击
使用某种方式使得目标无法继续提供服务. 通过僵尸网络对服务器发起的攻击称为DDoS(Distributed Denial of Service)攻击.

## 内核配置项
参考:
- [Linux TCP队列相关参数的总结](https://www.cnblogs.com/276815076/p/5587097.html)
- [Linux TCP/IP 协议栈调优](https://colobu.com/2014/09/18/linux-tcpip-tuning/)
- [sdn-handbook](https://tonydeng.github.io/sdn-handbook/)

```
// buffer
net.ipv4.tcp_mem : 确定TCP栈应该如何使用内存, 单位都是page. 第一个值是内存使用的下限；第二个值是内存压力模式开始对缓冲区使用应用压力的上限；第三个值是内存使用的上限, 在这个层次上可以将报文丢弃，从而减少对内存的使用. 对于较大的BDP可以增大这些值.
net.ipv4.tcp_wmem : 为自动调优定义每个 socket 使用的内存。第一个值是为 socket 的发送缓冲区分配的最少字节数。第二个值是默认值（该值会被 wmem_default 覆盖），缓冲区在系统负载不重的情况下可以增长到这个值。第三个值是发送缓冲区空间的最大字节数（该值会被 wmem_max 覆盖）
net.ipv4.tcp_rmem : 与 tcp_wmem 类似，不过它表示的是为自动调优所使用的接收缓冲区的值
et.core.rmem_default ：内核socket接收缓存区的默认的大小, 对于更大的 BDP 来说，这个大小也应该更大
net.core.wmem_default ：内核socket发送缓存区的默认的大小, 对于更大的 BDP 来说，这个大小也应该更大
net.core.rmem_max ：内核socket接收缓存区的最大的大小, 对于更大的 BDP 来说，这个大小也应该更大
net.core.wmem_max ：内核socket发送缓存区的最大的大小, 对于更大的 BDP 来说，这个大小也应该更大
net.core.optmem_max : 每个套接字所允许的最大缓冲区的大小

// BDP(bandwidth delay product, 带宽延迟乘积), 表示在传输过程中驻留在链路上的数据总量. 它提供了一种简单的方法来计算理论上最优的 TCP socket 缓冲区大小(即>=bdp)
// BDP = Bandwith(bytes/sec, 带宽) * Delay (sec, 延迟, 通过ping获得)
// socket 缓冲区的大小确定了通告 TCP 窗口的大小，但是 TCP 还在通告窗口内维护了一个拥塞窗口. 因此，由于这个拥塞窗口的存在，给定的 socket 可能永远都不会利用最大的通告窗口
net.ipv4.tcp_window_scaling : 启用RFC 1323定义的window scaling，要支持超过64KB(默认)的TCP窗口，必须启用该值（1表示启用），TCP窗口最大至1GB，TCP连接双方都启用时才生效

net.core.netdev_max_backlog ：当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包，这个参数表示该队列的最大值

net.ipv4.tcp_fin_timeout : TCP保持在FIN_WAIT2状态的时间，超时后直接处于CLOSED，所以降低tcp_fin_timeout有助于减少TIME_WAIT数量. 注意：虽然shutdown(SHUD_WR)也会处于FIN_WAIT2状态，但超时并不起作用
net.ipv4.tcp_keepalive_time : TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效
net.ipv4.tcp_max_syn_backlog : 对于还未获得对方确认的连接请求，可保存在队列中的最大数目.
net.ipv4.tcp_timestamps : TCP时间戳（会在TCP包头增加12个字节），以一种比重发超时更精确的方法（参考RFC 1323）来启用对RTT 的计算，为实现更好的性能应该启用这个选项
net.ipv4.tcp_sack : 启用有选择的应答（1表示启用），通过有选择地应答乱序接收到的报文来提高性能，让发送者只发送丢失的报文段，（对于广域网通信来说）这个选项应该启用，但是会增加对CPU的占用
net.ipv4.tcp_fack : 启用转发应答（Forward Acknowledgment），这可以进行有选择应答（SACK）从而减少拥塞情况的发生；这个选项也应该启用
```


## 扩展阅读
### quic/sctp(stream control transmission protocol)和数据包拥塞控制协议(DCCP, Datagram Congestion Control Protocol)
参考:
- [http3为什么不基于UDP使用SCTP](https://http3-explained.haxx.se/zh/why-quic/why-tcpudp)

sctp和dccp兼具tcp和udp的特点. sctp已与LTE(Long Term Evolution)结合使用, 而dccp还未在大型网络中测试.

> 若要了解更多SCTP与QUIC的差异，请参阅[A Comparison between SCTP and QUIC](https://http3-explained.haxx.se/zh/why-quic/why-tcpudp).

### tcp/ip配置项
ipv4的配置在`/proc/sys/net/ipv4`里, 永久性修改时应保持到`/etc/sysctl.conf`里,两者的映射关系举例:`net.ipv4.ip_forward`=>`/proc/sys/net/ipv4/ip_forward`

### tcp/ip
- [网络相关（tcp握手重传,http长短链接,Header分类）](http://liuxiang.github.io/2017/07/05/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%EF%BC%88tcp%E6%8F%A1%E6%89%8B%E9%87%8D%E4%BC%A0,http%E9%95%BF%E7%9F%AD%E9%93%BE%E6%8E%A5,Header%E5%88%86%E7%B1%BB%EF%BC%89/)

### socket
- [Unix网络编程(Unix Network Programming)](http://dirlt.com/unp.html)
- [epoll 的本质是什么？](https://my.oschina.net/editorial-story/blog/3052308)

### 路由
- ~~[VMware中三种网络连接的区别](http://www.cnblogs.com/rainman/archive/2013/05/06/3063925.html)~~
- [路由追踪程序Traceroute分析与科普](http://www.tuicool.com/articles/AfqemqY)
- [*基于 Linux 内核新特性的网关设计实践](https://linux.cn/article-10672-1.html)

### 协议
- [*协议森林](http://www.cnblogs.com/vamei/archive/2012/12/05/2802811.html)

## FAQ
### 输入 ping IP 后敲回车,发包前会发生什么
首先根据目的IP和路由表决定走哪个网卡,再根据网卡的子网掩码地址判断目的IP是否在子网内:

- 同一网段
    1. 直接先查询arp缓存，如果找到目标ip的mac地址，直接发送出去
    2. 如果不存在的话会通过该网卡广播询问目的IP的mac地址,得到后就开始发包了,同时mac地址也会被arp缓存起来.
- 不在同一网段内, 由网关处理
    通过获取路由器的mac(获取过程与同一网段的情况一样), 再将数据包交给网关路由.

### arp缓存时间
参考:
- [Linux实现的ARP缓存老化时间原理解析](https://blog.csdn.net/dog250/article/details/7251689)

/proc/sys/net/ipv4/neigh/ethX目录下的base_reachable_time是ARP缓存的老化时间.  其它兄弟文件都只是优化行为的措施, 比如gc_stale_time是`ARP缓存表项的缓存`的存活时间.

在Linux上想设置ARP缓存老化时间，执行`sysctl -w net.ipv4.neigh.ethX=Y`即可，如果设置别的，只是影响了性能，在Linux中，ARP缓存老化以其变为stale状态为准，而不是以其表项被删除为准，stale状态只是对缓存又进行了缓存.

![ Linux协议栈实现下ARP缓存的状态机](/misc/img/net/0_13289689352Ss2.gif.png)