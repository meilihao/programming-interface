# net
参考:
- [太厉害了，终于有人能把TCP/IP协议讲的明明白白了](http://developer.51cto.com/art/201906/597961.htm)

![全协议关系图](/images/net/network_protocal_all.png)
![TCP/IP协议关系图](/images/net/tcpip_protocal_r.png)
![protocols](/images/net/protocols.pdf)
[TCP/IP详解 卷1：协议](http://www.52im.net/topic-tcpipvol1.html)

计算机网络就是将多个独立工作的计算机系统通过通信线路相互连接构成的集合, 即其由计算机设备, 网络设备, 传输介质以及支持这些硬件的软件组成.

## 概念
数据包:
- 帧 : 表示数据链路层中数据传输的单位
- 数据包 : IP 和 UDP 等网络层以上的分层中数据传输的单位
- 段 : TCP 数据流中的信息
- 消息 : 应用协议中数据的单位

通信识别:
- mac : 识别同一链路中不同的计算机
- ip : 用来识别 TCP/IP 网络中互连的主机和路由器
- 端口 + protocol:　用来识别同一台计算机中进行通信的不同应用程序

Gateway（网关）在 TCP/IP 的世界里就是路由器的意思.

广播地址 : 在同一个链路中相互连接的主机之间发送数据包

相比于广播, 组播既可以穿透路由器, 可以实现只给那些必要的组发送数据包.

DHCP是自动设置 IP 地址、统一管理 IP 地址分配的机制.

NAT用于在本地网络中使用私有地址，在连接互联网时转而使用公网 IP 地址的技术, 是为正在面临地址枯竭的 IPv4 而开发的技术. 不过，在 IPv6 中为了提高网络安全也在使用 NAT.

IP 隧道是在网络层的首部后面追加网络层首部/IPv6首部的通信方法.

vpn(virtual private network)是在公用网络上建立虚拟私有网的技术.

点对点: 通信双方直接相连, 中间没有其他任何设备.

端到端: 两个终端系统的连接, 中间经过至少一个路由器.

### 分层结构
![OSI(Open System Interconnect, 开放系统互连参考模型) vs TCP/IP model](/images/net/OSI-vs-TCP-IP-model.jpg)
![OSI, TCP/IP, protocol](/images/net/tcp_ip_layers.png)
![各层数据封装](/images/net/package_layers.png)

> 分层(是计算机领域的常用技巧)是为了隔离, 过分层划分职能, 解问题, 与层之间约定接口, 蔽实现细节. 每个分层在发送时都会对所发送的数据附加一个包首部, 本层协议解读提供的必要信息, 发送的目标地址以及协议相关信息, 而从上一层收到的内容被认为是本层的数据.
> ISO七层是理论, TCP/IP四层是实践
> 物理层与数据链路层区别: 物理层是物理链路; 数据链路层是基于物理层的逻辑链路. 有点类似与http2中的connection与stream的关系.
> 数据链路层的主要作用是**在互连同一种数据链路**的节点之间进行包传递
> 网络层可以跨越不同的数据链路, 使是在不同的数据链路上也能实现两端节点之间的数据包传输

七层model各层作用:
7. 给用户应用的提供接口
6. 进行数据格式的转换, 比如加解密
5. 会话管理
4. 从端对端透明地传送报文
3. 分组传输和路由选择
2. 在链路上无错地传输帧, 常见设备网卡, 网桥, 二层交换机
1. 将数据以比特流的形式在物理介质上传输, 常见设备网线, 光纤

计算机网络分类:
- 按照网络覆盖的地理范围
    1. 局域网(LAN, Local Area Network), 比如常见的无线局域网(WLAN)
    1. 城域网(MAN, Metropolitan Area Network)
    1. 广域网(WAN, Wide Area Network), 比如Internet
- 按照网络管理模式
    1. 对等网(PTP)
    1. C/S网
- 按照传输方式
    1. 点对点传输, 比如modem使用的PPOE
    1. 广播式传输

## 物理层
双绞”(双绞线)是为了抑制噪声.
交换机端口的 **MAC 模块不具有 MAC 地址**, 它会根据帧中的目的MAC查 CAM表(MAC与交换机端口的映射表,通过帧的源MAC和广播查询MAC构建的), 后将信号发送到相应的端口.

> VLAN(虚拟局域网)中, 交换机的CAM表为(MAC地址, VLAN ID, 交换机端口), 为了提高广播查找效率, 它还会建立VLAN配置表(VLAN ID,该VLAN包含的所有交换机端口)
![二层交换原理](/images/l2_switch.png)

广播地址（ broadcast address）是一种特殊的地址, 广播地址设为接收方地址时, 会发送到网络中所有的设备. MAC 地址中的 FF:FF:FF:FF:FF:FF和 IP 地址中的 255.255.255.255 都是广播地址.

路由器是**基于 IP 设计的, 作在网络层**, 是数据传输过程中的指路人, 是能够连接不同的广域网形成更大的广域网.
交换机(二层)是**基于以太网设计的, 工作在数据链路层**, 是将以太网连接形成更大的以太网.
网关(Gateway)又称网间连接器/**协议转换器**. 网关在网络层以上实现网络互连, 最复杂的网络互连设备, 用于两个高层协议不同的网络互连, 充当翻译功能.

> 三层交换机 = 二层交换机 + 路由器
> 集线器只具有原样转发功能(广播模式), 在同一时刻只能有两个端口传送数据, 他端口只能等待, **已被交换机取代**.

交换机是通过 MAC 头部中的接收方 MAC 地址来判断转发目标的, 而路由器则是根据 IP 头部中的 IP 地址来判断的.
路由器会忽略主机号, 匹配网络号.
路由表中子网掩码为`0.0.0.0`的记录表示`默认路由`.
地址转换NAT的基本原理是在转发网络包时对 IP 头部中的 IP 地址和端口号 进行改写.

### frame
![frame](/images/net/frame.png)
每个包的前面都有报头和起始帧分界符（SFD）, 头用来测定时机, FD 用来确定帧的起始位置.

> 制定以太网标准的组织 IEEE 出于历史原因使用了“帧”而不是“包”, 此在以太网术语中都是说“帧”,可以认为两者等价.

### mac
作用:
1. 寻址(mac地址)
1. 解决网络中多个用户争抢公用传输通道

寻址需要依靠arp. mac帧分三种:
1. 单播 : 目的mac地址是一个单播mac地址的帧
1. 广播帧 : 目的mac地址是一个广播mac地址(全是`1`)的帧
1. 多播帧 : 目的mac地址是一个多播mac地址的帧

## 协议栈
协议栈即网络控制软件, 它是根据套接字中记录的控制信息来工作的.
协议栈发送数据的时机选择:
1. 每个网络包能容纳的数据长度, 协议栈会根据MTU来进行判断. 长度优先,可能产生延迟
2. 协议栈的内部计时器的时间. 时间优先, 可能降低网络效率

实际如何判断发送时机是由协议栈的实现决定的. 而且仅靠协议栈来判断发送的时机可能会带来一些问
题, 因此协议栈也给应用程序保留了控制发送时机的余地.

## dns
dns是让人使用名称, 让路由器使用 IP 地址进行通信的机制.

递归查询: DNS 服务器接收到客户机请求，**必须使用一个准确的查询结果回复客户机**. 如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机. 主体是 DNS 服务器.

迭代查询: DNS 服务器会向客户机提供其他能够解析查询请求的DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台DNS 服务器地址，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果为止. 主体是 客户机.

## TCP/IP 协议
TCP/IP协议族是一组协议的集合, 用来实现互联网上主机之间的相互通信.

包收发操作: 应用数据 <-> tcp模块 <-> ip模块 <-> 网络硬件.

IP 模块会添加**IP 头部和 MAC 头部这两种头部**. IP 头部中包含 IP 协议规定的、 根据 IP 地址将包发往目的地所需
的控制信息； MAC 头部包含通过以太网的局域网将包传输至最近的路由器所需的控制信息.

TCP 模块在收发数据时会分为好几个阶段, 并为各个阶段设计了实现相应功能的网络包, 但 IP 的包收发操作
都是相同的, 并不会因包本身而有所区别,即它将TCP 头部和数据块看作一整块二进制数据, 在执行收发操作时并不关心其中的内容.
IP 模块也不关心 TCP 的操作阶段, 对于包的乱序和丢失也一概不知.
总之, IP 的职责就是将委托的东西打包送到对方手里, 或者是将对方送来的包接收下来, 仅此而已.

IP 头部格式见<<网络是怎样连接的>>表2.2

> IP 头部包含目的地的ip地址, 由tcp模块提供(实际最初来源是应用程序), IP模块不负责判断目的地ip地址的可用性.
> MAC 头部很容易被误解为是由网卡来处理的, 实际上它是由 TCP/IP 软件来负责的.
> 分片的包会在 IP 头部的标志字段中进行标记,同一个包的所有分片在IP头部都具有相同的 ID, 此外, IP 头部还有一个分片偏移量（ fragment offset）字段, 它表示当前分片在整个包中所处的位置. 
> 分片重组: 根据IP头部的ID和分片偏移量, 在所有分片全部收到之后, 就可以将它们还原成原始的包的操作.
> IP 头部中的 TTL（ Time to Live, 生存时间）字段表示包的有效期.

## ip协议
IP（IPv4、IPv6）相当于 OSI 参考模型中的第3层——网络层, 其有三大作用模块, 们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包.

IP 地址是网际层唯一标识通信端的id, 其由网络号和主机号两部分标识组成.

### ICMP和 ARP
IP 中包括 ICMP 协议和 ARP 协议.

ICMP 用于告知网络包传送过程中产生的错误以及各种控制消息; ARP 用于根据 IP 地址查询相应的以太网 MAC 地址; RARP是逆地址解析协议, 用是完成硬件地址到IP地址的映射.

> ARP 只适用于 IPv4. IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息.
> IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4. 在 IPv4 时期, 使没有 ICMP仍然可以实现 IP 通信. 然而,  IPv6 中, CMP 的作用被扩大, 果没有 ICMPv6, Pv6 就无法进行正常通信.

### 路由
该路由控制表的形成方式有两种：一种是管理员手动设置, 一种是路由器与其他路由器相互交换信息时自动刷新(由路由协议构建). 前者也叫做静态路由控制, 后者叫做动态路由控制, 比如BGP.

#### 路由协议
- ~~RIP : 适用于小型同类网络的一个自治系统(AS)内的路由消息传递, 已废弃~~
- OSPFv4 : 内部网关协议, 用于单个AS的路由器之间
- IS-IS
- BGPv4 : 用于大型网络和isp运营商

### IP 分包与组包
- 每种数据链路的最大传输单元（MTU）都不尽相同, 为每个不同类型的数据链路的使用目的不同. 使用目的不同, 承载的 MTU 也就不同.
- 任何一台主机都有必要对 IP 分片进行相应的处理. 分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理
- 经过分片之后的 IP 数据报在被重组的时候, 是由目标主机进行. **路由器虽然可做分片但不会进行重组**.


> MTU(Maximum Transmission Unit) 表示一个网络包的最大长度, 在以太网中一般是 1500 字节. MTU 是**包含头部的总长度**, 因此需要从MTU 减去头部的长度, 然后得到的长度就是一个网络包中所能容纳的最大数据长度, 这一长度叫作 MSS(Maximum Segment Size). 所以当 IP 数据包长度大于 MTU 时会被拆成多个帧传输, 为"IP分片".
>  : .

#### 路径 MTU 发现
- 分片机制也有它的不足, 如路由器的处理负荷加重之类. 因此, **只要条件允许,是不希望由路由器进行 IP 数据包的分片处理的**.
- 为了应对分片机制的不足, "路径 MTU"(PMTU)发现技术应运而生. 路径 MTU 指的是数据包不分片情况下动态发现传输路径上允许的最大的MTU,即路径上所有链路MTU的最小值. 进行路径 MTU 发现, 可以避免在中途的路由器上进行分片处理, 可以在 TCP 中发送更大的包.

> PMTU依赖ICMP报文

### ipv4
实际的 IPv4 地址是一串32 比特的数字, 按照 8 比特（ 1 字节）为一组分成 4 组, 常用圆点隔开的十进制表示, 但仅凭这一串数字我们无法区分哪部分是网络号, 哪部分是主机号, 因此才有了子网掩码,即子网掩码表示网络号与主机号之间的边界.

网络号(网段) = ip & 子网掩码

网络号全为`0`是保留地址.

主机号:
1. 主机号部分全部为 0 代表**整个子网**而不是子网中的某台设备
1. 主机号部分全部为 1 代表向子网上所有设备发送包, 即广播

IP 地址分为四个级别, 别为A类、B类、C类、D类, 它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分:
- A类IP 地址是首位以 `0` 开头的地址(`0`+7b网络号+24b主机号, 掩码`255.0.0.0`)
    十进制: `1.0.0.1~127.255.255.254`, 网络容量: 126,主机容量: 2^24-2
- B类IP 地址是前两位 `10` 的地址(`10`+14b网络号+16b主机号, 掩码`255.255.0.0`)
    十进制: `128.0.0.1~191.255.255.254`, 网络容量: 64*256,主机容量: 2^16-2
- C类IP 地址是前三位为 `110` 的地址(`110`+21b网络号+8b主机号, 掩码`255.255.255.0`)
    十进制: `192.0.0.1~223.255.255.254`, 网络容量: 32*256*256,主机容量: 2^8-2
- D类IP 地址是前四位为 `1110` 的地址(`1110`+28b多播地址)
    十进制: `224.0.0.0~239.255.255.255`, 每个多播地址代表一个多播组, 由IGMP控制.
- E类IP 地址是前五位为 `11110` 的地址, 保留地址, 忽略

局域网ip段:
- A类局域网专用网段：10.0.0.1~10.255.255.254
- B类局域网专用网段：172.16.0.1~172.31.255.254
- C类局域网专用网段：192.168.0.1~192.168.255.254

> 255.255.255.255为通用的广播地址

## 传输层中的 TCP 和 UDP
TCP/IP 中有两个具有代表性的传输层协议, 别是 TCP 和 UDP.

- TCP 是面向连接的、可靠的流协议. 
    流就是指不间断的数据结构(即无数据边界), 应用程序采用 TCP 发送消息时, 然可以保证发送的顺序, 还是犹如没有任何间隔的数据流发送给接收端. TCP 为提供可靠性传输, 行"顺序控制”或"(发控制)机"( 此外)具备"流控制（流量"(）”、)拥塞控制”、"(网络利)率等众多功能.
- UDP 是无连接的, 不具有可靠性的数据报协议
    细微的处理它会交给上层的应用去完成. 虽然可以确保发送消息的大小(有边界), 不能保证消息一定会到达, 必要时应用需要自行进行重发处理

TCP与UDP的区别
1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的, 发送数据之前不需要建立连接
1. TCP提供可靠全双功的通信服务. UDP是半双功, 能单向传播. 
1. 通过TCP连接可靠传送的数据, 靠的、无差错, 丢失, 重复, 按序到达;UDP则是不可靠信道, 最大努力交付, 不保证可靠交付.
1. TCP面向字节流, 际上是TCP把数据看成一连串无结构的字节流,即没有数据边界, 可能出现粘包;UDP是面向报文的．
1. TCP具有拥塞控制和流量控制; UDP没有拥塞控制和流量控制, 此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用, IP电话, 时视频会议等）
1. 每一条TCP连接只能是点到点的; UDP比较灵活, 持一对一, 对多, 对一和多对多的交互通信
1. TCP首部开销最小20字节,最大60字节;UDP的首部开销小, 有8个字节.

TCP/UDP应用场景:
- tcp : 效率要求相对低, **有可靠传输要求**的场景. 因为传输中需要对数据确认、重发、排序等操作, 比之下效率没有UDP高.
    举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录. NSQ底层通讯就采用TCP. 对应的协议有http,imap,smtp,ssh,telnet等
- udp : 对**高速传输和实时性有较高要求**的通信或广播通信, 且对准确性要求相对低的场景
    举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯, 度要求高, 是出现偶尔断续不是太大问题, 且此处完全不可以使用重发机制）、广播通信（广播、多播）. 对应的协议有DNS等.

拥塞: 通信网络负荷超出其吞吐能力, 导致该网络性能下降的情况.

拥塞控制是确保网络能承载用户的通信量, 是全局性问题, 与主机, 路由器, 交换机等网络传输性能相关的所有组成相关.
流量控制与通信双方的通信量相关, 是局部问题.

## tcp
![tcp握手/挥手/状态](/images/net/tcp_status.jpg)
![tcp状态转换](/images/net/tcp_status_change.jpg)

实验环境:
```bash
$ nc -l -p 9000
$ nc localhost 9000
```
使用wireshare或tcpdump截包.

> tcp三次握手时发起方即为client; 四次分手时没有client, server之分.
> ACK起应答作用, SYN起同步作用
> 在Linux上报文段的最大生存时间通常是30秒, 2倍的MSL就是一分钟
> TCP规定, YN报文段（SYN=1的报文段）不能携带数据, 需要消耗掉一个序号
> TCP规定, ACK报文段可以携带数据, 是如果不携带数据则不消耗序号
> TCP规定, FIN报文段即使不携带数据, 要消耗一个序号
> 确认应答（ACK）: 在 TCP 中, 发送端的数据到达接收端时, 收端会返回的已收到消息的通知

### 三次握手
![TCP连接的建立](/images/net/tcp_connect_handle.png)

1. 第一次握手：建立连接. 
    client发送连接请求报文段, 将SYN位置为1, Sequence Number(随机)为x；然后, client进入SYN_SEND状态, 等待服务器的确认
2. 第二次握手：服务器端收到数据包后由标志位SYN=1知道client请求建立连接. 
    服务器收到client的SYN报文段, 需要对这个SYN报文段进行确认即设置Acknowledgment Number为x+1(Sequence Number+1)；同时, 自己还要发送SYN请求信息即将SYN位置为1, Sequence Number(随机)为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中, 一并发送给client, 此时服务器进入SYN_RECV状态；
3. 第三次握手：验证server ack并建立连接. 
    client收到服务器的SYN+ACK报文段, 验证server发回的ACK有效性, 通过后将Acknowledgment Number设置为y+1, 向服务器发送ACK报文段, 这个报文段发送完毕以后, client和server端都进入ESTABLISHED状态, 这样就完成TCP三次握手了. 
完成了三次握手, client和server就可以开始传送数据.

> tcp每个package均带有win(窗口大小, 即本端要告诉对端当前可以接受的数据量, 其不包括tcp头部大小).
> TCP Windows Update: 发送者传输数据比接收者读取快, 因此接收者需告诉发送者应以多大的速度发送数据, 从而使得数据传输与接受恢复正常.

为什么是三次: 防止了服务器端的一直等待而浪费资源. 假设握手是两次, 客户端发送连接请求因某些原因滞留, 客户端在等待超时后重新发送,服务端收到并响应,最后关闭连接通信(比如短请求像http请求之类的). 之后那个失效的连接请求抵达了服务端, 于只有两次握手, 务端会认为是新请求, 收到请求就会进入ESTABLISHED状态, 待发送数据或主动发送数据. 但此时的客户端早已进入CLOSED状态, 务端将会一直等待下去, 样浪费服务端连接资源.

由三次握手可以看出, 服务器收到 SYN 数据报文段后将为连接分配资源, 果服务器没有收到 ACK 报文段就会造成半开连接, 费服务器资源. SYN 洪水攻击就是利用 TCP 的这个缺陷, 过向服务器发送海量的 SYN 报文段而耗尽服务器资源. 详见[TCP洪水攻击（SYN Flood）的诊断和处理](https://cloud.tencent.com/developer/article/1115567)

### 四次分手
![TCP连接的释放](/images/net/tcp_close_handle.png)

1. 第一次分手：主机1（假定主机1为发起方）, 设置Sequence Number和Acknowledgment Number, 向主机2发送一个FIN报文段(表示没有数据要发送)；此时, 主机1进入FIN_WAIT_1状态
2. 第二次分手：主机2收到了主机1发送的FIN报文段, 再向主机1回一个ACK报文段, Acknowledgment Number为Sequence Number加1, 之后进入CLOSE_WAIT状态；主机1收到ACK进入FIN_WAIT_2状态；主机2告诉主机1, 同意你的关闭请求
3. 第三次分手：主机2向主机1发送FIN报文段, 表示这边数据也发完并准备好关闭连接了, 同时主机2进入LAST_ACK状态；
4. 第四次分手：主机1收到主机2发送的FIN报文段, 向主机2发送ACK报文段, 然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后, 就关闭连接；此时, 主机1等待2MSL(Double Maximun Segment Life, 两倍的报文段的最大生存时间)后依然没有收到回复, 则证明主机2端已正常关闭, 那么, 主机1也可以关闭连接了.
至此, TCP的四次分手就这么愉快的完成了

> 上方介绍的是一方主动关闭, 一方被动关闭的情况, 际中还会出现双方同时发送FIN+ACK进行主动关闭的情况.
> ![tcp同时关闭](/images/net/tcp_close_two.jpg)

为什么建立连接协议是三次握手, 而关闭连接却是四次握手呢? **tcp是全双工, 双方都要相互确认终止发送数据(即tcp的半关闭特性half-close)**,主机2收到FIN时可能还需要发送一些数据给对方, 这也是主机2的FIN和其响应主机1的FIN的ACK不能同时发送的原因.

为什么要有一个 TIME_WAIT 状态？为什么不能直接到达 CLOSED 状态？
1. 可靠地实现TCP全双工连接的终止
假设没有 TIME_WAIT 这种状态. 现实中, 网络环境不是理想的. 在数据包传输的过程中, 难免会有一些延时、丢包的情况发生. 如果在主机1最后一个ACK报文段发出去之后, 于某种原因, 没有到达主机2, 这样, 主机2在超时后, 就会向主机1重新发一个 FIN 报文段, 请求重传. 由于在主机1端, 连接实际上已经断开, 端口已经关闭. 那么在主机1收到这个报文段后, 会向主机2发送一个 RST 报文(RST表示复位, 用来异常地关闭连接). 而主机2收到该报文段后, 会认为是错误的, 它所期望收到的是ACK报文.

2. 保证让迟来的报文段有足够的时间被处理
同样在不理想的网络环境中, 有些包会在网络中有所延迟. 假如没有 TIME_WAIT 这种状态, 在关闭连接后并且建立新的连接后, 可能会收到该数据包. 由于序号不同, 接收方会要求对方重传数据包, 这样, 连接就会混乱出错. 而 TIME_WAIT 状态的时间, 一般是 2MSL 时间且端口没有释放. 这样, 前一个连接的报文段有足够的时间被识别或者丢弃, 也就不会出现这个问题.

为什么A(主机1)要先进入TIME-WAIT状态, 等待2MSL时间后才进入CLOSED状态？ 为了保证B(主机2)能收到A的确认应答.  若A发完确认应答后直接进入CLOSED状态, 那么如果该应答丢失, B等待超时后就会重新发送连接释放请求, 但此时A已经关闭了, 不会作出任何响应, 因此B永远无法正常关闭.

### 可靠性
网络出现错误时, tcp协议栈会负责重传; 因此网卡、路由器、应用程序都没有错误补偿机制, 一旦检测到错误就直接丢弃相应的包. TCP 会在尝试几次重传无效之后强制结束通信, 并向应用程序报错.

网络的错误检测和补偿机制:
1. 返回 ACK 号的等待时间（这个等待时间叫超时时间）.tcp会根据网络包平均往返时间调整 ACK 号等待时间.
2. 使用窗口有效管理 ACK 号. TCP 采用滑动窗口方式来管理数据发送和 ACK 号的操作. 所谓滑动窗口, 就是在发送一个包之后, 不等待 ACK 号返回, 而是直接发送后续的一系列包. 窗口大小一般和接收方的缓冲区大小一致.

通信结束之后,套接字并不会立即被删除, 而是会等待一段时间(通常是几分钟)之后再被删除,等待这段时间是为了防止误操作, 具体时长与包重传的操作方式有关.

#### 通过序列号/确认应答/超时重发/选择性确认(SACK)4中机制提高可靠性(即是否收到了网络包)
1. 如果有确认应答, 表明数据已经成功到达对端; 反之, 数据丢失的可能性很大
1. 在一定时间内没有等待到确认应答, 发送端就可以认为数据已经丢失, 进行重发. 由此, 即使产生了丢包, 依然能够保证数据能够到达对端, 实现可靠传输. 
1. 未收到确认应答并不意味着数据一定丢失. 也有可能是数据对方已经收到, 是返回的确认应答在途中丢失. 这种情况也会导致发送端误以为数据没有到达目的地而重发数据. 
1. 此外, 有可能因为一些其他原因导致确认应答延迟到达, 源主机重发数据以后才到达的情况也屡见不鲜. 此时, 主机只要按照机制重发数据即可. 
1. 对于目标主机来说, 重复收到相同的数据是不可取的. 为了对上层应用提供可靠的传输, 目标主机必须放弃重复的数据包. 因为此我们引入了序列号. 
1. 序列号是按照顺序给发送的数据包都标上号码的编号. 接收端查询接收数据 TCP 首部中的序列号和数据的长度, 自己下一步应该接收的序列号作为确认应答返送回去. 通过序列号和确认应答号, 接收方 能够识别是否已经接收数据, 能够判断是否需要接收, 从而实现可靠传输

![序列号和确认应答](/images/net/sequence_ack.jpg)

#### 重发超时的确定
1. 重发超时是指在重发数据之前, 等待确认应答到来的那个特定时间间隔. 如果超过这个时间仍未收到确认应答, 发送端将进行数据重发. 最理想的是, 取到一个最小时间, 能保证"确认应答一定能在这个时间段内返回. 
1. TCP 要求不论处在何种网络环境下都要提供高性能通信, 且无论网络拥堵情况发生何种变化, 必须保持这一特性. 为此, 在每次发包时都会计算往返时间及其偏差. 将这个往返时间和偏差时间相加, 重发超时的时间就是比这个总和要稍大一点的值. 
1. 在 BSD 的 Unix 以及 Windows 系统中, 都以0.5秒为单位进行控制, 因此重发超时都是0.5秒的整数倍. 不过, 最初其重发超时的默认值一般设置为6秒左右. 
1. 数据被重发之后若还是收不到确认应答, 会进行再次发送. 此时, 等待确认应答的时间将会以2倍、4倍的指数函数延长. 
1. 此外, 数据也不会被无限、反复地重发. 达到一定重发次数之后, 如果仍没有任何确认应答返回, 就会判断为网络或对端主机发生了异常, 强制关闭连接, 并且通知应用通信异常强行终止. 

#### 以段为单位发送数据
1. 在建立 TCP 连接的同时, 可以确定发送数据包的单位, 它们也可以称其为"最大消息长度"(MSS). 最理想的情况是, 最大消息长度正好是 IP 中不会被分片处理的最大数据长度. 
1. TCP 在传送大量数据时, 会以 MSS 的大小将数据进行分割发送. 重发时也是以 MSS 为单位. 
1. MSS 在三次握手的时候, 在两端主机之间被计算得出. 两端的主机在发出建立连接的请求时, 在 TCP 首部中写入 MSS 选项, 告诉对方自己的接口能够适应的 MSS 的大小. 然后会在两者之间选择一个较小的值投入使用

#### 利用窗口控制提高速度
TCP 以1个段为单位，每发送一个段进行一次确认应答的处理. 这样的传输方式有一个缺点，就是包的往返时间越长通信性能就越低. 

为解决这个问题，TCP 引入了窗口这个概念. 确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间将会被大幅地缩短. 即发送端主机在发送了一个段以后不必要一直等待确认应答，而是继续发送.

![窗口控制](/images/net/tcp_window.jpg)

> 窗口大小就是指无需等待确认应答而可以继续发送数据的最大值. 上图中窗口大小为4个段. 这个机制实现了使用大量的缓冲区，通过对多个段同时进行确认应答的功能.
> 接收方收到不连续序号时会先缓存数据到`接收窗口`待完整后提交给应用/将`接收窗口`中有效的连续的部分提交给应用

![滑动窗口控制](/images/net/tcp_window_move.jpg)

- 上图中的窗口内的数据即便没有收到确认应答也可以被发送出去. 不过，在整个窗口的确认应答没有到达之前，如果其中部分数据出现丢包，那么发送端仍然要负责重传. 为此，发送端主机需要设置缓存保留这些待被重传的数据，直到收到他们的确认应答. 
- 在滑动窗口以外的部分包括未发送的数据以及已经确认对端已收到的数据. 当数据发出后若如期收到确认应答就可以不用再进行重发，此时数据就可以从缓存区清除. 
- 收到确认应答的情况下，将窗口滑动到确认应答中的序列号的位置. 这样可以顺序地将多个段同时发送提高通信性能. 这种机制也别称为滑动窗口控制.

窗口控制中的重发控制在使用窗口控制中， 出现丢包一般分为两种情况
1. 部分确认应答丢失
    ![部分确认应答丢失](/images/net/tcp_window_ack_lost.jpg)
    因为接收端只对连续接收的数据段进行确认. 发送方收到`6001`即可认为1~6000都以接收, 可忽略丢失的`1001`和`3001`
1. 某个报文段丢失的情况
接收主机如果收到一个自己应该接收的序列号以外的数据时，会针对当前为止收到数据返回确认应答. 如下图所示，当某一报文段丢失后，发送端会一直收到序号为1001的确认应答，因此，在窗口比较大，又出现报文段丢失的情况下，同一个序列号的确认应答将会被重复不断地返回. 而发送端主机如果连续3次收到同一个确认应答，就会将其对应的数据进行重发. 这种机制比之前提到的超时管理更加高效，因此也被称为高速重发控制.
![高速重发控制](/images/net/tcp_window_resend_fast.jpg)

### 流控
滑动窗口机制

### 拥塞控制
tcp中最复杂的功能, 通过tcp连接双方商定的协议来减少数据的发送而实现的, 比如知名的[bbr](https://juejin.im/entry/5b8e5308e51d45589b26be26).


## socket
- socket.connect() 是通信双方交换控制信息, 尝试建立一个连接
    通信操作中使用的控制信息分为两类:
    1. 头部(以太网头部, IP头部, TCP头部等)中记录的信息
    2. 套接字（协议栈中的内存空间）中记录的信息
- socket.bind() : 为新建的socket绑定一个本地网络地址.
- socket.listen() : 为新socket分配缓存空间, 并给出队列大小
- socket.accept() : 阻塞调用方, 直到有连接进入
    新连接进来时socket调用accept原语创建一个新socket并返回一个与其关联的文件描述符, 旧socket继续监听.
- socket.send() : 向socket发送数据
- socket.recv() : 从socket接收数据
- socket.close() : 释放socket

> 默认情况，内核会认为socket函数创建的套接字是主动套接字（active socket），它存在于一个连接的客户端. 而服务器调用listen函数告诉内核，该套接字是被服务器而不是客户端使用的，即listen函数将一个主动套接字转化为监听套接字. 监听套接字可以接受来自客户端的连接请求. 服务器通过accept函数等待来自客户端的连接请求到达监听套接字, 处理后返回一个已连接套接字.

> 网络字节序是大端序

端口分类:
- 保留端口: 0~1023
- 动态分配端口: > 1024
- 注册端口: > 1024

## 扩展阅读
### tcp/ip
- [网络相关（tcp握手重传,http长短链接,Header分类）](http://liuxiang.github.io/2017/07/05/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%EF%BC%88tcp%E6%8F%A1%E6%89%8B%E9%87%8D%E4%BC%A0,http%E9%95%BF%E7%9F%AD%E9%93%BE%E6%8E%A5,Header%E5%88%86%E7%B1%BB%EF%BC%89/)

### socket
- [Unix网络编程(Unix Network Programming)](http://dirlt.com/unp.html)
- [epoll 的本质是什么？](https://my.oschina.net/editorial-story/blog/3052308)

### 路由
- ~~[VMware中三种网络连接的区别](http://www.cnblogs.com/rainman/archive/2013/05/06/3063925.html)~~
- [路由追踪程序Traceroute分析与科普](http://www.tuicool.com/articles/AfqemqY)
- [*基于 Linux 内核新特性的网关设计实践](https://linux.cn/article-10672-1.html)

### 协议
- [*协议森林](http://www.cnblogs.com/vamei/archive/2012/12/05/2802811.html)