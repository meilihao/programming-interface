# x86_64
[intel主板架构](/images/z390_chipset.jpg)

平台路径控制器(Platform Controller Hub，PCH)了取代南/北桥.
目前北桥芯片的功能已被集成在cpu里, 可参考[消失的北桥 主板芯片组背后的故事](http://www.mcplive.cn/?controller=Article&id=3008)

> 北桥负责高速IO, 与CPU通信，并且连接高速设备（内存/显卡），并且与南桥通信
> 南桥负责低速IO, 与低速设备（硬盘/USB）通信，时钟/BIOS/系统管理/旧式设备控制，并且与北桥通信

## cpu
cpu包括三个部分,运算单元、数据单元和控制单元, 其实它还包括时钟.

运算单元只管算,可以执行算术和逻辑运算, 例如做加法、做位移等等.

数据单元包括 CPU 内部的缓存和寄存器组,空间很小,但是速度飞快,可以暂时存放数据/指令和运算结果. 寄存器组可分为专用寄存器和通用寄存器. 专用寄存器的作用是固定的，分别寄存相应的数据；而通用寄存器用途广泛并可由程序员规定其用途.

控制单元是整个CPU的指挥控制中心，由指令寄存器IR（Instruction Register）、指令译码器ID（Instruction Decoder）和 操作控制器OC（Operation Controller） 等组成，协调整个cpu有序工作.  它根据用户预先编好的程序，依次从存储器中取出各条指令，放在指令寄存器IR中，通过指令译码（分析）确定应该进行什么操作，然后通过操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号. 操作控制器OC中主要包括：节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑.

**对于CPU, 我们只需要了解寄存器即可, 其他部分不需要太过关注:　程序是把寄存器作为操作对象来描述的**．因此对程序员来说CPU就是具有各种功能的寄存器的集合体.

> CPU 字长是CPU在单位时间内(同一时间)能一次处理的二进制数的位数叫字长.
> 外频(来自主板时钟, 其目前都相当低只有100MHz)指的是CPU与外部组件进行数据传输时的速度，倍频则是CPU内部用来加速工作效能的一个倍数，两者相乘才是CPU的频率速度. 因为CPU的倍频通常在出厂时已经被锁定而无法修改，因此较常被超频的是外频
> CPU通常在内部设计有一个锁相环频率发生器，对于输入的时钟信号(即外频)进行分频处理，按照一定比例提高输入的外频频率，从而得到CPU的实际工作频率，这个比例就称之为倍频系数
> 时钟周期作为CPU操作的最小时间单位，内部的所有操作都是以这个时钟周期作为基准

### 工作原理
1. 取指令
CPU 的控制单元里面,有一个指令指针寄存器,执行的是下一条指令在内存中的地址. 控制单元会不停地将代码段的指令拿进来,先放入指令寄存器.

指令=操作码+操作数地址.
操作码：汇编语言里的 mov，add，jmp 等符号码；
操作数地址：该指令需要的操作数所在的地方，是在内存里还是在CPU的内部寄存器里
1. 指令译码
指令寄存器中的指令经过译码，决定该指令应进行何种操作（就是指令里的操作码）、操作数在哪里（操作数的地址） 。
1. 执行指令
执行指令分为两个阶段： 取操作数 和 进行运算:
- 取操作数：CPU 通过寻址操作，从内存（数据段）中读取操作数到通用寄存器中，暂存起来
- 进行运算：运算单元通过指令中的操作码，对寄存器中的操作数进行 mov，add，jmp 操作
1. 指令计数
修改指令计数器，决定下一条指令的地址 . CPU 重复上述三步操作，处于内存代码段的指令被逐个的执行，直到程序执行完毕为止

### [x86_64寄存器](https://docs.microsoft.com/zh-CN/windows-hardware/drivers/debugger/x64-architecture)
x86_64寄存器的变化不仅体现在位数上，更加体现在寄存器数量上. 新增加寄存器%r8到%r15, 加上x86的原有8个，一共16个寄存器:
```txt
%rsp 栈指针寄存器，指向栈顶
%rbx，%rbp，%r12，%r13，%14，%15 被调用者保存寄存器. 遵循被调用者使用规则: 不使用 或 入栈备份，使用完后再出栈恢复
// 以下都是调用者保存寄存器
%rax 作为函数返回值使用
%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作传递函数参数，依次对应第1参数，第2参数...
%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值
```
x86_64中，所有寄存器都是64位，相对32位的x86来说，标识符发生了变化.

多年来，体系结构从8位扩展到16位，32位，64位, 因此每个寄存器都有一些内部结构： 
![rax](/images/register_rax.png)

%rax的低8位是8位寄存器%al, 紧靠的8位是%ah; 低16位是 %ax， 低32位是 %eax，整个64位是%rax.
为了向后兼容性，`%eax`依然可以使用，不过指向了`%rax`的低32位, 其他位数同理.

寄存器`%r8-%r15`也有相同结构，但命名方式稍有不同： 
![rx](/images/register_rxx.png)


如何查看寄存器:
1. [gdb](https://wizardforcel.gitbooks.io/100-gdb-tips/print-registers.html)
    打印寄存器命令: `i registers`/`i all-registers`
    `i all-registers` =`i registers` + 浮点寄存器(FPRs)和向量寄存器
1. dlv
    打印寄存器命令: `regs`

做法相同: 设置断点, 等程序运行到断点时打印寄存器信息即可:
```c
(gdb) i registers
rax            0x5555555546b0	93824992233136  // 返回值
rbx            0x0	0                           // 被调者保存
rcx            0x0	0                           // 第4个参数
rdx            0x7fffffffe1f8	140737488347640 // 第3个参数
rsi            0x7fffffffe1e8	140737488347624 // 第2个参数
rdi            0x1	1                           // 第1个参数
rbp            0x7fffffffe100	0x7fffffffe100  // 被调者保存
rsp            0x7fffffffe0f0	0x7fffffffe0f0  // 
r8             0x555555554750	93824992233296  // 第5个参数
r9             0x7ffff7de8c60	140737351945312 // 第6个参数
r10            0xc	12                          // 调者保存
r11            0x1	1                           // 调者保存
r12            0x555555554580	93824992232832  // 被调者保存
r13            0x7fffffffe1e0	140737488347616 // 被调者保存
r14            0x0	0                           // 被调者保存
r15            0x0	0                           // 被调者保存
rip            0x5555555546bf	0x5555555546bf <main+15>
eflags         0x206	[ PF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
```

[寄存器分类](https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf#BASIC PROGRAM EXECUTION REGISTERS):
- 通用寄存器(General-Purpose Registers)
    RAX, RBX, RCX, RDX, RSI, RDI, or R8-R15
    - RSP : 栈指针(Stack Pointer)寄存器，保存当前栈顶位置, 与SS配合使用
    - RBP : 基址指针(Base Pointer)寄存器，保存当前帧的栈底地址
- eflags : 标志寄存器(Program Status and Control Register)
    ![rflags](/images/register_flags.png)

    INTEL手册将EFLAGS中的标志按功能划分为三类:
    - 状态标志（status flags）
    - 控制标志（control flags）
    - 系统标志（system flags）
    
    这里只关注状态标志，即哪些指令会改变状态标志，然后Jcc指令又是如何根据状态标志决定程序执行流程的. EFLAGS寄存器的状态标志(0、2、4、6、7以及11位)指示算术指令（如ADD, SUB, MUL以及DIV指令）的结果，这些状态标志的作用如下:
    - CF(bit 0) [Carry flag]   若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置1，反之清零. 这个标志指示无符号整型运算的溢出状态，这个标志同样在多倍精度运算(multiple-precision arithmetic)中使用
    - PF(bit 2) [Parity flag]   如果结果的最低有效字节(least-significant byte)包含偶数个1位则该位置1，否则清零
    - AF(bit 4) [Adjust flag]   如果算术操作在结果的第3位发生进位或借位则将该标志置1，否则清零. 这个标志在BCD(binary-code decimal)算术运算中被使用.
    - ZF(bit 6) [Zero flag]   若结果为0则将其置1，反之清零
    - SF(bit 7) [Sign flag]   该标志被设置为有符号整型的最高有效位(0指示结果为正，反之则为负)
    - OF(bit 11) [Overflow flag]  如果整型结果是较大的正数或较小的负数，并且无法匹配目的操作数时将该位置1，反之清零. 这个标志为带符号整型运算指示溢出状态

    rflags的高32是保留位, 因此rflags = eflags
- (E|R)IP, 指令指针寄存器(Instruction Pointer Register, 也叫程序计数器) : 指向代码段中下一条指令的位置
- 段寄存器：
    - CS : 代码段寄存器(Code Segment Register)，其值为代码段的段值, 通过它可以找到代码在内存中的位置
    - DS : 数据段寄存器(Data Segment Register)，其值为数据段的段值, 通过它可以找到数据在内存中的位置
    - SS : 堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值, 栈是程序运行中一个特殊的数据结构,数据的存取只能从一端进行,秉承后 进先出的原则. 凡是与函数调用相关的操作,都与栈紧密相关.
    - ES : 附加段寄存器(Extra Segment Register)，其值为附加数据段的段值
    - FS : 附加段寄存器(Extra Segment Register)，其值为附加数据段的段值
    - GS : 附加段寄存器(Extra Segment Register)，其值为附加数据段的段值

> **x64禁止mov的两个操作数都指向内存, 因此将一个内存值复制到另一个内存位置需要两条指令, 中间通过寄存器中转**.

参考:
- [CPU 寄存器](http://chengqian90.com/Linux%E5%86%85%E6%A0%B8/CPU-%E5%AF%84%E5%AD%98%E5%99%A8.html)
- [深入浅出GNU X86-64 汇编](https://blog.csdn.net/pro_technician/article/details/78173777)
- [Intel® 64 and IA-32 Architectures Software Developer Manuals](https://software.intel.com/en-us/articles/intel-sdm)里的[Intel® 64 and IA-32 architectures software developer’s manual combined volumes](https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4)
- [AMD Developer Guides, Manuals & ISA Documents](https://developer.amd.com/resources/developer-guides-manuals/)里的[AMD64 Architecture Programmer's Manual Volume 1: Application Programming](https://www.amd.com/system/files/TechDocs/24592.pdf)

实模式: 总线带宽20位即只能寻址1M(2^20),每个段最多 64K(2^16), 可以直接访问物理地址. 物理地址的计算公式为`physicaladdress=segment << 4 + offset`
保护模式: 访问内存的地址采用的是 分页 方式，生成的是 虚拟地址 ，不能直接访问物理内存，需要通过 MMU 硬件将虚拟地址转换为物理地址后才能访问物理内存. 此时CS、SS、DS、ES 仍然是 16 位的,但是不再是段的起始地址. 段的起始地址放在内存的某个表格里,表格中的每一项是段描述符(Segment Descriptor), 它才是真正的段的起始地址, 而段寄存器里面保存的是在这个表格中的哪一项,称为选择子(Selector). 将一个从段寄存器直接拿到的段起始地址,就变成了先间接地从段寄存器找到表格中的一项,再从表格中的一项中拿到段起始地址. 这样段起始地址就会很灵活了. 当然为了快速拿到段起始地址,段寄存器会从内存中拿到 CPU 的描述符放入高速缓存器中.

指令的寻址：
- 实模式：CS:IP
- 保护模式：CS:EIP

## Linux 开机引导和启动过程详解
参考:
- [Linux 开机引导和启动过程详解](https://linux.cn/article-8807-1.html)
- [Linux内核加载启动过程分析](http://www.qingpingshan.com/pc/fwq/288265.html)
- [在UEFI平台通过grub2引导各种介质操作系统](https://www.ibm.com/developerworks/community/blogs/5144904d-5d75-45ed-9d2b-cf1754ee936a/entry/uefi-grub2?lang=en)
- [bios内存分布-编写最简单操作系统(mbr)](https://blog.csdn.net/u011391093/article/details/51701602)
- ![real-mode memory map](/images/arch/10535A225-0.jpg)

> UEFI后, 运行实模式部分(即setup.bin), 已由Bootloader取代.
> grub2在加载内核期间就已经将cpu切换到了保护模式.

事实上，操作系统的启动分为两个阶段：引导boot和启动startup. 引导阶段开始于打开电源开关，结束于内核初始化完成和 systemd 进程成功运行. 启动阶段接管了剩余工作，直到操作系统进入可操作状态

基于 EFI(mac os)、UEFI(linux/windows) 的开机过程与传统的BIOS不尽相同，这里以传统的 BIOS，Intel CPU 为例介绍开机过程.

Intel x86 系列的 CPU 可以分别在 16 位 实模式（Real mode） 和 32 位 保护模式（Protected mode） 下运行. 为了向后兼容，Intel 将所有 x86 系列的 CPU（包括最新型号的 CPU）的硬件都设计为加电即进入 16 位实模式运行, 实模式的特征是 CPU 的寻址空间只有 2 ^ 20 = 1048576 Bytes = 1 MB，且硬件不支持分布机制和实时多任务.

### 引导过程
#### 启动BIOS
1. 在 x86 系统中, cpu加电进入实模式, 它会将 1M 空间最上面的 0xF0000 到 0xFFFFF 这 64K 映射给 BIOS(ROM). 当电脑刚加电的时候,会做一些重置的工作,将 CS 设置为 0xFFFF,将 IP 设置为 0x0000,所以第一条指令就会指向 0xFFFF0(CS * 16 + IP, BIOS程序的入口地址),正是在 ROM 的范围内. 在这里,有一个 JMP 命令(`jmp far f000:e05b`)会跳到 ROM 中做初始化工作的代码,于是BIOS 开始进行初始化的工作.
1. BIOS 就马不停蹄地检测内存、显卡等外设信息，当硬件检测通过之后，就在内存的物理内存的起始位置 0x000 ~ 0x3FF （刚好 1KB 的内存空间)建立中断向量表（IVT）, 在紧挨着它的位置用256字节的内存空间构建**BIOS数据区**(0x00400~0x004FF),并在大约57KB以后的位置(0x0E05B~0x0FFFE)加载了8KB左右与中断向量表相应的若干**中断服务程序**

> Shadow RAM 即RAM中被写保护的内存区域. 开机加电的瞬间，BIOS信息会首先从ROM中装载到Shadow RAM中的指定区域里. 由于Shadow RAM的物理编址与对应的ROM相同，所以当需要访问BIOS时，只需访问Shadow RAM而不必再访问ROM，这就能大大加快计算机系统的运算时间. 因此BIOS程序的入口地址0xFFFF0就是指RAM的物理绝对地址，BIOS程序的第一条指令就设计在这个位置.
> 关于入口地址的形成，有的文章上说是CS 0xFFFF和IP 0x0000的组成，有的文章上说是 CS 0xF000 和IP 0xFFF0的组合，我猜可能是不同硬件的初始化不同，只要最后形成的入口地址是 0xFFFF0就行
> x86 中断向量表中有 256 个中断向量，每个中断向量用 4 个字节来表示（CS 用两个字节表示，IP 也用两个字节表示），通过中断向量中保存的 CS:IP 地址就可以跳转到对应的中断处理程序去处理中断请求信号

#### 加载操作系统内核程序并为保护模式做准备
1. BIOS让CPU接收到一个int0x13中断，CPU接收到这个中断后，会立即在中断向量表中找到int0x13这个中断向量. 该中断服务程序的作用是将某个接入的可引导设备的引导扇区（MBR 扇区，Master Boot Record）的 512 个字节(前446B是boot loader)的数据加载到物理内存地址为 0x7C00 ~ 0x7E00 的区域，然后程序就跳转到 0x7C00 处开始执行，至此，BIOS 就完成了所有的工作，将控制权转交到了 MBR 中的代码. 这个中断服务程序是BIOS事先设计好的，代码是固定的，与操作系统无关
1. 从 MBR 扇区中的第一个 bootloader 程序跳转实际执行内核加载操作的第二个 bootloder 程序. 第二个 bootloder 程序查找 Linux Kernel 镜像在启动盘中的位置, 将找到的 Linux Kernel 镜像和 initrd 文件加载到物理内存中的指定地址处，并建立运行内核的所需的基本环境, 再加载 systemd 进程，并转移控制权到 systemd. 由于此时还没有其他任何程序在执行，故其不能执行任何有关用户的功能性任务


> Bootloader 是一段用来将 Linux Kernel 镜像文件加载到物理内存中指定地址的程序，这里所指的 Bootloader 是广义上概念，其实它还可以细分成两个独立的 bootloader：
> 第一个 bootloader (boot.img)：由 MBR 扇区中的前 446 个字节构成，作用是找到第二个 bootloader 并将其加载到物理内存中，并跳转到第二个 bootloader 中执行.
> 第二个 bootloader (core.img)：这个 bootloader 位于启动盘中 MBR 扇区之后，根据 bootloader 代码的大小可能会占用一个或多个磁盘分区，它的主要作用就是找到磁盘中存放的 Linux Kernel 镜像文件以及 initrd 文件（如果在内核命令行参数中指定了的话），并将其加载到物理内存当中
> 以上这两个 bootloader 程序合在一起就构成了我们在 Linux 系统中经常用到的![GRUB2](/images/GNU_GRUB_components.png)

#### linux kernel 初始化
内核的启动从入口函数 start_kernel() 开始, 在 ${kernel_root}/init/main.c 文件中,start_kernel 相当于内核的main 函数.

start_kernel流程:
1. 在操作系统里面,先要有个创始进程`set_task_stack_end_magic(&init_task)`. 它是系统创建的第一个进程,我们称为0 号进程, 也是唯一一个没有通过 fork 或者 kernel_thread 产生的进程,是进程列表的第一个.
1. trap_init() 设置了很多中断门 (Interrupt Gate),用于处理各种中断
1. mm_init() 用来初始化内存管理模块
1. sched_init() 用于初始化调度模块
1. vfs_caches_init() 用来初始化基于内存的文件系统 rootfs
1. rest_init()用来做其他方面的初始化
    1. 用kernel_thread(kernel_init, NULL, CLONE_FS) 创建第二个进程,这个是1 号进程, 是用户态的进程
    1. 用kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES), 创建第2 号进程. 函数 kthreadd,负责所有内核态的线程的调度和管理,是内核态所有线程运行的祖先

### 启动过程
systemd 是所有进程的父进程. 它负责将 Linux 主机带到一个用户可操作状态（可以执行功能任务）.

首先，systemd 挂载在 /etc/fstab 中配置的文件系统，包括内存交换文件或分区. systemd 借助其配置文件 /etc/systemd/system/default.target 决定 Linux 系统应该启动达到哪个状态（或目标态target）, 对于桌面系统，其链接到 graphical.target, 对于一个服务器操作系统来说，default.target 更多是默认链接到 multi-user.target.
然后, 直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码, 至此，全部启动过程完成.

> /etc/systemd/system/default.target没有则使用/usr/lib/systemd/system/default.target
> target查看: systemctl get-default

## grub2
参考:
- [GRUB 与系统引导](https://blog.nanpuyue.com/2017/037.html)

core.img 由 lzma_decompress.img、diskboot.img、kernel.img(是grub2的kernel) 和一系列的模块组成.

boot.img 先加载的是 core.img 的第一个扇区, 如果从硬盘启动的话,这个扇区里面是diskboot.img.

boot.img 将控制权交给 diskboot.img 后,diskboot.img 的任务就是将 core.img 的其他部分加载进来;
- 先是解压缩程序 lzma_decompress.img
- 再往下是 kernel.img(grub 的内核而不是linux kernel)
- 最后是各个模块 module

kernel.img 是压缩过的,现在执行的时候,需要解压缩. 但实模式这 1M 的地址空间实在放不下了,所以在真正的解压缩之前,lzma_decompress.img 做了一个重要的决定,就是调用 real_to_prot,切换到保护模式,这样就有了更大的寻址空间.

> 切换保护模式的函数 DATA32 call real_to_prot 会打开 Gate A20,也就是第 21 根地址线的控制线

切换到保护模式要干很多工作,大部分工作都与内存的访问方式有关:
1. 启用分段, 即在内存里面建立段描述符表,将寄存器里面的段寄存器变成段选择子,指向某个段描述符,这样就能实现不同进程的切换了
1. 启动分页

kernel.img 对应的代码里有 grub_main, 它是grub kernel 的主函数. 在这个函数里面,grub_load_config() 开始解析 `/boot/grub/grub.conf` 文件里的配置信息.
如果是正常启动,grub_main 最后会调用 grub_command_execute ("normal", 0, 0),最终会调用 grub_normal_execute() 函数. 在这个函数里面 grub_show_menu() 会显示出让你选择的那
个操作系统的列表, 选中某个操作系统后就会调用 grub_menu_execute_entry() , 开始解析并执行你选择的那一项.

比如`linux	/vmlinuz-4.15.0-30deepin-generic root=UUID=e7da8b89-73e6-414f-b3ab-2189f31131a8 ro  splash quiet  DEEPIN_GFXMODE=$DEEPIN_GFXMODE`命令,表示装载指定的内核文件,并传递内核启动参数, 于是grub_cmd_linux() 函数会被调用, 它会首先读取 Linux 内核镜像头部的一些数据结构,放到内存
中并进行检查. 如果检查通过,则会读取整个 Linux 内核镜像到内存. 如果配置文件里面还有 initrd 命令,用于为即将启动的内核传递 init ramdisk 路径, 那么grub_cmd_initrd() 函数会被调用,将 initramfs 加载到内存中来.

当这些事情做完之后,grub_command_execute ("boot", 0, 0) 才开始真正地启动内核.

## 中断、异常和系统调用
系统调用(System call)是应用程序主动向操作系统发出的服务请求.
异常(Exception)则是非法指令或者其他原因导致的指令执行失败(如：内存出错)之后的处理请求.
中断(hardware interrupt)是硬件设备对操作系统提出的处理请求.

中断、异常和系统调用的比较
- 源头
    中断：外设
    异常：应用程序意想不到的行为
    系统调用：应用程序请求操作提供服务
- 响应方式
    中断：异步
    异常：同步. 因为异常是与当前指令有关的，必须处理完该异常问题才能继续下去
    系统调用：异步或同步
- 处理机制
    中断：持续，对用户应用程序是透明的
    异常：杀死或者重新执行意想不到的应用程序指令. 异常会处理当前所出现的问题
    系统调用：用户请求后开始处理，处理完成后继续等待用户请求

## Ring
x86 提供了分层的权限机制,把区域分成了四个 Ring,越往里权限越高,越往外权限越低.

操作系统很好地利用了这个机制,将能够访问关键资源的代码放在 Ring0称为内核态(Kernel Mode);将普通的程序代码放在 Ring3称为用户态 (User Mode)

系统调用过程: 用户态 - 系统调用 - kernel保存寄存器 - 内核态执行系统调用 - kernel恢复寄存器 - 返回
用户态,然后接着运行.

## ELF
Linux 下一个常用的格式是ELF (Executable and Linkable Format,可执行与可链接格式)