# stack
![stack 布局](images/stack_64_2.png)
![stack 布局](images/stack_64_3.png)

栈 我们通常指保存局部变量，具有先进后出 (FILO) 特性的一段高内存地址空间，维护这个 栈 结构而使用两个寄存器：栈指针 rsp 、帧指针 rbp. 当程序调用层数比较深时，栈内存呈现出一块一块连续空间，每一块空间属于某一个调用对像，这个块可以称之为帧(stack frame), 即栈帧表示程序的函数调用记录, 用于保存函数调用过程中的各种信息（参数，返回地址，本地变量等）.

> 栈的生长方向是从高地址到低地址.
> pop操作后，栈中的数据并没有被清空，只是该数据我们无法直接访问

通常所有参数直接用寄存器传递, 而使用栈帧的情况:
- 调用过程中需要的存储空间**超出**寄存器能够存放的大小(最多6个整型参数)时
- 一个局部变量使用了指针
- 某些局部变量是数组或struct

> 通过栈传递参数时, 所有的数据大小都要向8的倍数对齐. 而引用传参时调用代码必定要分配一个栈帧.

寄存器使用顺序: `rdi, rsi, rdx, rcx, r8, r9`

## 函数调用栈
- 参数从右向左依次入栈
- call function = push rip + jmp function
- 抬高栈顶，分配临时数据区: `subq &xx, %rsp`

## c stack
参考:
- [函数调用栈](https://www.jianshu.com/p/0299f56edab5)
- [探秘“栈”之旅](https://linux.cn/article-9645-1.html)

不超过6个参数:
```c
#include<stdio.h>

int add(int a, int b, int c) { // 3 个参数相加
    int sum = a + b + c;
    return sum;
}

int main(void) {
    int i = 10;
    int j = 20;
    int sum = add(1, 2, 3);
    return 0;
}
```

`gcc -S demo1.c`:
```asm
	.file	"demo1.c"
	.text
	.globl	add
	.type	add, @function
add:                            // 参数: %edi,a ; %esi,b ; %edx,c
.LFB0:
	.cfi_startproc              // 用在每个函数的开始，用于初始化一些内部数据结构
	pushq	%rbp                // 保存调用者的%rbp = `subq $8, %rsp` + `movq %rbp, (%rsp)`
	.cfi_def_cfa_offset 16		// 表示此处（rsp）距离 CFA 16 字节. CFA（Canonical Frame Address）是标准框架地址,指调用者栈帧中调用点处的栈指针值
	.cfi_offset 6, -16
	movq	%rsp, %rbp          // 让新的%rbp指向栈顶
	.cfi_def_cfa_register 6
	movl	%edi, -20(%rbp)     // a 入栈, 从左往右入栈
	movl	%esi, -24(%rbp)     // b 入栈
	movl	%edx, -28(%rbp)     // c 入栈
	movl	-20(%rbp), %edx     // 将a放入%edx
	movl	-24(%rbp), %eax     // 将b放入%eax
	addl	%eax, %edx          // a+b放入%edx
	movl	-28(%rbp), %eax     // 将c放入%eax
	addl	%edx, %eax          // %edx+c放入%eax
	movl	%eax, -4(%rbp)      // 将计算结果z, 放入紧靠%rbp的位置,
	movl	-4(%rbp), %eax      // 将z放入%eax
	popq	%rbp                // 恢复旧%rbp = `movq (%rsp), %rbp`(读数据)+`addq $8, %rsp`
	.cfi_def_cfa 7, 8
	ret                         // = popq %rip, 继续执行
	.cfi_endproc // 在函数结束的时候使用与.cfi_startproc相配套使用
.LFE0:
	.size	add, .-add
	.globl	main
	.type	main, @function
main:
.LFB1:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$16, %rsp
	movl	$10, -4(%rbp)   // i入栈
	movl	$20, -8(%rbp)   // j入栈
	movl	$3, %edx        // 第3个参数, 从右往左传参
	movl	$2, %esi        // 第2个参数
	movl	$1, %edi        // 第1个参数
	call	add             // pushp %rip(%rip已是call指令的下一条指令的地址, 通过gdb可了解) + jump add地址入口
	movl	%eax, -12(%rbp)
	movl	$0, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE1:
	.size	main, .-main
	.ident	"GCC: (Debian 6.3.0-18+deb9u1) 6.3.0 20170516"
	.section	.note.GNU-stack,"",@progbits
```

> 使用`gcc -g -O0 demo1.c`生成代码, 之后再用`objdump -S a.out`反汇编后代码比`gcc -S demo1.c`可读性更好
> 对比发现gcc生成的asm比`clang-8 -S demo1.c`的可读性更好.
> .cfi_startproc 和 .cfi_endproc 分别是 dwarf2 CFI 的初始过程和结束过程指令，它们隐藏了一些 CFI 有关的操作

超过6个参数:
```c
#include<stdio.h>

int add(int a, int b, int c, int d, int e, int f, int g, int h) { // 8 个参数相加
    int sum = a + b + c + d + e + f + g + h;
    return sum;
}

int main(void) {
    int i = 10;
    int j = 20;
    int k = i + j;
    int sum = add(11, 22,33, 44, 55, 66, 77, 88);
    int m = k; // 为了观察 %rax Caller Save 寄存器的恢复
    return 0;
}
```

`gcc -S demo2.c`:
```asm
	.file	"demo2.c"
	.text
	.globl	add
	.type	add, @function
add:                         // 参数: %edi,a ; %esi,b ; %edx,c; %ecx,d; %r8d,e ; %r9d,f
.LFB0:
	.cfi_startproc
	pushq	%rbp             // 保存调用者的%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp       // 让新的%rbp指向栈顶
	.cfi_def_cfa_register 6
	movl	%edi, -20(%rbp)  // 将a~f 入栈
	movl	%esi, -24(%rbp)
	movl	%edx, -28(%rbp)
	movl	%ecx, -32(%rbp)
	movl	%r8d, -36(%rbp)
	movl	%r9d, -40(%rbp)
	movl	-20(%rbp), %edx
	movl	-24(%rbp), %eax
	addl	%eax, %edx      // 计算a+b -> %edx
	movl	-28(%rbp), %eax
	addl	%eax, %edx
	movl	-32(%rbp), %eax
	addl	%eax, %edx
	movl	-36(%rbp), %eax
	addl	%eax, %edx
	movl	-40(%rbp), %eax
	addl	%eax, %edx      // %edx = a + b + c + d + e + f
	movl	16(%rbp), %eax  // 跳过调用者的%rbp和返回地址, 到上一个frame里取g
	addl	%eax, %edx
	movl	24(%rbp), %eax  // 取h
	addl	%edx, %eax
	movl	%eax, -4(%rbp)  // 将结果保存到sum
	movl	-4(%rbp), %eax  // 将sum返回
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	add, .-add
	.globl	main
	.type	main, @function
main:
.LFB1:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$32, %rsp           // 栈帧分配32B空间
	movl	$10, -4(%rbp)       // 10 入栈
	movl	$20, -8(%rbp)       // 20 入栈
	movl	-4(%rbp), %edx      // 10 -> %edx 
	movl	-8(%rbp), %eax      // 20 -> %eax
	addl	%edx, %eax          // %eax += %edx 
	movl	%eax, -12(%rbp)     // %eax 入栈(k)
	pushq	$88                 // 第8个参数入栈(h)
	pushq	$77                 // 第7个参数入栈(g)
	movl	$66, %r9d           // 小于等于6个参数使用寄存器
	movl	$55, %r8d
	movl	$44, %ecx
	movl	$33, %edx
	movl	$22, %esi
	movl	$11, %edi
	call	add
	addq	$16, %rsp           // 回收空间
	movl	%eax, -16(%rbp)     // 将add返回值sum入栈
	movl	-12(%rbp), %eax     // k -> %eax ,因为x64禁止mov的两个操作数都指向内存, 因此将一个内存值复制到另一个内存位置需要两条指令, 中间通过寄存器中转
	movl	%eax, -20(%rbp)     // 给m赋值
	movl	$0, %eax
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE1:
	.size	main, .-main
	.ident	"GCC: (Debian 6.3.0-18+deb9u1) 6.3.0 20170516"
	.section	.note.GNU-stack,"",@progbits
```