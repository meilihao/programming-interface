# 内存对齐
为什么:
1. 平台（移植性）
   
   不是所有的硬件平台都能够访问任意地址上的任意数据. 例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况, 比如[go中在 32bit 平台下进行 64bit 原子操作要求必须 8 字节对齐，否则程序会 panic](https://ms2008.github.io/2019/08/01/golang-memory-alignment/).
1. 性能
   
   若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算. 而本身就对齐的内存仅需要一次访问就可以完成读取动作，这显然高效很多，是标准的空间换时间做法

> 实际上 CPU 并不会以一个一个字节去读取和写入内存，而是一块一块读取的，块的大小可以为 2、4、6、8、16 字节等大小，块大小我们称其为内存访问粒度. 假设访问粒度为 4，那么 CPU 就会以每 4 个字节大小的访问粒度去读取和写入内存.

在不同平台上的编译器都有自己默认的"对齐系数". 一般来讲, 我们常用的 x86 平台的系数为 4；x86_64 平台系数为 8. 需要注意的是，除了这个默认的对齐系数外，还有不同数据类型的对齐系数. 数据类型的对齐系数在不同平台上可能会不一致. 例如，在 x86_64 平台上，int64 的对齐系数为 8，而在 x86 平台上其对齐系数就是 4.

## tools
- [golang-sizeof.tips : 可视化 go struct的内存布局](http://golang-sizeof.tips/)
- [structlayout](https://github.com/dominikh/go-tools/tree/master/cmd/structlayout)
- [golangci-lint : 内存布局优化检查](https://ms2008.github.io/2019/08/01/golang-memory-alignment/)
- [Golang beautify data display for Humans](https://github.com/go-ffmt/ffmt)
