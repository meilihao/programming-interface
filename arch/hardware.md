# hardware

## cpu
### 指令集
参考:
- [《手把手教你设计CPU——RISC-V处理器篇》]

CPU的灵魂是指令集架构（Instruction Set Architecture，ISA）.

指令集，顾名思义是一组指令的集合，而指令是指处理器进行操作的最小单元（譬如加减乘除操作或者读/写存储器数据）.

![指令集架构示意图](/misc/img/arch/isa.png)

指令集架构主要分为复杂指令集（Complex Instruction Set Computer，CISC）和精简指令集（Reduced Instruction Set Computer，RISC），两者的主要区别如下:
- CISC不仅包含了处理器常用的指令，还包含了许多不常用的特殊指令. 其指令数目比较多，所以称为复杂指令集.
- RISC只包含处理器常用的指令，而对于不常用的操作，则通过执行多条常用指令的方式来达到同样的效果, 由于其指令数目比较精简，所以称为精简指令集.

指令集使用也遵循8/2原则: CISC指令集定义的指令，只有20%被经常使用到，而有80%则很少被用到, 那些很少被用到的特殊指令尤其让CPU设计变得极为复杂，大大增加了硬件设计的时间成本与面积开销. 因此自从RISC诞生之后，**基本上所有现代指令集架构都选择使用RISC架构**.

通俗来讲，处理器架构的位数是指通用寄存器的宽度，其决定了寻址范围的大小、数据运算能力的强弱. 除嵌入式主流进入32bit时代外, 目前主流的mobile、pc和server，均使用64位架构.

> 处理器指令集架构的宽度和指令的编码长度无任何关系. 并不是说64位架构的指令长度为64位（这是一个常见的误区）. **从理论上来讲，指令本身的编码长度越短越好，因为可以节省代码的存储空间**. 因此即便在64位的架构中，也大量存在16位编码的指令，且基本上很少出现过64位长的指令编码.

主流指令集架构:
- x86

    pc和server中的主流, 是CISC. Intel公司通过内部`微码化`的方法克服掉了CISC架构的部分缺点.

    微码化: 是指将复杂的CISC指令先用硬件解码器翻译成对应的内部简单指令（微码）序列，然后送给处理器流水线执行的方法，使得x86的处理器核也变成了一种RISC的形式，从而能够借鉴RISC架构的优点. 不过，额外的硬件解码器同样也会带来额外的复杂度与面积开销.
- arm

    嵌入式和mobile的主流.

    arm cpu分类:
    - Cortex-A：面向性能密集型系统的应用处理器核
    - Cortex-R：面向实时应用的高性能核
    - Cortex-M：面向各类嵌入式应用的微控制器核

    Cortex-A、Cortex-M和Cortex-R架构的最大区别是前者包含了**存储器管理单元（Memory Management Unit，MMU），因此可以支持操作系统的运行**.
- risc-v

    开源的模块化的isa, 没有历史包袱, 后发优势, 获得大学教育和业界的大力支持.

### RISC-V
模块化的 RISC-V 架构能够使得用户灵活地选择不同的模块进行组合,以满足不同的应用场景:
- 针对小面积、低功耗的嵌入式场景 : RV32IC 组合的指令集,仅使用机器模式( Machine Mode) 
- 针对高性能应用操作系统场景 : RV32IMFDC 的指令集,使用机器模式( Machine Mode )与用户模式( User Mode )两种模式

RISC-V 最基本也是唯一强制要求实现的指令集部分是由`I`字母表示的基本整数指令子集. 使用该整数指令子集,便能够实现完整的软件编译器.

> 一个特定组合`IMAFD`,也被称为`通用`组合,用英文字母 G 表示. 因此 RV32G 表示 RV32IMAFD, 同理 RV64G 表示 RV64IMAFD.

为了提高代码密度, RISC -V 架构也提供可选的`压缩`指令子集,用英文字母 C 表示, 压缩指令的指令编码长度为 16 bit, 而普通的非压缩指令的长度为 32 bit.

为了进一步减少面积, RISC-V 架构还提供一种`嵌入式`架构,用英文字母 E 表示, 该架构主要用于追求极低面积与功耗的深嵌入式场景, 仅需要支持 16 个通用整数寄存器,而**非嵌入式的普通架构则需要支持 32 个通用整数寄存器**.

RISC-V 架构的整数通用寄存器组,包含 32个 (I 架构)或者 16个 (E 架构),其中整数寄存器 0 被预留为常数0, 其他的 31个 (I 架构)或者 15个 (E 架构)为普通的通用整数寄存器.

如果使用浮点模块F或者D,则需要另外一个独立的浮点寄存器组,包含 32 个通用浮点寄存器. 如果仅使用 F 模块的浮点指令子集,则每个通用浮点寄存器的宽度为 32 bit; 如果使用了 D 模块的浮点指令子集,则每个通用浮点寄存器的宽度为 64 bit.

在流水线中能够尽快地读取通用寄存器组,往往是处理器流水线设计的期望之一,这样
可以提高处理器性能和优化时序. 大部分risc因为历史和指令累积原因很难实现, 而因为后发优势和业界经验总结, RISC-V 的指令集编码非常规整,指令所需的通用寄存器的索引 Clndex)都被放在固定的位置, 便于指令译码器( Instruction Decoder )译码出寄存器索引, 然后读取通用寄存器.

> 由于现在的主流应用是小端格式, RISC-V 架构仅支持小端格式.

RISC-V 通过公用的程序库(专门用于保存和恢复现场)来处理子程序调用, 而不是使用`一次读多个寄存器指令`和`一次写多个寄存器指令`, 因此可以大幅简化 CPU 的硬件设计.

RISC-V 的一个特殊之处是对任何的运算指令错误(包括整数与浮点指令〉均不产生异常,而是产生某个特殊的默认值,同时设置某些状态寄存器的状态位.

RISC-V 架构定义了 3 种工作模式,又称为特权模式( Privileged Mode ):
- Machine Mode :机器模式,简称 M Mode.
- Supervisor Mode :监督模式,简称 S Mode.
- User Mode :用户模式,简称 U Mode.

RISC-V 架构定义 M Mode 为必选模式,另外两种为可选模式,通过不同的模式组合可以实现不同的系统

RISC-V 架构也支持几种不同的存储器地址管理机制,包括对于物理地址和虚拟地址的管理机制,使得 RISC-V 架构能够支持从简单的嵌入式系统(直接操作物理地址〉到复杂的操作系统(直接操作虚拟地址)的各种系统.

RISC-V 架构定义了一些控制和状态寄存器( Control and Status Regist町, CSR ),用于配置或记录一些运行的状态. CSR 寄存器是处理器核内部的寄存器,使用自己的地址编码空间和存储器寻址的地址区间完全无关系.

RISC-V 架构目前虽然还没有定型的矢量( Vector )指令子集,但是从目前的草案中看, RISC-V 架构将使用可变长度的矢量, 而不是矢量定长的 SIMD 指 令集( 例如ARM 的 NEON 和 Intel 的 M孔1X ),从而能够灵活地支持不同的实现.

RISC -V 架构支持第三方的扩展. 用户可以扩展自己的指令子集, RISC-V 预留了大量的指令编码空间用于用户的自定义扩展,同时还定义了 4条 Custom 指令可供用户直接使用.