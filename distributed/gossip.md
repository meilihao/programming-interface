# Gossip
Gossip 的三板斧分别是：直接邮寄（Direct Mail）、反熵（Anti-entropy）和谣言传播（Rumor mongering）:
- 直接邮寄：就是直接发送更新数据，当数据发送失败时，将数据缓存下来，然后重传

	直接邮寄虽然实现起来比较容易，数据同步也很及时，但可能会因为缓存队列满了而丢数据。即只采用直接邮寄是无法实现最终一致性的
- 反熵. 本质上，反熵是一种通过异步修复实现最终一致性的方法. 常见的最终一致性系统（比如 Cassandra），都实现了反熵功能

	反熵指的是集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性

	在实现反熵的时候，主要有推、拉和推拉三种方式:
	1. 推方式，就是将自己的所有副本数据，推给对方，修复对方副本中的熵
	1. 拉方式，就是拉取对方的所有副本数据，修复自己副本中的熵
	1. 推拉: 同时修复自己副本和对方副本中的熵

	> 反熵中的熵是指混乱程度，反熵就是指消除不同节点中数据的差异，提升节点间数据的相似度，降低熵值

	反熵需要节点两两交换和比对自己所有的数据，执行反熵时通讯成本会很高，所以不建议你在实际场景中频繁执行反熵，并且可以通过引入校验和（Checksum）等机制，降低需要对比的数据量和通讯消息等.

	**反熵需要做一致性对比，很消耗系统性能，所以建议你将是否启用反熵功能、执行一致性检测的时间间隔等，做成可配置的，能在不同场景中按需使用**

	> 作为一种异步修复、实现最终一致性的协议，反熵在存储组件中应用广泛，比如 Dynamo、InfluxDB、Cassandra. 工作中，需要实现最终一致性时，优先考虑反熵.

	执行反熵时，相关的节点都是已知的，而且节点数量不能太多，如果是一个动态变化或节点数比较多的分布式环境（比如在 DevOps 环境中检测节点故障，并动态维护集群节点状态），这时反熵就不适用了, 此时需要"谣言传播"
1. 谣言传播: 当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据

	谣言传播非常具有传染性，它适合动态变化的分布式系统.

	谣言传播具有传染性，一个节点传给了另一个节点，另一个节点又将充当传播者，传染给其他节点，所以非常适合动态变化的分布式系统，比如 Cassandra 采用这种方式动态管理集群节点状态.


在实际场景中，实现数据副本的最终一致性时，一般而言，直接邮寄的方式是一定要实现的，因为不需要做一致性对比，只是通过发送更新数据或缓存重传，来修复数据的不一致，性能损耗低。在存储组件中，节点都是已知的，一般采用反熵修复数据副本的一致性。当集群节点是变化的，或者集群节点数比较多时，这时要采用谣言传播的方式，同步更新数据，实现最终一致.

