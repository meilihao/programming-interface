# 分布式db
分布式数据库的核心——数据分片、数据同步.

NewSQL 是基于 NoSQL 模式构建的分布式数据库，它通常采用**现有的 SQL 类关系型数据库为底层存储或自研引擎**，并**在此之上加入分布式系统**，从而对终端用户屏蔽了分布式管理的细节. Citus 和 Vitess 就是此种类型的两个著名案例.

NoSQL 和 NewSQL 是建立在一个假设上，即构建一个完备功能的分布式数据库代价是高昂的，需要进行某种妥协。而商用 Distributed SQL 数据库的目标恰恰是要以合理的成本构建这样一种数据库，可以看到它们的理念是针锋相对的.

## 分片
数据分片的方式一般有两种:
- 水平分片：在不同的数据库节点中存储同一表的不同行
- 垂直分片：在不同的数据库节点中存储表不同的表列

分片理念来源于经济学的边际收益理论：如果投资持续增加，但收益的增幅开始下降时，被称为边际收益递减状态, 而刚好要开始下降的那个点被称为边际平衡点.

该理论应用在数据库计算能力上往往被表述为：如果数据库处理能力遇到瓶颈，最简单的方式是持续提高系统性能，如更换更强劲的 CPU、更大内存等，这种模式被称为垂直扩展. 当持续增加资源以提升数据库能力时，垂直扩展有其自身的限制，最终达到边际平衡，收益开始递减.

分片算法一般指代水平分片所需要的算法:
- 哈希分片

    获取分片键，然后根据特定的哈希算法计算它的哈希值，最后使用哈希值确定数据应被放置在哪个分片中。数据库一般对所有数据使用统一的哈希算法（例如 ketama），以促成哈希函数在服务器之间均匀地分配数据，从而降低了数据不均衡所带来的热点风险。通过这种方法，数据不太可能放在同一分片上，从而使数据被随机分散开.

    这种算法非常适合随机读写的场景，能够很好地分散系统负载，但弊端是不利于范围扫描查询操作.

- 范围分片

    范围分片根据数据值或键空间的范围对数据进行划分，相邻的分片键更有可能落入相同的分片上。每行数据不像哈希分片那样需要进行转换，实际上它们只是简单地被分类到不同的分片上.

    范围分片需要选择合适的分片键，这些分片键需要尽量不包含重复数值，也就是其候选数值尽可能地离散。同时数据不要单调递增或递减，否则，数据不能很好地在集群中离散，从而造成热点。

    范围分片非常适合进行范围查找，但是其随机读写性能偏弱.

- 融合算法

    灵活地组合哈希分片和范围分片.

    比如可以建立一个多级分片策略，该策略在最上层使用哈希算法，而在每个基于哈希的分片单元中，数据将按顺序存储

- 地理位置算法

    该算法一般用于 NewSQL 数据库，提供全球范围内分布数据的能力

    在基于地理位置的分片算法中，数据被映射到特定的分片，而这些分片又被映射到特定区域以及这些区域中的节点, 然后在给定区域内，使用哈希或范围分片对数据进行分片.

自动分片是分布式数据库的主流功能，所有主要的分布式数据库，甚至数据库中间件都在尝试自动分片.

### 手动分片 vs 自动分片
手动分片是设置静态规则来将数据根据分片算法分散到数据库节点. 这一般是由于用户使用的数据库不支持自动的分片, 而在应用层面上做数据分片来解决, 也可以使用简单的数据库中间件或 Proxy 来设置静态的分片规则来解决.

手动分片的缺点是数据分布不均匀. 数据分布不均可能导致数据库负载极其不平衡.

使用自动分片意味着计算节点与分片算法可以相互配合，从而使数据库进行弹性伸缩.

使用基于范围的分片很容易实现自动分片：只需拆分或合并每个分片.

基于范围的分片可能会带来读取和写入热点，我们可以通过拆分和移动分片消除这些热点.

而使用基于哈希的分片的系统实现自动分片代价很高昂. 因为在应用哈希函数后，数据是随机分布的，并且调整散列算法肯定会更改大多数数据的分布情况.

## 数据复制
数据库的复制技术需要考虑两个因素：数据一致 RPO 和业务连续性 RTO.

常见的复制模式:
- 同步复制：如果由于从库已崩溃，存在网络故障或其他原因而没有响应，则主库也无法写入该数据
- 半同步复制：其中部分从库进行同步复制，而其他从库进行异步复制。也就是，如果其中一个从库同步确认，主库可以写入该数据
- 异步复制：不管从库的复制情况如何，主库可以写入该数据。而此时，如果主库失效，那么还未同步到从库的数据就会丢失

不同的同步模式是在性能和一致性上做平衡，三种模式对应不同场景，并没有好坏差异. 用户需要根据自己的业务场景来设置不同的同步模式.


常见的复制方式:
1. 基于语句的复制

    主库记录它所执行的每个写请求（一般以 SQL 语句形式保存），每个从库解析并执行该语句，就像从客户端收到该语句一样。但这种复制会有一些潜在问题，如语句使用了获取当前时间的函数，复制后会在不同数据节点上产生不同的值.

    另外如自增列、触发器、存储过程和函数都可能在复制后产生意想不到的问题, 但可以通过预处理规避这些问题。使用该复制方式的分布式数据库有 VoltDB、Calvin.

1. 日志（WAL）同步

    WAL 是一组字节序列，其中包含对数据库的所有写操作. 它的内容是一组低级操作，如向磁盘的某个页面的某个数据块写入一段二进制数据，主库通过网络将这样的数据发送给从库.

    这种方法避免了上面提到的语句中部分操作复制后产生的一些副作用，但要求主从的数据库引擎完全一致，最好版本也要一致. 如果要升级从库版本，那么就需要计划外停机. PostgreSQL 和 Oracle 中使用了此方法.

3. 行复制

    它由一系列记录组成，这些记录描述了以行的粒度对数据库表进行的写操作. 它与特定存储引擎解耦，并且第三方应用可以很容易解析其数据格式.

4. ETL 工具

    该功能一般是最灵活的方式. 用户可以根据自己的业务来设计复制的范围和机制，同时在复制过程中还可以进行如过滤、转换和压缩等操作, 但性能一般较低.

### 单主复制
即主从复制. 写入主节点的数据都需要复制到从节点，即存储数据库副本的节点. 当客户要写入数据库时，就必须将请求发送给主节点，而后主节点将这些数据转换为复制日志或修改数据流发送给其所有从节点. 从使用者的角度来看，从节点都是只读的.

### 多主复制
即主主复制. 数据库集群内存在多个对等的主节点，它们可以同时接受写入, 每个主节点同时充当主节点的从节点.

多主节点的架构模式最早来源于 DistributedSQL 这一类多数据中心，跨地域的分布式数据库。在这样的物理空间相距甚远，有多个数据中心参与的集群中，每个数据中心内都有一个主节点. 而在每个数据中心的内部，却是采用常规的单主复制模式.

此方法的最大缺点是，存在一种可能性，即两个不同的主节点同时修改相同的数据.

典型的多主复制产品有 MySQL 的 Tungsten Replicator、PostgreSQL 的 BDR 和 Oracle 的 GoldenGate.

### Mysql复制
Mysql复制经历了四代的发展: 第一代为传统复制，使用 MHA（Master High Available）架构；第二代是基于 GTID 的复制，即 GTID+Binlog server 的模式；第三代为增强半同步复制，GTID+增强半同步复制；第四代为 MySQL 原生高可用，即 MySQL InnoDB Cluster.