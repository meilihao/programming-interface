# driver
参考:
- [Linux Platform驱动模型(二) _驱动方法](https://www.cnblogs.com/xiaojiang1025/p/6367910.html)

驱动本质上只做了两件事：向上提供接口，向下控制硬件:

开发一个驱动的流程：
1. 确定驱动架构：根据硬件连接方式结合分层/分离思想设计驱动的基本结构
1. 确定驱动对象：内核中的一个驱动/设备就是一个对象，1.定义，2.初始化，3.注册，4.注销
1. 向上提供接口：根据业务需要确定提供cdev/proc/sysfs哪种接口
1. 向下控制硬件：1.查看原理图确定引脚和控制逻辑，2.查看芯片手册确定寄存器配置方式，3.进行内存映射，4.实现控制逻辑

## 地址
物理地址: CPU地址总线使用的地址, 由硬件电路控制其具体含义. 物理地址中很大一部分是留给内存的, 但也常被映射到其他存储器上（如显存、BIOS等）. 在程序指令中的虚拟地址经过段映射和页面映射后, 就生成了物理地址.

总线地址: 总线使用的地址

外设使用的是总线地址, CPU使用的是物理地址.

物理地址与总线地址之间的关系由系统的设计决定的. 在x86平台上物理地址就是总线地址, 这是因为它们共享相同的地址空间.

虚拟地址: 现代操作系统普遍采用虚拟内存管理（Virtual Memory Management）机制, 这需要MMU（Memory Management Unit）的支持. MMU通常是CPU的一部分, 如果处理器没有MMU或者有MMU但没有启用, CPU执行单元发出的内存地址将直接传到芯片引脚上, 被内存芯片（物理内存）接收，这称为物理地址（Physical Address）. 如果处理器启用了MMU, CPU执行单元发出的内存地址将被MMU截获, 从CPU到MMU的地址称为虚拟地址（Virtual Address）, 而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上, 也就是将虚拟地址映射成物理地址.

## cpu访问外设的方法
ref:
- [由于与IO地址空间相关的一些限制和不良影响, IO地址空间很快就失去了软件和硬件供应商的青睐](https://blog.csdn.net/u013253075/article/details/119491100)
- [x86 I/O端口分配表](https://bochs.sourceforge.io/techspec/PORTS.LST)


外设都是通过读写设备上的寄存器来进行访问的, 外设寄存器(通常包括控制寄存器、状态寄存器和数据寄存器三大类)也称为`I/O端口`, 而IO端口有两种编址方式：独立编址和统一编址. 而具体采用哪一种则取决于CPU的体系结构.

- 内存映射(memory-mapped, 统一编址, mmio): 此类cpu通常只实现一个物理地址空间, 会将外设 I/O端口的物理地址映射到CPU的单一物理地址空间中, 成为存储空间的一部分，通过直接读写内存地址的方式来访问外设.

	RISC指令系统的CPU（如ARM、PowerPC等）通常支持内存映射模式.

	优点: 访问速度较快, 编程比较简单
	缺点: 需要占用CPU的内存地址空间
	适用: 需要频繁访问外设的应用

	IO内存：当寄存器或内存位于内存空间时的称呼, 可通过`cat /proc/iomem`查看.
- io映射(i/o-mapped, 独立编址): 为外设专门实现了一个单独地地址空间, 称为`I/O地址空间或I/O端口空间`(32位X86有64K的IO空间, `cat /proc/ioport`). IO地址与内存地址分开独立编址, I/O端口地址不占用存储空间的地址范围. 此时在系统中就存在了另一种与存储地址无关的IO地址. 此时, 需要使用专用的CPU指令来访问某种特定外设, 比如x86的in/out等指令.

	接口的作用是连接处理器和外部设备, 处理速度不匹配, 格式转换(模拟转数字, cpu只能处理数字信号)等情况.

	> IA32 体系系统中，因为用于存储端口号的寄存器是 16 位的，所以最大有 65536 个端口，即 0～ 65535.

	x86体系的CPU均支持io映射模式.

	优点: 不占用CPU的内存地址
	缺点: 编程比较复杂, 也就是CPU访问外设时相对复杂
	适用: 需要同时访问多个外设的应用

	IO端口：当寄存器或内存位于IO空间时的称呼, 可通过`cat /proc/ioports`查看.

	**不过x86平台也支持内存映射（MMIO）, 该技术是PCI规范的一部分, 如果硬件支持MMIO, 就可将其IO设备端口映射到内存空间. 为了兼容一些之前开发的软件, PCIe仍然支持IO地址空间, 只是建议在新开发的软件中采用MMIO**.

> 控制显卡用的是内存映射+io映射.

对于Linux内核而言, 它适用于不同的CPU, 所以它必须都要考虑这两种方式, 于是它采用一种新的方法, 将基于I/O映射方式(对应于独立编址)的或内存映射方式(对应于统一编址)的I/O端口通称为`I/O区域(I/O region, include/linux/ioport.h)`, 不论采用哪种方式, 都要先申请IO区域: request_resource(), 结束时释放它: release_resource().

## 中断
单核cpu使用pic模型, 只有一张IDT; 多核使用APIC.

APIC由2部分组成:
- LAPIC

	每个core一个LAPIC, 且有一个唯一id, 该id用作区分多核cpu不同核心的标志

	每个LAPIC有自己的定时器, 能处理自己的内部中断.

	x86 LAPIC的属性在一些列的寄存器中, 它们通过mmio映射, 因此设置LAPIC定时器的中断时间就可通过mmio实现.

	LVT(Local Vector Table, 本地向量表)是联系中断信号和IDT的纽带, 是程序调度实现的关键硬件基础.

	LVT的Vector保存IDT的中断号

	获取LAPIC路径: RSDP->XSDT->MADT->LAPIC
- IO APIC

	只有一个io apic, 也有表, 可设置哪个中断由哪个cpu处理.

	处理硬盘, 网卡等外部设备产生的中断

ps: bsp(随机指定by IPI) cpu core通过IPI(Inter-Processor Interrupt, 是硬件中断)中断来唤醒其他cpu core.