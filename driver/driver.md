# driver
参考:
- [Linux Platform驱动模型(二) _驱动方法](https://www.cnblogs.com/xiaojiang1025/p/6367910.html)

驱动本质上只做了两件事：向上提供接口，向下控制硬件:

开发一个驱动的流程：
1. 确定驱动架构：根据硬件连接方式结合分层/分离思想设计驱动的基本结构
1. 确定驱动对象：内核中的一个驱动/设备就是一个对象，1.定义，2.初始化，3.注册，4.注销
1. 向上提供接口：根据业务需要确定提供cdev/proc/sysfs哪种接口
1. 向下控制硬件：1.查看原理图确定引脚和控制逻辑，2.查看芯片手册确定寄存器配置方式，3.进行内存映射，4.实现控制逻辑

## 地址
物理地址: CPU地址总线使用的地址, 由硬件电路控制其具体含义. 物理地址中很大一部分是留给内存的, 但也常被映射到其他存储器上（如显存、BIOS等）. 在程序指令中的虚拟地址经过段映射和页面映射后, 就生成了物理地址.

总线地址: 总线使用的地址

外设使用的是总线地址, CPU使用的是物理地址.

物理地址与总线地址之间的关系由系统的设计决定的. 在x86平台上物理地址就是总线地址, 这是因为它们共享相同的地址空间.

虚拟地址: 现代操作系统普遍采用虚拟内存管理（Virtual Memory Management）机制, 这需要MMU（Memory Management Unit）的支持. MMU通常是CPU的一部分, 如果处理器没有MMU或者有MMU但没有启用, CPU执行单元发出的内存地址将直接传到芯片引脚上, 被内存芯片（物理内存）接收，这称为物理地址（Physical Address）. 如果处理器启用了MMU, CPU执行单元发出的内存地址将被MMU截获, 从CPU到MMU的地址称为虚拟地址（Virtual Address）, 而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上, 也就是将虚拟地址映射成物理地址.

## 和cpu交互的数据传输方式
1. 无条件传送方式

    用此方式的数据源设备一定是随时准备好了数据, CPU 随时取随时拿都没问题, 如寄存器、内存就是类似这样的设备, CPU 取数据时不用提前打招呼
2. 查询传送方式
    
    也称为程序 I/O或PIO (Programming Input/Output Model ）, 是指传输之前, 由程序先去检测设备的状态. 数据源设备在一定的条件下才能传送数据, 这类设备通常是低速设备, 比CPU 慢很多. CPU 需要数据时, 先检查该设备的状态, 如果状态为“准备好了可以发送飞, CPU 再去获取数据. 硬盘有 status 寄存器, 里面保存了工作状态, 所以对硬盘可以用此方式来获取数据.
3. 中断传送方式

    也称为中断驱动I/O. “查询传送方式”有这样的缺陷, 由于 CPU需要不断查询设备状态, 所以意味着只有最后一刻的查询才是有意义的, 之前的查询都是发生在数据尚未准备好的时间段里，所以说效率不高，仅对于不要求速度的系统可以采用. 可以改进的地方是如果数据源设备将数据准备好后再通知 CPU 来取，这样效率就高了. 通知 CPU 可以采用中断的方式，当数据源设备准备好数据后，它通过发中断来通知 CPU 来拿数据，这样避免了 CPU花在查询上的时间，效率较高.

    bios设置的中断号从0x08开始, 但由于中断号 0x00--0x1F 属于 Intel 公司专门保留给 CPU 使用的, 为解决这个冲突Linux 操作系统不会直接使用这些 BIOS 默认设置好的中断号。在上电启动时， Linux 操作系统会在内核初始化期间又重新对 8259A 进行了设置，把所有系统硬件中断请求号全部都映射到了 0X20 及以上中断号上.
4. 直接存储器存取方式(DMA)

    在中断传送方式中，虽然极大地提高了 CPU 的利用率，但通过中断方式来通知 CPU, CPU 就要通过压找来保护现场，还要执行传输指令，最后还要恢复现场. 其实还可一点都不要浪费 CPU 资源，不让 CPU参与传输，完全由数据源设备和内存直接传输. CPU 直接到内存中拿数据就好了. 这就是此方式中“直接”的意思. 不过 DMA 是由硬件实现的, 所以需要 DMA 控制器才行.

    DMA的发起者可以是处理器, 也可以是I/O设备. 以处理器发起DMA为例, 设备驱动首先在内存中分配一块DMA缓冲区, 随后发起DMA请求, 设备收到请求后通过DMA机制将数据传输至DMA缓冲区. DMA操作完成后, 设备触发中断通知处理器对DMA缓冲区中的数据进行处理.

    在一些总线中, DMA的发起还需要DMA控制器的参与, 此时DMA控制器相当于收发双方（处理器和设备）的第三方, 因此这种机制被称为第三方DMA（third-party DMA）, 也被称为标准DMA.
5. I/O 处理机传送方式

    DMA中数据输入之后或输出之前还是有一部分工作要由 CPU 来完成的.

    I/O处理机是专门用于处理 IO, 并且它其实是一种处理器, 只不过用的是另一套擅长 IO 的指令系统，随时可以处理数据, 彻底解放CPU, 让CPU 甚至可以不知道有传输这回事.

## cpu访问外设的方法
ref:
- [由于与IO地址空间相关的一些限制和不良影响, IO地址空间很快就失去了软件和硬件供应商的青睐](https://blog.csdn.net/u013253075/article/details/119491100)
- [x86 I/O端口分配表](https://bochs.sourceforge.io/techspec/PORTS.LST)

CPU通常以读写设备寄存器的方式与设备进行通信. 一个设备通常有多个寄存器, 可以在内存地址空间或I/O地址空间中被访问. 设备寄存器可以分为如下几种类型:
1. 控制寄存器:用于接收来自驱动程序的命令
1. 状态寄存器:用于反馈当前设备的工作状态
1. 输入/输出寄存器(即数据寄存器):用于驱动和设备之间的数据交互

设备寄存器也称为`I/O端口`, 而IO端口有两种编址方式：独立编址和统一编址. 而具体采用哪一种则取决于CPU的体系结构.

- 内存映射(memory-mapped, 统一编址, mmio): 此类cpu通常只实现一个物理地址空间, 会将外设 I/O端口的物理地址映射到CPU的单一物理地址空间中, 成为存储空间的一部分，通过直接读写内存地址的方式来访问外设.

	RISC指令系统的CPU（如ARM、PowerPC等）通常支持内存映射模式.

	优点: 访问速度较快, 编程比较简单
	缺点: 需要占用CPU的内存地址空间
	适用: 需要频繁访问外设的应用

	IO内存：当寄存器或内存位于内存空间时的称呼, 可通过`cat /proc/iomem`查看.
- io映射(i/o-mapped, 独立编址): 为外设专门实现了一个单独地地址空间, 称为`I/O地址空间或I/O端口空间`(32位X86有64K的IO空间, `cat /proc/ioport`). IO地址与内存地址分开独立编址, I/O端口地址不占用存储空间的地址范围. 此时在系统中就存在了另一种与存储地址无关的IO地址. 此时, 需要使用专用的CPU指令来访问某种特定外设, 比如x86的in/out等指令.

	接口的作用是连接处理器和外部设备, 处理速度不匹配, 格式转换(模拟转数字, cpu只能处理数字信号)等情况.

	> IA32 体系系统中，因为用于存储端口号的寄存器是 16 位的，所以最大有 65536 个端口，即 0～ 65535.

	x86体系的CPU均支持io映射模式.

	优点: 不占用CPU的内存地址
	缺点: 编程比较复杂, 也就是CPU访问外设时相对复杂
	适用: 需要同时访问多个外设的应用

	IO端口：当寄存器或内存位于IO空间时的称呼, 可通过`cat /proc/ioports`查看.

	**不过x86平台也支持内存映射（MMIO）, 该技术是PCI规范的一部分, 如果硬件支持MMIO, 就可将其IO设备端口映射到内存空间. 为了兼容一些之前开发的软件, PCIe仍然支持IO地址空间, 只是建议在新开发的软件中采用MMIO**.

> 控制显卡用的是内存映射+io映射.

对于Linux内核而言, 它适用于不同的CPU, 所以它必须都要考虑这两种方式, 于是它采用一种新的方法, 将基于I/O映射方式(对应于独立编址)的或内存映射方式(对应于统一编址)的I/O端口通称为`I/O区域(I/O region, include/linux/ioport.h)`, 不论采用哪种方式, 都要先申请IO区域: request_resource(), 结束时释放它: release_resource().

## 中断
单核cpu使用pic模型, 只有一张IDT; 多核使用APIC.

APIC由2部分组成:
- LAPIC

	每个core一个LAPIC, 且有一个唯一id, 该id用作区分多核cpu不同核心的标志

	每个LAPIC有自己的定时器, 能处理自己的内部中断.

	x86 LAPIC的属性在一些列的寄存器中, 它们通过mmio映射, 因此设置LAPIC定时器的中断时间就可通过mmio实现.

	LVT(Local Vector Table, 本地向量表)是联系中断信号和IDT的纽带, 是程序调度实现的关键硬件基础.

	LVT的Vector保存IDT的中断号

	获取LAPIC路径: RSDP->XSDT->MADT->LAPIC
- IO APIC

	只有一个io apic, 也有表, 可设置哪个中断由哪个cpu处理.

	处理硬盘, 网卡等外部设备产生的中断

ps: bsp(随机指定by IPI) cpu core通过IPI(Inter-Processor Interrupt, 是硬件中断)中断来唤醒其他cpu core.